Cpp Solution:
# Intuition :
- We have to add two binary numbers (made up of 0's and 1's) and returns the result in binary.
<!-- Describe your first thoughts on how to solve this problem. -->

# Approach :
- We start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string. 
- Now we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.
- If there is any carry-over value after adding all the digits,  append it to the end of the new string. 
- Finally, the new string is reversed and returned as the sum of the two binary numbers.
<!-- Describe your approach to solving the problem. -->
# Explanation to Approach :
- Suppose we want to add two binary numbers - "1010" and "1101". 
- To add these two numbers, we can use the given function as follows:
- First, we initialize a StringBuilder object to store the sum and two integer variables 'carry' and 'i' to keep track of the carry-over value and the current position in the first binary number (a), respectively. 
- We also initialize another integer variable 'j' to keep track of the current position in the second binary number (b). Here is how the code initializes these variables:
``` 
StringBuilder sb = new StringBuilder();
int carry = 0;
int i = a.length() - 1;
int j = b.length() - 1;

``` 
- Next, we enter a while loop that iterates until we have processed all digits in both binary numbers and there is no more carry-over value left. In each iteration, we add the digits from both numbers at the current position and the carry-over value (if any), and append the result to the StringBuilder object. 
- We also update the carry-over value based on the sum of the digits. Here is the code for this step:
``` 
while (i >= 0 || j >= 0 || carry == 1) {
    if (i >= 0) {
        carry += a.charAt(i--) - '0';
    }
    if (j >= 0) {
        carry += b.charAt(j--) - '0';
    }
    sb.append(carry % 2);
    carry /= 2;
}

``` 
- In each iteration, the current position in each binary number is moved one digit to the left (if there are any digits left to process) by decrementing the value of i and j. 
- If there is a carry-over value from the previous iteration or the addition of the two digits produces a carry-over value, we set the value of 'carry' to 1; otherwise, we set it to 0. 
- We also append the sum of the digits to the StringBuilder object by computing the remainder of 'carry' divided by 2 (which is either 0 or 1). 
- Finally, we update the value of 'carry' by dividing it by 2 (which gives either 0 or 1) so that we can carry over any remaining value to the next iteration.
- After the while loop completes, we reverse the StringBuilder object and convert it to a string using the toString() method. 
- This gives us the sum of the two binary numbers in binary format. Here is the final code:
``` 
return sb.reverse().toString();

``` 
# Example : the sum of "1010" and "1101
``` 
     1010
    +1101
    ______
    10111
``` 

# Complexity
- Time complexity : O(max|a|,|b|)
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

- Space complexity : O(max|a|,|b|)
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
# Please Upvote
``` 
Thanks for visiting my solution.
``` 
# Codes [C++ |Java |Python3] 
``` C
Language: C++ 
class Solution {
 public:
  string addBinary(string a, string b) {
    string ans;
    int carry = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += a[i--] - '0';
      if (j >= 0)
        carry += b[j--] - '0';
      ans += carry % 2 + '0';
      carry /= 2;
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};
``` 
``` Java
Language: Java 
class Solution 
{
  public String addBinary(String a, String b) 
  {
    StringBuilder sb = new StringBuilder();
    int carry = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;

    while (i >= 0 || j >= 0 || carry == 1) 
    {
      if(i >= 0)
        carry += a.charAt(i--) - '0';
      if(j >= 0)
        carry += b.charAt(j--) - '0';
      sb.append(carry % 2);
      carry /= 2;
    }
    return sb.reverse().toString();
  }
}
``` 
``` Python3
Language: Python3 
class Solution:
  def addBinary(self, a: str, b: str) -> str:
    s = 
    carry = 0
    i = len(a) - 1
    j = len(b) - 1

    while i >= 0 or j >= 0 or carry:
      if i >= 0:
        carry += int(a[i])
        i -= 1
      if j >= 0:
        carry += int(b[j])
        j -= 1
      s.append(str(carry % 2))
      carry //= 2

    return ''.join(reversed(s))
``` 
# Please Upvote
![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/fe5d77d5-39f2-4839-9fcf-41c50106b04f_1676347139.1033723.gif)




Python Solution:
``` 
													# IMPORTANT INFO FOR YOU
``` 
* If, you are preperaing for `FACEBOOK interview` or will prepare. Then according to `LeetCode premium` it is no.4 most asked Question by **Facebook** as per now.

**So Ladies n Gentlemen without any further due let's start,**
`What question saying is, Given two binary strings a and b, return their sum as a binary string.`

**Approach Explained :**

**Summary of Below Explanation :**

*The overall idea is to make up the short two strings with 00 to make the two strings have the same length, and then traverse and calculate from the end to get the final result.*

Let's understand with an **example** : Addition of **1 and 1** will lead to **carry 1** and **print 0** , Addition of **1 and 0** give us **1 as carry** will lead **print 0** , Addition of last remaning **carry 1** with no body will lead to **print 1** , So, we get something like **"1 0 0"** as answer
One **key point** total addition will be 3 then print 1 and carry will remain 1

**Detailed Explaination :**

So, first do we understand how do we perform **binary addition**. **Take an example**, given two numbers **"11" + "1"** where **"11"** is representing **"3"** & **"1"** is **"1"**, in decimal form. 
Now let's perform **binary addition** it's very **similar to the decimal addition** that we do. In decimal what we do we add 2 numbers & if it goes beyond 9 we **take a carry**. And here also we have a **number in range 0 - 1**, **2 values over here** & in **Decimal range is 0 - 9**, **10 values** are there. So, in binary what it means is if result more **than 1**, there **is a carry** otherwise **no carry**.
Let me show you in diagram:
![image](https://assets.leetcode.com/users/images/fcd956d9-2703-41fe-90ad-57c49e227799_1641778567.285665.png)


* So, what's going in diagram is **intially carry is "0"** we **add 1 + 1** we **get 2** which is more **then 1**, so there is a **carry of 1** and **result is 0**. Now we have **carry of 1**, **again 1 + 1 is 0**, and still left with **carry of 1**. And the **last carry** one will be **return as it is**. 
* So, if you see this binary number it is **[2^2 * 1 + 2^1 * 0 + 2^0 * 0]** and this is the decimal coversion of **[1 0 0]** which **is 4**. 

![image](https://assets.leetcode.com/users/images/b12c2264-ddf0-4709-a761-4bfa3becdd95_1641779179.1482372.png)

**Hope you got the point **

*Now, let's code it up:*
**code, each lne explained :** `Similar for C++, Java, Python` **{Only synatx difference}** approach is same

* Step 1:
``` 
{
// First, create result name string and intially it is empty & in the end we gonna return it as our aswer
        StringBuilder res = new StringBuilder(); 
        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left 
        int j = b.length() - 1; // similar pointer j for string b
        int carry = 0; // we create a carry, as we have to consider it as well
``` 
* Step 2:
``` 
// iterate over the loop until the both condition become false
        while(i >= 0 || j >= 0){ 
            int sum = carry; // intialise our sum with carry;
            
            // Now, we subtract by '0' to convert the numbers from a char type into an int, so we can perform operations on the numbers
            if(i >= 0) sum += a.charAt(i--) - '0';
            if(j >= 0) sum += b.charAt(j--) - '0';
            // taking carry;
            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 
			// if sum is 0 res is 1 & then carry would be 0;
            // if sum is 1 res is 1 & carry would be 0
            // if sum is 2 res is 0 & carry would be 1
            // if sum is 3 res is 1 & carry would be 1
            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result
        }
``` 
* Final Step:
``` 
if(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;
        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;
``` 
* Let's combine each line of code


**Java**
``` 
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder res = new StringBuilder();
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        while(i >= 0 || j >= 0){
            int sum = carry;
            if(i >= 0) sum += a.charAt(i--) - '0';
            if(j >= 0) sum += b.charAt(j--) - '0';
            carry = sum > 1 ? 1 : 0;
            res.append(sum % 2);
        }
        if(carry != 0) res.append(carry);
        return res.reverse().toString();
    }
}
``` 
**C++**
``` 
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        while(i >= 0 || j >= 0){
            int sum = carry;
            if(i >= 0) sum += a[i--] - '0';
            if(j >= 0) sum += b[j--] - '0';
            carry = sum > 1 ? 1 : 0;
            res += to_string(sum % 2);
        }
        if(carry) res += to_string(carry);
        reverse(res.begin(), res.end());
        return res;
    }
};
``` 
**Python**
``` 
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        res = ""
        i, j, carry = len(a) - 1, len(b) - 1, 0
        while i >= 0 or j >= 0:
            sum = carry;
            if i >= 0 : sum += ord(a[i]) - ord('0') # ord is use to get value of ASCII character
            if j >= 0 : sum += ord(b[j]) - ord('0')
            i, j = i - 1, j - 1
            carry = 1 if sum > 1 else 0;
            res += str(sum % 2)

        if carry != 0 : res += str(carry);
        return res[::-1]
``` 
ANALYSIS :-
* **Time Complexity :-** BigO(max(M, N)), M & N is the length of string a, b;

* **Space Complexity :-** BigO(max(M, N)), which is the size of "res" object

**Guy's if you find this solution helpful , PLEASE do UPVOTE. By doing that it motivate's me to create more better post like this ✍️**
`If you have some  doubts feel free to bug me`