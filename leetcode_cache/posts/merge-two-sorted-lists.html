Cpp Solution:
**C++**

The first line ensures that `a` is at least as good a list head as `b`, by swapping them if that's not already the case. The second line merges the remaining lists behind `a`.

    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {
        if (!a || b && a->val > b->val) swap(a, b);
        if (a) a->next = mergeTwoLists(a->next, b);
        return a;
    }

---

**C**

Same solution, I just have to replace C++'s `swap`. I'm not sure whether evaluation order is standardized, but it worked and got accepted this way.

    struct ListNode* mergeTwoLists(struct ListNode* a, struct ListNode* b) {
        if (!a || b && a->val > b->val) a += b - (b = a);
        if (a) a->next = mergeTwoLists(a->next, b);
        return a;
    }


Python Solution:
**UPVOTE if you like (◠‿◠), If you have any question, feel free to ask.**

For simplicity, we create a dummy node to which we attach nodes from lists. We iterate over lists using two-pointers and build up a resulting list so that values are monotonically increased.

Time: **O(n)**
Space: **O(1)**

``` 
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        cur = dummy = ListNode()
        while list1 and list2:               
            if list1.val < list2.val:
                cur.next = list1
                list1, cur = list1.next, list1
            else:
                cur.next = list2
                list2, cur = list2.next, list2
                
        if list1 or list2:
            cur.next = list1 if list1 else list2
            
        return dummy.next
``` 

**UPVOTE if you like (◠‿◠), If you have any question, feel free to ask.**