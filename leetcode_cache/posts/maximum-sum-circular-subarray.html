Cpp Solution:
 Exciting News! Join my Coding Journey! Subscribe Now! 

 Link in the leetcode profile 

New coding channel alert!  Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! 

Thanks for your support! 
# Approach
There are 2 possibility of The **maximum subarray sum in circular array** 
1. **Maximum subarray sum in non circular array**
   - If max subarray sum in non circular array then we can simply apply Kadane's Algorithm and we will calculate the max_sum_subarray
   -  Example A=[-3,-5,**3,5,7,3,5**,-9] ans= 23
   
2.**Maximum subarray sum in circular array.**
   - If max subarray sum in circular array then we will calculate the `minimum sum of subarray` and **Subtract** it from `total_sum` of array.
   - Example A=[11,1,-17,2,-15,9,13]
    
![circular.png](https://assets.leetcode.com/users/images/7ef7d266-0bc5-41d0-9c75-44b77a1f9000_1674004416.8592637.png)
 
   - Here we will remove {17,2,-15} from our total sum that will give us max subarray sum because max sum include some prefix and suffix part:- 
Ans= max(prefix+suffix)
Ans= max(total sum - subarray)
Ans=total sum + max(-subarray)
**Ans= total sum - min(subarray)**
3. **Corner case -When all the element in the array are negative** then our answer will be `max_sum_subarray` because if when all the element are negative at that time our `total_sum - minsum_subary=0`
and it will return 0 means empty subarray thats why we will return max sum of subarray

4. **At last we will return**
   max(subarray sum in non circular array,Maximum subarray sum in circular array)
  
   


# Complexity
- Time complexity:O(N)
- Space complexity:O(1)

# Code
``` 
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& A) {
        int total_sum=0,curr_sum1=0,curr_sum2=0,mxsum_subary=INT_MIN,minsum_subary=INT_MAX;   
        for(auto i:A)
        {
            total_sum+=i; curr_sum1+=i; curr_sum2+=i;
            mxsum_subary=max(mxsum_subary,curr_sum1);
            if(curr_sum1<0) curr_sum1=0;
           minsum_subary=min(curr_sum2,minsum_subary);
            if(curr_sum2>0) curr_sum2=0;
        }
        return (total_sum==minsum_subary)?mxsum_subary:max(mxsum_subary,total_sum-minsum_subary);  
    }
};
``` 
If you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.
**Let me know in comment if i can do better**.
Let's connect on **[LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)**

![upvote.jfif](https://assets.leetcode.com/users/images/0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg)



Python Solution:
## **Kadane's Algorithm**

**Problem 918 : [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)**

``` python
Language: python
class Solution:
    def maxSubarraySumCircular(self, A: List[int]) -> int:
    
        # Method 1 : Kadane's Algorithm
        if max(A) <= 0:
            return max(A)
        
        max_sum = curr_max = min_sum = curr_min = A[0] 
        
        for i in range(1, len(A)): 
            curr_max = max(A[i], curr_max + A[i]) 
            max_sum = max(max_sum, curr_max)
            curr_min = min(A[i], curr_min + A[i]) 
            min_sum = min(min_sum, curr_min)
            
        return max(max_sum, sum(A) - min_sum)
            
        '''
        # Method 2 : Dynamic Programming
        if max(A) <= 0:
            return max(A)
            
        max_dp = [i for i in A]
        min_dp = [i for i in A]
        
        for i in range(1,len(A)):
            if max_dp[i-1] > 0:
                max_dp[i] += max_dp[i-1]
            if min_dp[i-1] < 0:
                min_dp[i] += min_dp[i-1]

        return max(max(max_dp), sum(A) - min(min_dp))
		'''
		
``` 


**Problem 152 : [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)**

``` python
Language: python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums:
            return 0
        max_prod = prev_max = prev_min =  nums[0] 
        for i in range(1, len(nums)): 
            curr_min = min(prev_max * nums[i], prev_min * nums[i], nums[i]) 
            curr_max = max(prev_max * nums[i], prev_min * nums[i], nums[i])
            prev_min, prev_max = curr_min, curr_max
            max_prod = max(curr_max, max_prod)    
        return max_prod
		
``` 


**Problem 53 : [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**

``` python
Language: python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum = curr = nums[0] 
        for i in range(1, len(nums)): 
            curr = max(nums[i], curr + nums[i]) 
            max_sum = max(max_sum, curr)    
        return max_sum 
		
``` 
