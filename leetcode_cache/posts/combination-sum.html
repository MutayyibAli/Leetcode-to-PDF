Cpp Solution:
Similar idea from the problem [coin-change-2](https://leetcode.com/problems/coin-change-2/) .
it is simplest and fastest dp solution, we don't need to sort elements 
``` 
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& nums, int target) {
		// dp vector to store all possible combinations of the target sum
        vector <vector <vector <int>>> dp(target+1);
        dp[0]={{}};
        for(int &i:nums)
        {
		// Iterating through all the elements from array nums aka candidates
            for(int j=i;j<=target;j++)
            {
			// Finding all possible ways to achieve sum j from element i
                for(auto v:dp[j-i])
                {
                    v.push_back(i);
                    dp[j].push_back(v);
                }
            }
        }
		// Finally, returning our ans 
        return dp[target];
    }
};
``` 
If you liked this solution please upvote if you have any query plz comment below 


Python Solution:
``` 
class Solution(object):
    def combinationSum(self, candidates, target):
        ret = 
        self.dfs(candidates, target, , ret)
        return ret
    
    def dfs(self, nums, target, path, ret):
        if target < 0:
            return 
        if target == 0:
            ret.append(path)
            return 
        for i in range(len(nums)):
            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)
``` 