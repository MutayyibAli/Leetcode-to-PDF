Cpp Solution:
 Exciting News! Join my Coding Journey! Subscribe Now! 

 Link in the leetcode profile 

New coding channel alert!  Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! 

Thanks for your support! 
# Intuition
Here we will apply greedy approach

# Approach
In the question given that
**If there exists a solution, it is guaranteed to be unique**
-This lines clearly tells us that we have unique or no solution exists

*Here two cases are possible*
1. if our **total_gas is less than our total cost** in that case we can't complete our journey ,so will return -1
2. Now we have a unique solution that means single **starting_point** exists
3. To find that point we will **keep track of my current_gas+=gas[i]-cost[i]**
  - lets suppose at any index our current gas became negative so we can clearly say that till that index all the gas station between ith and starting point are bad,  starting point as well.
So, this means we can start trying at next gas_station on the i+1 station

# Complexity
- Time complexity:O(N)
- Space complexity:O(1)

# Code(C++)
``` 
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n=gas.size();
        int total_gas=0,total_cost=0;
        int curr_gas=0, starting_point=0;
        for(int i=0;i<n;i++)
        {
            //these two variable are to check if no case is possible
            total_gas+=gas[i];
            total_cost+=cost[i];
            //for checking the total present gas at index i
            curr_gas+=gas[i]-cost[i];
            if(curr_gas<0)
            {
               //there is a breakdown....so we will start from next point or index
                starting_point=i+1;
                //reset our fuel 
                curr_gas=0;
            }
        }
        return (total_gas<total_cost)?-1:starting_point;     
    }
};
``` 
If you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.
Lets connect on [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/) Or [Telegram](https://t.me/mahesh_vishnoi29)



Python Solution:
``` C
Language: C++ 
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n = cost.size(), bal = 0, start = 0, deficit = 0;

        for(int i = 0; i< n; i++){
            bal += gas[i] - cost[i];

            if(bal < 0){

                deficit += bal;
                start = i+1;
                bal = 0;
            }
        }
        return bal + deficit >= 0 ? start : -1;
    }
};
``` 

``` Python3
Language: Python3 
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost): return -1
        tank = idx = 0
        for i in range(len(gas)):
            tank+= gas[i]-cost[i] 
            if tank < 0: tank, idx = 0, i+1
        return idx 

        print(f"cost: {cost}")
        print(f"gas: {gas}")
        tank = 0
        for i in range(len(cost)):
            # find where we can start
            if cost[i] > gas[i]+tank:
                continue
            start = i    
            tank += gas[i]
            print("tank", tank)
            for j in range(start+1, len(cost)):
                if cost[i] > gas[i]:
                    print("inside", j)
        return -1
``` 

``` Java
Language: Java 
class Solution {
    public int canCompleteCircuit(int gas, int cost) {
        int sGas = 0, sCost = 0, res = 0, total = 0;
        for (int i = 0; i < gas.length; i++) {
            sGas += gas[i];
            sCost += cost[i];
        }
        if (sGas < sCost) return -1;
        for (int i = 0; i < gas.length; i++) {
            total += gas[i] - cost[i];
            if (total < 0) {
                total = 0;
                res = i + 1;
            }
        }
        return res;
    }
}
``` 
