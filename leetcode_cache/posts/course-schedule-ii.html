Cpp Solution:
Similar to [Course Schedule](https://leetcode.com/problems/course-schedule/ ), during the process of visiting the nodes, store them in order to a `vector`. In DFS, you may need an additional `reverse`.

**BFS**

``` cpp
Language: cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector<int> degrees = computeIndegrees(g);
        vector<int> order;
        for (int i = 0; i < numCourses; i++) {
            int j = 0;
            for (; j < numCourses; j++) {
                if (!degrees[j]) {
                    order.push_back(j);
                    break;
                }
            }
            if (j == numCourses) {
                return {};
            }
            degrees[j]--;
            for (int v : g[j]) {
                degrees[v]--;
            }
        }        
        return order;
    }
private:
    typedef vector<vector<int>> graph;
    
    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }
    
    vector<int> computeIndegrees(graph& g) {
        vector<int> degrees(g.size(), 0);
        for (auto adj : g) {
            for (int v : adj) {
                degrees[v]++;
            }
        }
        return degrees;
    }
};
``` 

**DFS**

``` cpp
Language: cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector<int> order;
        vector<bool> todo(numCourses, false), done(numCourses, false);
        for (int i = 0; i < numCourses; i++) {
            if (!done[i] && !acyclic(g, todo, done, i, order)) {
                return {};
            }
        }
        reverse(order.begin(), order.end());
        return order;
    }
private:
    typedef vector<vector<int>> graph;
    
    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }
    
    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node, vector<int>& order) {
        if (todo[node]) {
            return false;
        }
        if (done[node]) {
            return true;
        }
        todo[node] = done[node] = true;
        for (int neigh : g[node]) {
            if (!acyclic(g, todo, done, neigh, order)) {
                return false;
            }
        }
        order.push_back(node);
        todo[node] = false;
        return true;
    }
};
``` 


Python Solution:
Runs takes 80ms

    class Solution:
        # @param {integer} numCourses
        # @param {integer} prerequisites
        # @return {integer}
        def findOrder(self, numCourses, prerequisites):
            # use DFS to parse the course structure
            self.graph = collections.defaultdict(list) # a graph for all courses
            self.res =  # start from empty
            for pair in prerequisites:
                self.graph[pair[0]].append(pair[1]) 
            self.visited = [0 for x in xrange(numCourses)] # DAG detection 
            for x in xrange(numCourses):
                if not self.DFS(x):
                    return 
                 # continue to search the whole graph
            return self.res
        
        def DFS(self, node):
            if self.visited[node] == -1: # cycle detected
                return False
            if self.visited[node] == 1:
                return True # has been finished, and been added to self.res
            self.visited[node] = -1 # mark as visited
            for x in self.graph[node]:
                if not self.DFS(x):
                    return False
            self.visited[node] = 1 # mark as finished
            self.res.append(node) # add to solution as the course depenedent on previous ones
            return True