Cpp Solution:
To appy DP, we define the state as the maximal **size** (square = size * size) of the square that can be formed till point `(i, j)`, denoted as `dp[i][j]`.

For the topmost row (`i = 0`) and the leftmost column (`j = 0`), we have `dp[i][j] = matrix[i][j] - '0'`, meaning that it can at most form a square of size 1 when the matrix has a `'1'` in that cell.

When `i > 0` and `j > 0`, if `matrix[i][j] = '0'`, then `dp[i][j] = 0` since no square will be able to contain the `'0'` at that cell. If `matrix[i][j] = '1'`, we will have `dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`, which means that the square will be limited by its left, upper and upper-left neighbors.

``` cpp
Language: cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!i || !j || matrix[i][j] == '0') {
                    dp[i][j] = matrix[i][j] - '0';
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
                sz = max(dp[i][j], sz);
            }
        }
        return sz * sz;
    }
};
``` 

In the above code, it uses `O(mn)` space. Actually each time when we update `dp[i][j]`, we only need `dp[i-1][j-1]`, `dp[i-1][j]` (the previous row) and `dp[i][j-1]` (the current row). So we may just keep two rows.

``` cpp
Language: cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0;
        vector<int> pre(n, 0), cur(n, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!i || !j || matrix[i][j] == '0') {
                    cur[j] = matrix[i][j] - '0';
                } else {
                    cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1;
                }
                sz = max(cur[j], sz);
            }
            fill(pre.begin(), pre.end(), 0);
            swap(pre, cur);
        }
        return sz * sz;
    }
};
``` 

Furthermore, we may only use just one `vector` (thanks to @stellari for sharing the idea).

``` cpp
Language: cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0, pre;
        vector<int> cur(n, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int temp = cur[j];
                if (!i || !j || matrix[i][j] == '0') {
                    cur[j] = matrix[i][j] - '0';
                } else {
                    cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1;
                }
                sz = max(cur[j], sz);
                pre = temp;
            }
        }
        return sz * sz;
    }
};
``` 


Python Solution:
**Understanding basics**
![image](https://assets.leetcode.com/users/arkaung/image_1587997244.png)

* Here I want to mention that we are drawing squares from top left corner to bottom right corner. Therefore, when I mention, "surrounding elements", I am saying cells above the corner cell and the cells on the left of the corner cell.

**Building DP grid to memoize**
* We are going to create a `dp` grid with initial values of 0.
* We are going to update `dp` as described in the following figure. 

![image](https://assets.leetcode.com/users/arkaung/image_1587997873.png)

**Bigger Example**
* Let's try to see a bigger example.
* We go over one cell at a time row by row in the `matrix` and then update our `dp` grid accordingly. 
* Update `max_side` with the maximum `dp` cell value as you update.

![image](https://assets.leetcode.com/users/arkaung/image_1588005144.png)



In the code, I create a `dp` grid which has one additional column and one additional row. The reason is to facilitate the index dp[r-1][c] dp[r][c-1] and dp[r-1][c-1] for cells in first row and first column in `matrix`.

```  python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if matrix is None or len(matrix) < 1:
            return 0
        
        rows = len(matrix)
        cols = len(matrix[0])
        
        dp = [[0]*(cols+1) for _ in range(rows+1)]
        max_side = 0
        
        for r in range(rows):
            for c in range(cols):
                if matrix[r][c] == '1':
                    dp[r+1][c+1] = min(dp[r][c], dp[r+1][c], dp[r][c+1]) + 1 # Be careful of the indexing since dp grid has additional row and column
                    max_side = max(max_side, dp[r+1][c+1])
                
        return max_side * max_side
                
``` 

**Complexity Analysis**

Time complexity : `O(mn)`. Single pass - `row x col (m=row; n=col)`
Space complexity : `O(mn)`. Additional space for `dp` grid (don't need to worry about additional 1 row and col).

**Follow up**
Space can be optimized as we don't need to keep the whole `dp` grid as we progress down the rows in `matrix`.

Aren't Dynamic Programming problems much like this joke? :D
![image](https://assets.leetcode.com/users/arkaung/image_1587998641.png)

