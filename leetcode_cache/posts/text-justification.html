Cpp Solution:
``` C
Language: C++ 
class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> res;
        const int n = words.size();
        int begin = 0, len = 0;
        for (int i = 0; i < n; ++i) {
            if (len + words[i].size() + (i - begin) > maxWidth) {
                res.emplace_back(connect(words, maxWidth, begin, i, len, false));
                begin = i;
                len = 0;
            }
            len += words[i].size();
        }
        res.emplace_back(connect(words, maxWidth, begin, n, len, true));
        return res;
    }
private:
    string connect(const vector<string>& words, int maxWidth,
                   int begin, int end, int len,
                   bool is_last) {
        string s;
        int n = end - begin;
        for (int i = 0; i < n; ++i) {
            s += words[begin + i];
            addSpaces(i, n - 1, maxWidth - len, is_last, &s);
        }
        if (s.size() < maxWidth) {
            s.append(maxWidth - s.size(), ' ');
        }
        return s;
    }
    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {
        if (i < spaceCnt) {
            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);
            s->append(spaces, ' ');
        }
    }
};
``` 

``` Python3
Language: Python3 
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res = 
        
        cur_wlist  = 
        cur_ch_cnt = 0   # for the space consideration
     
        for w in words: 
            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:
                for i in range(maxWidth - cur_ch_cnt):  # insert space
                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += ' '
               
                res.append(''.join(cur_wlist)) # insert a this row 
                cur_wlist, cur_ch_cnt = , 0 # prepare a new row, resetting
                
            cur_wlist += [w]
            cur_ch_cnt += len(w)
            
        return res + [' '.join(cur_wlist).ljust(maxWidth)]
``` 

``` Java
Language: Java 
class Solution {
    public List<String> fullJustify(String words, int maxWidth) {

        List<String> result = new ArrayList<>();

        int word = 0;

        while(word<words.length){

            int j = word-1;
            int characters = 0;


            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)
            {
                j++;
                characters+=words[j].length();
            }
            result.add(line(words , word , j, characters , maxWidth));
            word = j+1;
        }
        return result;
    }
      public String line(String words,int start,int end, int Linelen,int max)
    {
        StringBuilder a = new StringBuilder();
        int p=1,q=0;
        if(end!=start)
        {
            p=(max-Linelen)/(end-start);
            q=(max-Linelen)%(end-start);
        }
        
        for(int i=start;i<=end;i++)
        {
            a.append(words[i]);
            if(i!=end)
            {
                if(end==words.length-1) a.append(" ");
                else {
                    for(int j=1;j<=p;j++) a.append(" ");
                    if(q-->=1) a.append(" ");
                }
            }
        }
        while(a.length()<max) a.append(" ");
        return a.toString();
    }
}
``` 



Python Solution:
--------------------------------------------

    def fullJustify(self, words, maxWidth):
        res, cur, num_of_letters = , , 0
        for w in words:
            if num_of_letters + len(w) + len(cur) > maxWidth:
                for i in range(maxWidth - num_of_letters):
                    cur[i%(len(cur)-1 or 1)] += ' '
                res.append(''.join(cur))
                cur, num_of_letters = , 0
            cur += [w]
            num_of_letters += len(w)
        return res + [' '.join(cur).ljust(maxWidth)]

How does it work? Well in the question statement, the sentence "Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: 

    for i in range(maxWidth - num_of_letters):
                    cur[i%(len(cur)-1 or 1)] += ' '

What does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The "or 1" part is for dealing with the edge case len(cur) == 1.

###### Note: I found that this problem & solution is directly being used in the "Elements of Programming Interviews in Python" book. Cool I guess, but the book should include an acknowledgement or link to this source.
--------------------------------------------

The following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.

    def fullJustify(self, words, maxWidth):
        res, cur, num_of_letters = , , 0
        for w in words:
            if num_of_letters + len(w) + len(cur) > maxWidth:
                if len(cur) == 1:
                    res.append( cur[0] + ' '*(maxWidth - num_of_letters) )
                else:
                    num_spaces = maxWidth - num_of_letters
                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)
                    for i in range(num_extra_spaces):
                        cur[i] += ' '
                    res.append( (' '*space_between_words).join(cur) )
                cur, num_of_letters = , 0
            cur += [w]
            num_of_letters += len(w)
        res.append( ' '.join(cur) + ' '*(maxWidth - num_of_letters - len(cur) + 1) )
        return res