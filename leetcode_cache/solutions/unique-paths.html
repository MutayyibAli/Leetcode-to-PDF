<div class='cpp-solution'><h4>C++ DP [Votes: 1579]</h4><p>Since the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use <code>dp[i][j]</code> for the number of unique paths to arrive at the point <code>(i, j)</code>, then the state equation is <code>dp[i][j] = dp[i][j - 1] + dp[i - 1][j]</code>. Moreover, we have the base cases <code>dp[0][j] = dp[i][0] = 1</code> for all valid <code>i</code> and <code>j</code>.</p>
<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
</code></pre>
<p>The above solution runs in <code>O(m * n)</code> time and costs <code>O(m * n)</code> space. However, you may have noticed that each time when we update <code>dp[i][j]</code>, we only need <code>dp[i - 1][j]</code> (at the previous row) and <code>dp[i][j - 1]</code> (at the current row). So we can reduce the memory usage to just two rows (<code>O(n)</code>).</p>
<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; pre(n, 1), cur(n, 1);
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                cur[j] = pre[j] + cur[j - 1];
            }
            swap(pre, cur);
        }
        return pre[n - 1];
    }
};
</code></pre>
<p>Further inspecting the above code, <code>pre[j]</code> is just the <code>cur[j]</code> before the update. So we can further reduce the memory usage to one row.</p>
<pre><code>class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; cur(n, 1);
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                cur[j] += cur[j - 1];
            }
        }
        return cur[n - 1];
    }
};
</code></pre>
<p>Now, you may wonder whether we can further reduce the memory usage to just <code>O(1)</code> space since the above code seems to use only two variables (<code>cur[j]</code> and <code>cur[j - 1]</code>). However, since the whole row <code>cur</code> needs to be updated for <code>m - 1</code> times (the outer loop) based on old values, all of its values need to be saved and thus <code>O(1)</code>-space is impossible. However, if you are having a DP problem without the outer loop and just the inner one, then it will be possible.</p></div><div class='python-solution'><h4>✅ 98.83% Easy DP & Math [Votes: 182]</h4><h4>Interview Guide - Unique Paths in a Grid</h4>
<h5>Problem Understanding</h5>
<p>The problem describes a robot situated on a $$ m \times n $$ grid, starting at the top-left corner (i.e., $$ \text{grid}[0][0] $$). The robot can move either to the right or downwards at any given time, and the objective is to reach the bottom-right corner of the grid. The challenge is to find the number of unique paths the robot can take to reach this goal.</p>
<h6>Key Points to Consider</h6>
<ol>
<li>
<p><strong>Grid Dimensions</strong>:<br />
   The grid dimensions are $$ m $$ (rows) and $$ n $$ (columns), with $$ 1 \leq m, n \leq 100 $$.</p>
</li>
<li>
<p><strong>Movement Constraints</strong>:<br />
   The robot can only move either down or to the right at any given point. It cannot move diagonally or backwards.</p>
</li>
<li>
<p><strong>Dynamic Programming and Combinatorial Mathematics</strong>:<br />
   The problem can be solved using either a Dynamic Programming approach or using Combinatorial Mathematics.</p>
</li>
</ol>
<h5>Live Coding &amp; More - 3 Solutions</h5>
<p>https://youtu.be/-0OSF4u0cjQ?si=zup18xLotShahabI</p>
<h5>Solution #1: Dynamic Programming</h5>
<h6>Intuition and Logic Behind the Solution</h6>
<p>The idea behind this approach is to use a 2D Dynamic Programming (DP) array to store the number of unique paths to each cell. A cell $$ (i, j) $$ can be reached either from $$ (i-1, j) $$ or $$ (i, j-1) $$, and thus the number of unique paths to $$ (i, j) $$ is the sum of the number of unique paths to these two cells.</p>
<h6>Step-by-step Explanation</h6>
<ol>
<li>
<p><strong>Initialization</strong>: </p>
<ul>
<li>Create a $$ m \times n $$ DP array, initializing the first row and first column to 1 because there's only one way to reach those cells from the starting point.</li>
</ul>
</li>
<li>
<p><strong>Main Algorithm</strong>:  </p>
<ul>
<li>Iterate over the DP array starting from cell $$ (1, 1) $$.</li>
<li>For each cell $$ (i, j) $$, set $$ \text{dp}[i][j] = \text{dp}[i-1][j] + \text{dp}[i][j-1] $$.</li>
</ul>
</li>
</ol>
<h6>Complexity Analysis</h6>
<ul>
<li><strong>Time Complexity</strong>: $$ O(m \times n) $$ — We iterate through each cell once.</li>
<li><strong>Space Complexity</strong>: $$ O(m \times n) $$ — For the DP array.</li>
</ul>
<h5>Solution #2: Memory-Optimized Dynamic Programming</h5>
<h6>Intuition and Logic Behind the Solution</h6>
<p>The original DP solution used a $$ m \times n $$ array to store the number of unique paths to each cell. However, since we only need information from the previous row and the current row to compute the number of unique paths for a given cell, we can optimize the solution to use only two rows at a time. This reduces the space complexity from $$ O(m \times n) $$ to $$ O(n) $$.</p>
<h6>Transitioning from $$ O(m \times n) $$ to $$ O(n) $$</h6>
<p>In the original $$ O(m \times n) $$ approach, we used a 2D array <code>dp</code> where $$ \text{dp}[i][j] $$ represented the number of unique paths to reach cell $$ (i, j) $$. To optimize this to $$ O(n) $$, we can maintain only two 1D arrays: <code>prev_row</code> and <code>curr_row</code>, each of length $$ n $$.</p>
<ul>
<li><code>prev_row[j]</code> will represent $$ \text{dp}[i-1][j] $$, the number of unique paths to reach the cell in the previous row and $$ j $$-th column.</li>
<li><code>curr_row[j]</code> will represent $$ \text{dp}[i][j] $$, the number of unique paths to reach the cell in the current row and $$ j $$-th column.</li>
</ul>
<h6>Step-by-step Explanation</h6>
<ol>
<li><strong>Initialization</strong>:  </li>
<li>
<p>Initialize two 1D arrays <code>curr_row</code> and <code>prev_row</code> with $$ n $$ elements, setting all elements to 1.</p>
</li>
<li>
<p><strong>Main Algorithm</strong>:  </p>
</li>
<li>Iterate over the rows starting from 1 (the second row).</li>
<li>For each cell $$ (i, j) $$, set  <code>curr_row[j] = curr_row[j-1] + prev_row[j]</code> .</li>
<li>Swap <code>curr_row</code> and <code>prev_row</code> for the next iteration.</li>
</ol>
<h6>Complexity Analysis</h6>
<ul>
<li><strong>Time Complexity</strong>: $$ O(m \times n) $$ — We still iterate through each cell once.</li>
<li><strong>Space Complexity</strong>: $$ O(n) $$ — For the two 1D arrays.</li>
</ul>
<h5>Solution #3: Combinatorial Mathematics</h5>
<h6>Intuition</h6>
<p>The number of unique paths can be seen as the number of ways to choose $$ m-1 $$ downs and $$ n-1 $$ rights, regardless of the order. In combinatorial terms, this is equivalent to $$ \binom{m+n-2}{m-1} $$.</p>
<h6>Algorithm</h6>
<ol>
<li>
<p><strong>Use the Combinatorial Formula</strong>:<br />
   $$ \binom{m+n-2}{m-1} $$ or $$ \binom{m+n-2}{n-1} $$ to calculate the number of unique paths.</p>
</li>
<li>
<p><strong>Python's Math Library</strong>:<br />
   Python provides a built-in function $$ \text{math.comb(n, k)} $$ to calculate $$ \binom{n}{k} $$ efficiently.</p>
</li>
</ol>
<h6>Complexity Analysis</h6>
<ul>
<li><strong>Time Complexity</strong>: $$ O(m) $$ or $$ O(n) $$ — For calculating the combination.</li>
<li><strong>Space Complexity</strong>: $$ O(1) $$ — Constant space.</li>
</ul>
<h4>Performance</h4>
<h6>Dynamic Programming</h6>
<p>| Language  | Time (ms) | Memory (MB) |
|-----------|-----------|-------------|
| Rust      | 0 ms      | 2.2 MB      |
| cpp       | 0 ms      | 6.5 MB      |
| Java      | 0 ms      | 39.9 MB     |
| Go        | 1 ms      | 2.1 MB      |
| PHP       | 10 ms     | 19.3 MB     |
| C####        | 23 ms     | 26.6 MB     |
| Python3 (1D)   | 26 ms     | 16.3 MB     |
| Python3 (2D)  | 28 ms     | 16.3 MB     |
| JavaScript| 52 ms     | 41.6 MB     |</p>
<h5>Combinatorial Mathematics</h5>
<p>| Language  | Time (ms) | Memory (MB) |
|-----------|-----------|-------------|
| Rust      | 0 ms      | 2.2 MB      |
| cpp       | 0 ms      | 5.9 MB      |
| PHP       | 0 ms      | 18.9 MB     |
| Java      | 0 ms      | 39.8 MB     |
| Go        | 1 ms      | 1.9 MB      |
| C####        | 22 ms     | 26.5 MB     |
| Python3   | 27 ms     | 16.4 MB     |
| JavaScript| 55 ms     | 41.3 MB     |</p>
<h4>Code Math</h4>
<pre><code class="language-Python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        return math.comb(m+n-2, m-1)
</code></pre>
<pre><code class="language-Rust">impl Solution {
    pub fn unique_paths(m: i32, n: i32) -&gt; i32 {
        let mut ans: i64 = 1;
        for i in 1..=m as i64 - 1 {
            ans = ans * (n as i64 - 1 + i) / i;
        }
        ans as i32
    }
}
</code></pre>
<pre><code class="language-Go">func uniquePaths(m int, n int) int {
    ans := 1
    for i := 1; i &lt;= m - 1; i++ {
        ans = ans * (n - 1 + i) / i
    }
    return ans
}
</code></pre>
<pre><code class="language-cpp">#include &lt;cmath&gt;
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long ans = 1;
        for (int i = 1; i &lt;= m - 1; ++i) {
            ans = ans * (n - 1 + i) / i;
        }
        return (int)ans;
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int i = 1; i &lt;= m - 1; i++) {
            ans = ans * (n - 1 + i) / i;
        }
        return (int)ans;
    }
}
</code></pre>
<pre><code class="language-C####">public class Solution {
    public int UniquePaths(int m, int n) {
        long ans = 1;
        for (int i = 1; i &lt;= m - 1; i++) {
            ans = ans * (n - 1 + i) / i;
        }
        return (int)ans;
    }
}
</code></pre>
<pre><code class="language-PHP">class Solution {
    function uniquePaths($m, $n) {
        $ans = 1;
        for ($i = 1; $i &lt;= $m - 1; ++$i) {
            $ans = $ans * ($n - 1 + $i) / $i;
        }
        return (int)$ans;
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    let ans = 1;
    for (let i = 1; i &lt;= m - 1; i++) {
        ans = ans * (n - 1 + i) / i;
    }
    return ans;
};
</code></pre>
<h4>Code DP - 2D</h4>
<pre><code class="language-Python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        dp = [[1 if i == 0 or j == 0 else 0 for j in range(n)] for i in range(m)]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

        return dp[-1][-1]
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));

        for (int i = 0; i &lt; m; ++i) {
            dp[i][0] = 1;
        }
        for (int j = 0; j &lt; n; ++j) {
            dp[0][j] = 1;
        }

        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for (int i = 0; i &lt; m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j &lt; n; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
}
</code></pre>
<pre><code class="language-Rust">impl Solution {
    pub fn unique_paths(m: i32, n: i32) -&gt; i32 {
        let mut dp: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![1; n as usize]; m as usize];

        for i in 1..m as usize {
            for j in 1..n as usize {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        dp[(m-1) as usize][(n-1) as usize]
    }
}
</code></pre>
<pre><code class="language-Go">func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 0; i &lt; m; i++ {
        dp[i][0] = 1
    }
    for j := 0; j &lt; n; j++ {
        dp[0][j] = 1
    }

    for i := 1; i &lt; m; i++ {
        for j := 1; j &lt; n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}
</code></pre>
<pre><code class="language-C####">public class Solution {
    public int UniquePaths(int m, int n) {
        int[,] dp = new int[m, n];

        for (int i = 0; i &lt; m; i++) {
            dp[i, 0] = 1;
        }
        for (int j = 0; j &lt; n; j++) {
            dp[0, j] = 1;
        }

        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i, j] = dp[i-1, j] + dp[i, j-1];
            }
        }

        return dp[m-1, n-1];
    }
}
</code></pre>
<pre><code class="language-PHP">class Solution {
    function uniquePaths($m, $n) {
        $dp = array_fill(0, $m, array_fill(0, $n, 0));

        for ($i = 0; $i &lt; $m; ++$i) {
            $dp[$i][0] = 1;
        }
        for ($j = 0; $j &lt; $n; ++$j) {
            $dp[0][$j] = 1;
        }

        for ($i = 1; $i &lt; $m; ++$i) {
            for ($j = 1; $j &lt; $n; ++$j) {
                $dp[$i][$j] = $dp[$i-1][$j] + $dp[$i][$j-1];
            }
        }

        return $dp[$m-1][$n-1];
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    const dp = Array.from({ length: m }, () =&gt; Array(n).fill(0));

    for (let i = 0; i &lt; m; ++i) {
        dp[i][0] = 1;
    }
    for (let j = 0; j &lt; n; ++j) {
        dp[0][j] = 1;
    }

    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }

    return dp[m-1][n-1];
};
</code></pre>
<h4>Code DP - 1D</h4>
<pre><code class="language-Python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        curr_row = [1] * n
        prev_row = [1] * n

        for i in range(1, m):
            for j in range(1, n):
                curr_row[j] = curr_row[j - 1] + prev_row[j]    
            curr_row, prev_row = prev_row, curr_row

        return prev_row[-1]
</code></pre>
<h5>Final Thoughts</h5>
<p>Both solutions are valid for the given problem constraints. The Dynamic Programming approach is more general and can be extended to more complex scenarios, such as when some cells are blocked. On the other hand, the Combinatorial Mathematics approach is more efficient for this specific problem.</p>
<p>Tackling this problem offers a deep dive into Dynamic Programming and Combinatorial Mathematics. Whether you use a dynamic table or mathematical combinations, each approach is a lesson in computational thinking. This isn't just a problem; it's a tool for honing your optimization and math skills. So dive in and advance your algorithm mastery. ‍</p></div>