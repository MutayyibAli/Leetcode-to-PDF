<div class='cpp-solution'><h4>✅C++ | ✅DFS | ✅BFS | ✅Intuitive Approach [Votes: 11]</h4><h4>Intuition</h4>
<p>We need to use BFS/DFS traversal technique to visit all rooms.</p>
<h4>Approach</h4>
<p>We define visited array and while visiting all rooms we mark visited rooms. At last we check whether all rooms are visited or not. </p>
<h4>DFS</h4>
<pre><code>class Solution 
{
public:

    void dfs(int i, vector&lt;vector&lt;int&gt;&gt; &amp; rooms, vector&lt;int&gt; &amp;vis)
    {
        vis[i]=1;
        for(auto key: rooms[i])
            if(!vis[key])
                dfs(key, rooms, vis);
    }

    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) 
    {
        vector&lt;int&gt; vis(rooms.size(), 0);

        dfs(0, rooms, vis);

        for(auto it:vis)
            if(!it) return false;

        return true;

    }
};
</code></pre>
<h5>Complexity</h5>
<ul>
<li>
<p>Time complexity:
O(n)</p>
</li>
<li>
<p>Space complexity:
O(2n) ~ O(n)</p>
</li>
</ul>
<h4>BFS</h4>
<pre><code>class Solution 
{
public:

    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) 
    {
        int n=rooms.size();
        vector&lt;int&gt; vis(n, 0);
        queue&lt;int&gt; q;
        q.push(0);
        while(!q.empty())
        {
            int curr_room = q.front(); q.pop();
            vis[curr_room] = 1;
            for(auto key:rooms[curr_room])
                if(!vis[key])
                    q.push(key);
        }

        for(int i=0; i&lt;n; i++)
            if(!vis[i]) return false;

        return true;
    }
};
</code></pre>
<h5>Complexity</h5>
<ul>
<li>
<p>Time complexity:
O(n)</p>
</li>
<li>
<p>Space complexity:
O(2n) ~ O(n)</p>
</li>
</ul></div><div class='python-solution'><h4>[Python3] Soln -> Keys and Rooms [stack implementation] [Votes: 32]</h4><pre><code>class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -&gt; bool:
        visited_rooms = set()
        stack = [0] #### for rooms that we need to visit and we start from room [0]

        while stack: 
            room = stack.pop() 
            visited_rooms.add(room)
            for key in rooms[room]:
                if key not in visited_rooms:
                    stack.append(key)
        return len(visited_rooms) == len(rooms)            

</code></pre></div>