<div class='cpp-solution'><h4>Basic C++ Solution | Non-Hashmap & Non-Set Solution | Basic Vector Solution | Most efficient | 85% [Votes: 286]</h4><p>Please do UPVOTE if this solution helps you.</p>
<pre><code>class Solution {
public:
    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {
        int i = 0;
        sort(arr.begin(),arr.end());
        vector&lt;int&gt; ans;
        while (i &lt; arr.size()){
            int count = 1;
            for (int j = i+1; j&lt; arr.size(); j++){
                if (arr[i] == arr[j])
                    count++;
            }
            ans.push_back(count);
            i = i + count;
        }
        sort(ans.begin(),ans.end());
        for (int i = 0; i &lt; ans.size() - 1; i++){
            if (ans[i] == ans [i+1])
                return false;
        }
        return true;
    }
};
</code></pre></div><div class='python-solution'><h4>âœ…â˜‘Beats 100% Users || [C++/Java/Python/JavaScript] || 2 Approaches || EXPLAINEDðŸ”¥ [Votes: 219]</h4><h4>PLEASE UPVOTE IF IT HELPED</h4>
<h4>Approaches</h4>
<p>(Also explained in the code)</p>
<h6># <strong><em>Approach 1 (Without Sets and Maps)</em></strong></h6>
<ol>
<li>Sort the input array <code>arr</code> to group identical elements together.</li>
<li>Traverse the sorted array, counting occurrences of each element.</li>
<li>Store the counts in a separate vector <code>v</code>.</li>
<li>Sort the vector <code>v</code> to make it easier to check for duplicates.</li>
<li>Iterate through <code>v</code> and check if adjacent elements are equal. If so, return <code>false</code>.</li>
<li>If the loop completes, it means all counts are unique, and the function returns <code>true</code>.</li>
</ol>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity:
   $$O(nlogn)$$</p>
</li>
<li>
<p>Space complexity:
   $$O(n)$$</p>
</li>
</ul>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {
        sort(arr.begin(), arr.end());
        vector&lt;int&gt; v;

        for (int i = 0; i &lt; arr.size(); i++) {
            int cnt = 1;

            // Count occurrences of the current element
            while (i + 1 &lt; arr.size() &amp;&amp; arr[i] == arr[i + 1]) {
                cnt++;
                i++;
            }

            v.push_back(cnt);
        }

        sort(v.begin(), v.end());

        for (int i = 1; i &lt; v.size(); i++) {
            if (v[i] == v[i - 1]) {
                return false;
            }
        }

        return true;
    }
}; 

</code></pre>
<pre><code class="language-Java">import java.util.Arrays;

class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Arrays.sort(arr);
        int[] v = new int[arr.length];
        int idx = 0;

        for (int i = 0; i &lt; arr.length; i++) {
            int cnt = 1;

            // Count occurrences of the current element
            while (i + 1 &lt; arr.length &amp;&amp; arr[i] == arr[i + 1]) {
                cnt++;
                i++;
            }

            v[idx++] = cnt;
        }

        Arrays.sort(v);

        for (int i = 1; i &lt; v.length; i++) {
            if (v[i] == v[i - 1]) {
                return false;
            }
        }

        return true;
    }
}


</code></pre>
<pre><code class="language-python3">class Solution:
    def uniqueOccurrences(self, arr: List[int]) -&gt; bool:
        arr.sort()
        v = []

        i = 0
        while i &lt; len(arr):
            cnt = 1

            #### Count occurrences of the current element
            while i + 1 &lt; len(arr) and arr[i] == arr[i + 1]:
                cnt += 1
                i += 1

            v.append(cnt)
            i += 1

        v.sort()

        for i in range(1, len(v)):
            if v[i] == v[i - 1]:
                return False

        return True



</code></pre>
<pre><code class="language-javascript">var uniqueOccurrences = function(arr) {
    arr.sort((a, b) =&gt; a - b);
    let v = [];

    for (let i = 0; i &lt; arr.length; i++) {
        let cnt = 1;

        // Count occurrences of the current element
        while (i + 1 &lt; arr.length &amp;&amp; arr[i] === arr[i + 1]) {
            cnt++;
            i++;
        }

        v.push(cnt);
    }

    v.sort((a, b) =&gt; a - b);

    for (let i = 1; i &lt; v.length; i++) {
        if (v[i] === v[i - 1]) {
            return false;
        }
    }

    return true;
};



</code></pre>
<h6># <strong><em>Approach 2 (With Sets and Maps)</em></strong></h6>
<ol>
<li>Create an unordered map <code>freq</code> to store the frequency of each element in the array.</li>
<li>Iterate through each element of the input array (<code>arr</code>).</li>
<li>Update the frequency count in the freq map.</li>
<li>Create an unordered set <code>s</code> to store unique frequencies.</li>
<li>Iterate through the entries in the <code>freq</code> map and insert the frequencies into the set <code>s</code>.</li>
<li>Check if the size of the <code>freq</code> map is equal to the size of the set <code>s</code>. If they are equal, it means that the occurrences of frequencies are unique.</li>
</ol>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity:
   $$O(n)$$</p>
</li>
<li>
<p>Space complexity:
   $$O(n)$$</p>
</li>
</ul>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {
      unordered_map&lt;int,int&gt;freq;
      for(auto x: arr){
          freq[x]++;
      }  
      unordered_set&lt;int&gt;s;
      for(auto x: freq){
          s.insert(x.second);
      }
      return freq.size()==s.size();
    }
};




</code></pre>
<pre><code class="language-Java">class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;();
        for (int x : arr) {
            freq.put(x, freq.getOrDefault(x, 0) + 1);
        }

        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for (int x : freq.values()) {
            s.add(x);
        }

        return freq.size() == s.size();
    }
}


</code></pre>
<pre><code class="language-python3">class Solution:
    def uniqueOccurrences(self, arr: List[int]) -&gt; bool:
        freq = {}
        for x in arr:
            freq[x] = freq.get(x, 0) + 1

        return len(freq) == len(set(freq.values()))


</code></pre>
<pre><code class="language-javascript">/**
 * @param {number[]} arr
 * @return {boolean}
 */
var uniqueOccurrences = function(arr) {
    const freq = new Map();
    for (const x of arr) {
        freq.set(x, (freq.get(x) || 0) + 1);
    }

    const s = new Set(freq.values());
    return freq.size === s.size;
};


</code></pre>
<h4>PLEASE UPVOTE IF IT HELPED</h4>
<hr /></div>