<div class='cpp-solution'><h4>üî•üöÄSimplest SolutionüöÄ|| DFS ||üî•Full Explanation||üî•C++üî•|| Python3 [Votes: 63]</h4><h4>Consider</h4>
<pre><code>                    Please Upvote If You Find It Helpful
</code></pre>
<h4>Intuition</h4>
<p>As we have to find the <strong>Maximum Height of Tree</strong>.
So, first we find the height of <strong>Left Subtree and Right Subtree</strong> of root node.
And we return the <strong>maximum height</strong> from <strong>Left Subtree and Right Subtree</strong> <code>+</code> <code>1</code></p>
<!-- Describe your first thoughts on how to solve this problem. -->

<h4>Approach : DFS</h4>
<pre><code>Example : root = [3,9,20,null,8,15,7,null,null,null,null,10]
</code></pre>
<!-- Describe your approach to solving the problem. -->

<h4>Complexity</h4>
<ul>
<li>Time complexity: O(n) : As we are traversing each node of tree.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: O(Height of tree) : Recursive stack space</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Code</h4>
<h4>cpp</h4>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL)
            return 0;
        int lh = maxDepth(root-&gt;left);
        int rh = maxDepth(root-&gt;right);
        return max(lh, rh) + 1;
    }
};
</code></pre>
<h4>Python</h4>
<pre><code>class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:
        if not root:
            return 0
        leftSubtree = self.maxDepth(root.left)
        RightSubtree = self.maxDepth(root.right)
        return max(leftSubtree, RightSubtree) + 1
</code></pre>
<pre><code>                            Give a . It motivates me alot
</code></pre>
<p>Let's Connect On <a href="https://www.linkedin.com/in/naman-agarwal-0551aa1aa/">Linkedin</a></p></div><div class='python-solution'><h4>‚úîÔ∏è [Python3] RECURSIVE DFS ( ‚Ä¢‚åÑ‚Ä¢ ‡•Ç )‚úß, Explained [Votes: 337]</h4><p><strong>UPVOTE if you like (‚ó†‚Äø‚ó†), If you have any question, feel free to ask.</strong></p>
<p>To calculate the maximum depth we can use the Depth-First Search. We call a helper function recursively and return the maximum depth between left and right branches. </p>
<p>Time: <strong>O(N)</strong> - for DFS
Space: <strong>O(N)</strong> - for the recursive stack</p>
<p>Runtime: 40 ms, faster than <strong>89.54%</strong> of Python3 online submissions for Maximum Depth of Binary Tree.
Memory Usage: 16.3 MB, less than <strong>18.15%</strong> of Python3 online submissions for Maximum Depth of Binary Tree.</p>
<pre><code>class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:
        def dfs(root, depth):
            if not root: return depth
            return max(dfs(root.left, depth + 1), dfs(root.right, depth + 1))

        return dfs(root, 0)
</code></pre>
<p><strong>UPVOTE if you like (‚ó†‚Äø‚ó†), If you have any question, feel free to ask.</strong></p></div>