<div class='cpp-solution'><h4>PythonðŸ”¥JavaðŸ”¥C++ðŸ”¥Simple SolutionðŸ”¥Easy to Understand [Votes: 341]</h4><p><strong>!! BIG ANNOUNCEMENT !!</strong>
I am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you're interested <strong>DON'T FORGET</strong> to Subscribe</p>
<h4>Search  <code>Tech Wired Leetcode</code> to Subscribe</h4>
<h4>Video Solution</h4>
<h4>Search  <code>Spiral Matrix by Tech Wired</code></h4>
<h4>or</h4>
<h4>Click the Link in my Profile</h4>
<h4>Approach:</h4>
<ul>
<li>We will use a while loop to traverse the matrix in a clockwise spiral order.</li>
<li>We will define four variables: left, right, top, bottom to represent the four boundaries of the current spiral.</li>
<li>We will use four for loops to traverse each edge of the current spiral in clockwise order and add the elements to the result list.</li>
<li>We will update the boundaries of the current spiral and continue the process until all elements have been traversed.</li>
</ul>
<h4>Intuition:</h4>
<ul>
<li>We start with the outermost layer of the matrix and traverse it in a clockwise spiral order, adding the elements to the result list.</li>
<li>Then we move on to the next inner layer of the matrix and repeat the process until we have traversed all layers.</li>
<li>To traverse each layer, we need to keep track of the four boundaries of the current spiral.</li>
<li>We start at the top-left corner of the current spiral and move right until we hit the top-right corner.</li>
<li>Then we move down to the bottom-right corner and move left until we hit the bottom-left corner.</li>
<li>Finally, we move up to the top-left corner of the next spiral and repeat the process until we have traversed all elements in the matrix.</li>
</ul>
<pre><code class="language-Python">class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        if not matrix:
            return []

        rows, cols = len(matrix), len(matrix[0])
        top, bottom, left, right = 0, rows-1, 0, cols-1
        result = []

        while len(result) &lt; rows * cols:
            for i in range(left, right+1):
                result.append(matrix[top][i])
            top += 1

            for i in range(top, bottom+1):
                result.append(matrix[i][right])
            right -= 1

            if top &lt;= bottom:
                for i in range(right, left-1, -1):
                    result.append(matrix[bottom][i])
                bottom -= 1

            if left &lt;= right:
                for i in range(bottom, top-1, -1):
                    result.append(matrix[i][left])
                left += 1

        return result

</code></pre>
<pre><code class="language-Java">class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (matrix == null || matrix.length == 0) {
            return result;
        }

        int rows = matrix.length, cols = matrix[0].length;
        int left = 0, right = cols-1, top = 0, bottom = rows-1;

        while (left &lt;= right &amp;&amp; top &lt;= bottom) {
            for (int i = left; i &lt;= right; i++) {
                result.add(matrix[top][i]);
            }
            top++;

            for (int i = top; i &lt;= bottom; i++) {
                result.add(matrix[i][right]);
            }
            right--;

            if (top &lt;= bottom) {
                for (int i = right; i &gt;= left; i--) {
                    result.add(matrix[bottom][i]);
                }
                bottom--;
            }

            if (left &lt;= right) {
                for (int i = bottom; i &gt;= top; i--) {
                    result.add(matrix[i][left]);
                }
                left++;
            }
        }

        return result;
    }
}

</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; result;
        if (matrix.empty() || matrix[0].empty()) {
            return result;
        }

        int rows = matrix.size(), cols = matrix[0].size();
        int left = 0, right = cols-1, top = 0, bottom = rows-1;

        while (left &lt;= right &amp;&amp; top &lt;= bottom) {
            for (int i = left; i &lt;= right; i++) {
                result.push_back(matrix[top][i]);
            }
            top++;

            for (int i = top; i &lt;= bottom; i++) {
                result.push_back(matrix[i][right]);
            }
            right--;

            if (top &lt;= bottom) {
                for (int i = right; i &gt;= left; i--) {
                    result.push_back(matrix[bottom][i]);
                }
                bottom--;
            }

            if (left &lt;= right) {
                for (int i = bottom; i &gt;= top; i--) {
                    result.push_back(matrix[i][left]);
                }
                left++;
            }
        }

        return result;
    }
};

</code></pre>
<h4>An Upvote will be encouraging</h4></div><div class='python-solution'><h4>1-liner in Python + Ruby [Votes: 1816]</h4><p>Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions.</p>
<p>Python:</p>
<pre><code>def spiralOrder(self, matrix):
    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])
</code></pre>
<p>Python 3:</p>
<pre><code>def spiralOrder(self, matrix):
    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])
</code></pre>
<p>Ruby:</p>
<pre><code>def spiral_order(matrix)
  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []
end
</code></pre>
<p>or</p>
<pre><code>def spiral_order(matrix)
  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []
end
</code></pre>
<h6>Visualization</h6>
<p>Here's how the matrix changes by always extracting the first row and rotating the remaining matrix counter-clockwise:</p>
<pre><code>    |1 2 3|      |6 9|      |8 7|      |4|  =&gt;  |5|  =&gt;  ||
    |4 5 6|  =&gt;  |5 8|  =&gt;  |5 4|  =&gt;  |5|
    |7 8 9|      |4 7|
</code></pre>
<p>Now look at the first rows we extracted:</p>
<pre><code>    |1 2 3|      |6 9|      |8 7|      |4|      |5|
</code></pre>
<p>Those concatenated are the desired result.</p>
<h6>Another visualization</h6>
<pre><code>  spiral_order([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

= [1, 2, 3] + spiral_order([[6, 9],
                            [5, 8],
                            [4, 7]])

= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],
                                     [5, 4]])

= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],
                                              [5]])

= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])

= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])

= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []

= [1, 2, 3, 6, 9, 8, 7, 4, 5]
</code></pre></div>