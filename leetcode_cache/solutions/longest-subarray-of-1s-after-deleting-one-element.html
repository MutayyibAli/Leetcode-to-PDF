<div class='cpp-solution'><h4>âœ…Beat's 100% || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥ [Votes: 296]</h4><h4>Intuition:</h4>
<p>The Intuition is to use a sliding window approach to find the length of the longest subarray of 1's after removing at most one element (0 or 1) from the original array. It adjusts the window to have at most one zero, calculates the subarray length, and returns the maximum length found.</p>
<h4>Explanation:</h4>
<ol>
<li>The code aims to find the length of the longest subarray consisting of only 1's after deleting at most one element (0 or 1) from the original array.</li>
<li>The variable <code>left</code> represents the left pointer of the sliding window, which defines the subarray.</li>
<li>The variable <code>zeros</code> keeps track of the number of zeroes encountered in the current subarray.</li>
<li>The variable <code>ans</code> stores the maximum length of the subarray found so far.</li>
<li>The code iterates over the array using the right pointer <code>right</code>.</li>
<li>If <code>nums[right]</code> is 0, it means we encountered a zero in the array. We increment <code>zeros</code> by 1.</li>
<li>The while loop is used to adjust the window by moving the left pointer <code>left</code> to the right until we have at most one zero in the subarray.</li>
<li>If <code>nums[left]</code> is 0, it means we are excluding a zero from the subarray, so we decrement <code>zeros</code> by 1.</li>
<li>We update the <code>left</code> pointer by moving it to the right.</li>
<li>After adjusting the window, we calculate the length of the current subarray by subtracting the number of zeroes from the total length <code>right - left + 1</code>. We update <code>ans</code> if necessary.</li>
<li>Finally, we check if the entire array is the longest subarray. If it is, we subtract 1 from the maximum length to account for the one element we are allowed to delete. We return the resulting length.</li>
</ol>
<h4>Complexity:</h4>
<p><strong>Time complexity</strong>: $$ O(N) $$
- Each element in the array will be iterated over twice at max. Each element will be iterated over for the first time in the for loop; then, it might be possible to re-iterate while shrinking the window in the while loop. No element can be iterated more than twice.</p>
<p><strong>Space complexity</strong>: $$ O(1) $$</p>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    int longestSubarray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();

        int left = 0;
        int zeros = 0;
        int ans = 0;

        for (int right = 0; right &lt; n; right++) {
            if (nums[right] == 0) {
                zeros++;
            }
            while (zeros &gt; 1) {
                if (nums[left] == 0) {
                    zeros--;
                }
                left++;
            }
            ans = max(ans, right - left + 1 - zeros);
        }
        return (ans == n) ? ans - 1 : ans;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length;

        int left = 0;
        int zeros = 0;
        int ans = 0;

        for (int right = 0; right &lt; n; right++) {
            if (nums[right] == 0) {
                zeros++;
            }
            while (zeros &gt; 1) {
                if (nums[left] == 0) {
                    zeros--;
                }
                left++;
            }
            ans = Math.max(ans, right - left + 1 - zeros);
        }
        return (ans == n) ? ans - 1 : ans;
    }
}
</code></pre>
<pre><code class="language-Python3">class Solution:
    def longestSubarray(self, nums: List[int]) -&gt; int:
        n = len(nums)

        left = 0
        zeros = 0
        ans = 0

        for right in range(n):
            if nums[right] == 0:
                zeros += 1

            while zeros &gt; 1:
                if nums[left] == 0:
                    zeros -= 1
                left += 1

            ans = max(ans, right - left + 1 - zeros)

        return ans - 1 if ans == n else ans
</code></pre>
<h4>Code With Comments</h4>
<pre><code class="language-cpp">class Solution {
public:
    int longestSubarray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size(); // The size of the input array

        int left = 0; // The left pointer of the sliding window
        int zeros = 0; // Number of zeroes encountered
        int ans = 0; // Maximum length of the subarray

        for (int right = 0; right &lt; n; right++) {
            if (nums[right] == 0) {
                zeros++; // Increment the count of zeroes
            }

            // Adjust the window to maintain at most one zero in the subarray
            while (zeros &gt; 1) {
                if (nums[left] == 0) {
                    zeros--; // Decrement the count of zeroes
                }
                left++; // Move the left pointer to the right
            }

            // Calculate the length of the current subarray and update the maximum length
            ans = max(ans, right - left + 1 - zeros);
        }

        // If the entire array is the subarray, return the size minus one; otherwise, return the maximum length
        return (ans == n) ? ans - 1 : ans;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length; // The size of the input array

        int left = 0; // The left pointer of the sliding window
        int zeros = 0; // Number of zeroes encountered
        int ans = 0; // Maximum length of the subarray

        for (int right = 0; right &lt; n; right++) {
            if (nums[right] == 0) {
                zeros++; // Increment the count of zeroes
            }

            // Adjust the window to maintain at most one zero in the subarray
            while (zeros &gt; 1) {
                if (nums[left] == 0) {
                    zeros--; // Decrement the count of zeroes
                }
                left++; // Move the left pointer to the right
            }

            // Calculate the length of the current subarray and update the maximum length
            ans = Math.max(ans, right - left + 1 - zeros);
        }

        // If the entire array is the subarray, return the size minus one; otherwise, return the maximum length
        return (ans == n) ? ans - 1 : ans;
    }
}
</code></pre>
<pre><code class="language-Python3">class Solution:
    def longestSubarray(self, nums: List[int]) -&gt; int:
        n = len(nums)  #### The size of the input array

        left = 0  #### The left pointer of the sliding window
        zeros = 0  #### Number of zeroes encountered
        ans = 0  #### Maximum length of the subarray

        for right in range(n):
            if nums[right] == 0:
                zeros += 1  #### Increment the count of zeroes

            #### Adjust the window to maintain at most one zero in the subarray
            while zeros &gt; 1:
                if nums[left] == 0:
                    zeros -= 1  #### Decrement the count of zeroes
                left += 1  #### Move the left pointer to the right

            #### Calculate the length of the current subarray and update the maximum length
            ans = max(ans, right - left + 1 - zeros)

        #### If the entire array is the subarray, return the size minus one; otherwise, return the maximum length
        return ans - 1 if ans == n else ans
</code></pre>
<p><strong>If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.</strong></p></div>