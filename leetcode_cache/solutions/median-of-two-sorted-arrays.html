<div class='cpp-solution'><h4>âœ…99%ðŸ”¥||âœ…Journey From Brute Force to Most ðŸ”¥Optimized âœ…Three Approaches||ðŸ”¥Easy to understand [Votes: 3644]</h4><h4>Problem Understanding:</h4>
<p>In simpler terms, you need to <strong>find the middle value of the combined</strong>, sorted array formed by merging nums1 and nums2. If the combined <strong>array has an even number</strong> of elements, you should return the average of the two middle values. <strong>If it has an odd number of elements, you should return the middle value itself.</strong></p>
<!-- Describe your first thoughts on how to solve this problem. -->
<h4>Hint:</h4>
<pre><code class="language-Hint1">Think of a brute force approach.
</code></pre>
<pre><code class="language-Hint2">Do you think how two pointer will help us?
</code></pre>
<pre><code class="language-Hint3">Can you observe the fact that the given arrays are sorted?
</code></pre>
<p><strong>I would recommend you, don't jump directly on solution.</strong></p>
<h4>Approach 1: Merge and Sort</h4>
<ul>
<li><strong>Create a new array</strong> with a size equal to the total number of elements in both input arrays.</li>
<li><strong>Insert elements</strong> from both input arrays into the new array.</li>
<li><strong>Sort the new array.</strong></li>
<li><strong>Find and return the median of the sorted array.</strong></li>
</ul>
<p><strong>Time Complexity</strong>
- In the worst case TC is <strong>O((n + m) * log(n + m))</strong>.</p>
<p><strong>Space Complexity</strong>
 - <strong>O(n + m)</strong>, where â€˜nâ€™ and â€˜mâ€™ are the sizes of the arrays.</p>
<h4>Approach 2: Two-Pointer Method</h4>
<ul>
<li><strong>Initialize two pointers</strong>, i and j, both initially set to 0.</li>
<li><strong>Move the pointer</strong> that corresponds to the <strong>smaller value forward at each step.</strong></li>
<li>Continue moving the pointers <strong>until you have processed half of the total number of elements.</strong></li>
<li>Calculate and <strong>return the median</strong> based on the values pointed to by i and j.</li>
</ul>
<p><strong>Time Complexity</strong>
- <strong>O(n + m)</strong>, where â€˜nâ€™ &amp; â€˜mâ€™ are the sizes of the two arrays.</p>
<p><strong>Space Complexity</strong>
 - <strong>O(1)</strong>.</p>
<h4>Approach 3: Binary Search</h4>
<ul>
<li><strong>Use binary search to partition the smaller of the two input arrays into two parts.</strong></li>
<li>Find the partition of the <strong>larger array such that the sum of elements on the left side of the partition in both arrays is half of the total elements.</strong></li>
<li>Check if this partition <strong>is valid by verifying</strong> if the largest number on the left side is smaller than the smallest number on the right side.</li>
<li><strong>If the partition is valid,</strong> calculate and return the median.</li>
</ul>
<p><strong>Time Complexity</strong>
- <strong>O(logm/logn)</strong></p>
<p><strong>Space Complexity</strong>
 - <strong>O(1)</strong></p>
<h4>SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated</h4>
<!-- Describe your approach to solving the problem. -->
<h4>Code Brute Force- Merge and Sort</h4>
<pre><code class="language-cpp">class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        // Get the sizes of both input arrays.
        int n = nums1.size();
        int m = nums2.size();

        // Merge the arrays into a single sorted array.
        vector&lt;int&gt; merged;
        for (int i = 0; i &lt; n; i++) {
            merged.push_back(nums1[i]);
        }
        for (int i = 0; i &lt; m; i++) {
            merged.push_back(nums2[i]);
        }

        // Sort the merged array.
        sort(merged.begin(), merged.end());

        // Calculate the total number of elements in the merged array.
        int total = merged.size();

        if (total % 2 == 1) {
            // If the total number of elements is odd, return the middle element as the median.
            return static_cast&lt;double&gt;(merged[total / 2]);
        } else {
            // If the total number of elements is even, calculate the average of the two middle elements as the median.
            int middle1 = merged[total / 2 - 1];
            int middle2 = merged[total / 2];
            return (static_cast&lt;double&gt;(middle1) + static_cast&lt;double&gt;(middle2)) / 2.0;
        }
    }
};

</code></pre>
<pre><code class="language-Java">import java.util.Arrays;

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // Get the sizes of both input arrays.
        int n = nums1.length;
        int m = nums2.length;

        // Merge the arrays into a single sorted array.
        int[] merged = new int[n + m];
        int k = 0;
        for (int i = 0; i &lt; n; i++) {
            merged[k++] = nums1[i];
        }
        for (int i = 0; i &lt; m; i++) {
            merged[k++] = nums2[i];
        }

        // Sort the merged array.
        Arrays.sort(merged);

        // Calculate the total number of elements in the merged array.
        int total = merged.length;

        if (total % 2 == 1) {
            // If the total number of elements is odd, return the middle element as the median.
            return (double) merged[total / 2];
        } else {
            // If the total number of elements is even, calculate the average of the two middle elements as the median.
            int middle1 = merged[total / 2 - 1];
            int middle2 = merged[total / 2];
            return ((double) middle1 + (double) middle2) / 2.0;
        }
    }
}

</code></pre>
<pre><code class="language-python3">class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        #### Merge the arrays into a single sorted array.
        merged = nums1 + nums2

        #### Sort the merged array.
        merged.sort()

        #### Calculate the total number of elements in the merged array.
        total = len(merged)

        if total % 2 == 1:
            #### If the total number of elements is odd, return the middle element as the median.
            return float(merged[total // 2])
        else:
            #### If the total number of elements is even, calculate the average of the two middle elements as the median.
            middle1 = merged[total // 2 - 1]
            middle2 = merged[total // 2]
            return (float(middle1) + float(middle2)) / 2.0

</code></pre>
<h4>Code for Two-Pointer Method</h4>
<pre><code class="language-cpp">class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int n = nums1.size();
        int m = nums2.size();
        int i = 0, j = 0, m1 = 0, m2 = 0;

        // Find median.
        for (int count = 0; count &lt;= (n + m) / 2; count++) {
            m2 = m1;
            if (i != n &amp;&amp; j != m) {
                if (nums1[i] &gt; nums2[j]) {
                    m1 = nums2[j++];
                } else {
                    m1 = nums1[i++];
                }
            } else if (i &lt; n) {
                m1 = nums1[i++];
            } else {
                m1 = nums2[j++];
            }
        }

        // Check if the sum of n and m is odd.
        if ((n + m) % 2 == 1) {
            return static_cast&lt;double&gt;(m1);
        } else {
            double ans = static_cast&lt;double&gt;(m1) + static_cast&lt;double&gt;(m2);
            return ans / 2.0;
        }
    }
};

</code></pre>
<pre><code class="language-Java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int i = 0, j = 0, m1 = 0, m2 = 0;

        // Find median.
        for (int count = 0; count &lt;= (n + m) / 2; count++) {
            m2 = m1;
            if (i != n &amp;&amp; j != m) {
                if (nums1[i] &gt; nums2[j]) {
                    m1 = nums2[j++];
                } else {
                    m1 = nums1[i++];
                }
            } else if (i &lt; n) {
                m1 = nums1[i++];
            } else {
                m1 = nums2[j++];
            }
        }

        // Check if the sum of n and m is odd.
        if ((n + m) % 2 == 1) {
            return (double) m1;
        } else {
            double ans = (double) m1 + (double) m2;
            return ans / 2.0;
        }
    }
}

</code></pre>
<pre><code class="language-python">class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        n = len(nums1)
        m = len(nums2)
        i = 0
        j = 0
        m1 = 0
        m2 = 0

        #### Find median.
        for count in range(0, (n + m) // 2 + 1):
            m2 = m1
            if i &lt; n and j &lt; m:
                if nums1[i] &gt; nums2[j]:
                    m1 = nums2[j]
                    j += 1
                else:
                    m1 = nums1[i]
                    i += 1
            elif i &lt; n:
                m1 = nums1[i]
                i += 1
            else:
                m1 = nums2[j]
                j += 1

        #### Check if the sum of n and m is odd.
        if (n + m) % 2 == 1:
            return float(m1)
        else:
            ans = float(m1) + float(m2)
            return ans / 2.0

</code></pre>
<h4>Code for Binary Search</h4>
<pre><code class="language-cpp">class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) {
        int n1 = nums1.size(), n2 = nums2.size();

        // Ensure nums1 is the smaller array for simplicity
        if (n1 &gt; n2)
            return findMedianSortedArrays(nums2, nums1);

        int n = n1 + n2;
        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size
        int low = 0, high = n1;

        while (low &lt;= high) {
            int mid1 = (low + high) &gt;&gt; 1; // Calculate mid index for nums1
            int mid2 = left - mid1; // Calculate mid index for nums2

            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;

            // Determine values of l1, l2, r1, and r2
            if (mid1 &lt; n1)
                r1 = nums1[mid1];
            if (mid2 &lt; n2)
                r2 = nums2[mid2];
            if (mid1 - 1 &gt;= 0)
                l1 = nums1[mid1 - 1];
            if (mid2 - 1 &gt;= 0)
                l2 = nums2[mid2 - 1];

            if (l1 &lt;= r2 &amp;&amp; l2 &lt;= r1) {
                // The partition is correct, we found the median
                if (n % 2 == 1)
                    return max(l1, l2);
                else
                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;
            }
            else if (l1 &gt; r2) {
                // Move towards the left side of nums1
                high = mid1 - 1;
            }
            else {
                // Move towards the right side of nums1
                low = mid1 + 1;
            }
        }

        return 0; // If the code reaches here, the input arrays were not sorted.
    }
};


</code></pre>
<pre><code class="language-Java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length, n2 = nums2.length;

        // Ensure nums1 is the smaller array for simplicity
        if (n1 &gt; n2)
            return findMedianSortedArrays(nums2, nums1);

        int n = n1 + n2;
        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size
        int low = 0, high = n1;

        while (low &lt;= high) {
            int mid1 = (low + high) &gt;&gt; 1; // Calculate mid index for nums1
            int mid2 = left - mid1; // Calculate mid index for nums2

            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE, r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;

            // Determine values of l1, l2, r1, and r2
            if (mid1 &lt; n1)
                r1 = nums1[mid1];
            if (mid2 &lt; n2)
                r2 = nums2[mid2];
            if (mid1 - 1 &gt;= 0)
                l1 = nums1[mid1 - 1];
            if (mid2 - 1 &gt;= 0)
                l2 = nums2[mid2 - 1];

            if (l1 &lt;= r2 &amp;&amp; l2 &lt;= r1) {
                // The partition is correct, we found the median
                if (n % 2 == 1)
                    return Math.max(l1, l2);
                else
                    return ((double)(Math.max(l1, l2) + Math.min(r1, r2))) / 2.0;
            }
            else if (l1 &gt; r2) {
                // Move towards the left side of nums1
                high = mid1 - 1;
            }
            else {
                // Move towards the right side of nums1
                low = mid1 + 1;
            }
        }

        return 0; // If the code reaches here, the input arrays were not sorted.
    }
}

</code></pre>
<pre><code class="language-python">class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        n1 = len(nums1)
        n2 = len(nums2)

        #### Ensure nums1 is the smaller array for simplicity
        if n1 &gt; n2:
            return self.findMedianSortedArrays(nums2, nums1)

        n = n1 + n2
        left = (n1 + n2 + 1) // 2 #### Calculate the left partition size
        low = 0
        high = n1

        while low &lt;= high:
            mid1 = (low + high) // 2 #### Calculate mid index for nums1
            mid2 = left - mid1 #### Calculate mid index for nums2

            l1 = float('-inf')
            l2 = float('-inf')
            r1 = float('inf')
            r2 = float('inf')

            #### Determine values of l1, l2, r1, and r2
            if mid1 &lt; n1:
                r1 = nums1[mid1]
            if mid2 &lt; n2:
                r2 = nums2[mid2]
            if mid1 - 1 &gt;= 0:
                l1 = nums1[mid1 - 1]
            if mid2 - 1 &gt;= 0:
                l2 = nums2[mid2 - 1]

            if l1 &lt;= r2 and l2 &lt;= r1:
                #### The partition is correct, we found the median
                if n % 2 == 1:
                    return max(l1, l2)
                else:
                    return (max(l1, l2) + min(r1, r2)) / 2.0
            elif l1 &gt; r2:
                #### Move towards the left side of nums1
                high = mid1 - 1
            else:
                #### Move towards the right side of nums1
                low = mid1 + 1

        return 0 #### If the code reaches here, the input arrays were not sorted.

</code></pre>
<h4>SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated</h4></div>