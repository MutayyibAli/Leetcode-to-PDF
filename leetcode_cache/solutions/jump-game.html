<div class='cpp-solution'><h4>【Video】Move Goal Position [Votes: 652]</h4><h4>Intuition</h4>
<p>Move goal position to the left if we meet a simple condition.</p>
<h4>Solution Video</h4>
<p>https://youtu.be/m6AymRRYgko</p>
<h6>⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️</h6>
<p><strong>■ Subscribe URL</strong>
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>Subscribers: 4,139
Thank you for your support!</p>
<h4>Approach</h4>
<p>We have several ways to reach <code>goal</code>(= the last index) or <code>other index</code> from a current position, so my strategy is to move <code>goal</code> to left position if we meet a simple condition.</p>
<p>The condition is</p>
<p>⭐️ Points</p>
<pre><code>if current position + maximum jump &gt;= goal
</code></pre>
<p>If we meet the condition we update <code>goal</code> with current index.</p>
<p>Let's see how it works.</p>
<pre><code>Input: nums = [2,3,1,1,4]
</code></pre>
<p>We start at the second position from the last.</p>
<pre><code>[2,3,1,1,4]
       i g

i = current position
g = goal
</code></pre>
<p>Let's use the formula above.</p>
<pre><code>current position + maximum jump &gt;= goal
= 3 + 1 &gt;= 4
= true
</code></pre>
<p>We can reach the current goal(= index <code>4</code>) from current position(= index <code>3</code>), <strong>that means if we reach index <code>3</code>, we are sure that we can definitely reach the <code>goal</code>(= the last index).</strong></p>
<p>That's why we can move <code>goal</code> to index <code>3</code>.</p>
<p>Next,</p>
<pre><code>[2,3,1,1,4]
     i g
</code></pre>
<pre><code>current position + maximum jump &gt;= goal
= 2 + 1 &gt;= 3
= true
</code></pre>
<p>If <code>true</code>, we are sure we can reach index <code>3</code> from index <code>2</code>. We know that if we reach index <code>3</code>, we can reach the last index, so update <code>goal</code> with index <code>2</code>. In the next time, if we can reach index <code>2</code>, that means we can reach the last index(= <code>4</code>)</p>
<p>Next,</p>
<pre><code>[2,3,1,1,4]
   i g
</code></pre>
<p>I'll speed up.</p>
<pre><code>current position + maximum jump &gt;= goal
= 1 + 3 &gt;= 2
= true
</code></pre>
<pre><code>[2,3,1,1,4]
 i g
</code></pre>
<pre><code>current position + maximum jump &gt;= goal
= 0 + 2 &gt;= 1
= true
</code></pre>
<p>In the end,</p>
<pre><code>[2,3,1,1,4]
 g
</code></pre>
<p>Now, <code>goal</code> is index <code>0</code>. That means we can reach the <code>goal</code> because we start from index <code>0</code>, so before we return <code>true</code> or <code>false</code>, we check this condition.</p>
<pre><code>if goal == 0
</code></pre>
<p>In this case</p>
<pre><code>return true
</code></pre>
<p>Easy!
Let's see solution codes and step by step algorithm!</p>
<p>⭐️ I recently created a video on how I've been using LeetCode to learn.</p>
<p>https://youtu.be/bU_dXCOWHls</p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity: $$O(n)$$</p>
</li>
<li>
<p>Space complexity: $$O(1)$$</p>
</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<pre><code class="language-python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        goal = len(nums) - 1

        for i in range(len(nums) - 2, -1, -1):
            if i + nums[i] &gt;= goal:
                goal = i

        return True if goal == 0 else False
</code></pre>
<pre><code class="language-javascript">var canJump = function(nums) {
    let goal = nums.length - 1;

    for (let i = nums.length - 2; i &gt;= 0; i--) {
        if (i + nums[i] &gt;= goal) {
            goal = i;
        }
    }

    return goal === 0;    
};
</code></pre>
<pre><code class="language-java">class Solution {
    public boolean canJump(int[] nums) {
        int goal = nums.length - 1;

        for (int i = nums.length - 2; i &gt;= 0; i--) {
            if (i + nums[i] &gt;= goal) {
                goal = i;
            }
        }

        return goal == 0;        
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int goal = nums.size() - 1;

        for (int i = nums.size() - 2; i &gt;= 0; i--) {
            if (i + nums[i] &gt;= goal) {
                goal = i;
            }
        }

        return goal == 0;        
    }
};
</code></pre>
<h5>Step by Step Algorithm</h5>
<ol>
<li>
<p><strong>Initialization</strong>:
    <code>python
    goal = len(nums) - 1</code> </p>
<ul>
<li><code>goal = len(nums) - 1</code>: Initialize the variable <code>goal</code> to the last index of the array <code>nums</code>. This represents the goal position we want to reach.</li>
</ul>
</li>
<li>
<p><strong>Main Loop</strong>:
    <code>python
    for i in range(len(nums) - 2, -1, -1):</code></p>
<ul>
<li><code>for i in range(len(nums) - 2, -1, -1)</code>: Iterate backward through the array <code>nums</code>, starting from the second to last element down to the first element.</li>
</ul>
</li>
<li>
<p><strong>Checking Jumpability</strong>:
    <code>python
    if i + nums[i] &gt;= goal:</code> </p>
<ul>
<li><code>if i + nums[i] &gt;= goal</code>: Check if the current index <code>i</code> plus the maximum jump length at that position (<code>nums[i]</code>) is greater than or equal to the <code>goal</code>. If it is, it means we can jump from index <code>i</code> to the <code>goal</code> or beyond.</li>
</ul>
</li>
<li>
<p><strong>Updating Goal</strong>:
    <code>python
    goal = i</code></p>
<ul>
<li><code>goal = i</code>: If the condition in step 3 is met, update the <code>goal</code> to the current index <code>i</code>. This means we have found a new closer position from which we can reach the previous <code>goal</code> position.</li>
</ul>
</li>
<li>
<p><strong>Return Result</strong>:
    <code>python
    return True if goal == 0 else False</code></p>
<ul>
<li><code>return True if goal == 0 else False</code>: If we successfully reach the first index (i.e., <code>goal == 0</code>), return <code>True</code>, indicating that it's possible to reach the last index from the first index. Otherwise, return <code>False</code>.</li>
</ul>
</li>
</ol>
<p>Thank you for reading my post.
⭐️ Please upvote it and don't forget to subscribe to my channel!</p>
<p>■ Subscribe URL
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>■ Twitter
https://twitter.com/CodingNinjaAZ</p>
<h4>My previous post and video - Move Zeroes</h4>
<p>post
https://leetcode.com/problems/container-with-most-water/solutions/4913496/video-two-pointer-solution/</p>
<p>video
https://youtu.be/-nvQm6f84Yg</p></div><div class='python-solution'><h4>Super simple, intuitive, 8-line Python solution (beats 99.92% of users)! [Votes: 813]</h4><h4>Intuition</h4>
<p>Imagine you have a car, and you have some distance to travel (the length of the array). This car has some amount of gasoline, and as long as it has gasoline, it can keep traveling on this road (the array). Every time we move up one element in the array, we subtract one unit of gasoline. However, every time we find an amount of gasoline that is greater than our current amount, we "gas up" our car by replacing our current amount of gasoline with this new amount. We keep repeating this process until we either run out of gasoline (and return false), or we reach the end with just enough gasoline (or more to spare), in which case we return true.
<b>Note:</b> We can let our gas tank get to zero as long as we are able to gas up at that immediate location (element in the array) that our car is currently at.</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $O(n)$</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: $O(1)$</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Code</h4>
<pre><code>class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        gas = 0
        for n in nums:
            if gas &lt; 0:
                return False
            elif n &gt; gas:
                gas = n
            gas -= 1

        return True
</code></pre></div>