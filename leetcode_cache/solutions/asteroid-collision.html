<div class='cpp-solution'><h2>C++ code with explanation (beats 95% in runtime) -- Votes: 330</h2><p><strong>Intuition</strong></p>
<p>According to the question, positive values are moving to the right and negative values are moving to the left. We can apply the concept of relative velocity and make positive values as fixed and negative values now moving with double velocity in the negative direction. But, magnitude of velocity does not matter only the direction matters.</p>
<p><strong>Idea</strong></p>
<p>Lets consider an example:-</p>
<p><code>[8, 9, 6, -7, -9, 12, 50, -34]</code></p>
<p>Start iterating from the beginning. Whenever we encounter a positive value, we don't have to do anything. Since they are fixed, they won't attack anyone. But the moment we sees a negative value, we are sure it is going to attack positive values.</p>
<p>Imagine <code>[8, 9, 6]</code> are happily sitting inside the array. The moment <code>-7</code> enters, it will start knocking out positive values. This gives an idea we can use a stack to solve this problem.</p>
<p><strong>Explanation</strong></p>
<p>Lets see how to use this idea to code.</p>
<p>Consider the same example <code>[8, 9, 6, -7, -9, 12, 50, -34]</code><br />
Initially <code>i = 0</code> .</p>
<ol>
<li>Whenever we encounter a positive value, we will simply push it to the stack.</li>
<li>The moment we encounter a negative value, we know some or all or zero positive values will be knocked out of the stack. The negative value may itself be knocked out or it may enter the stack.<br />
   We will keep on poping the elements from the stack while the <code>asteroids[i] &gt; s.top()</code> . But remember, negative asteroids can never pop another negative asteroids, since they will never meet them. So, the final condition is <code>while(!s.empty() and s.top() &gt; 0 and s.top() &lt; abs(ast[i]))</code> , we will pop the elements.</li>
<li>We have to take care of the case when <code>s.top() == asteroids[i]</code> . In this case one positive element will pop out and negative asteroid won't enter the stack.</li>
<li>If after knocking out elements stack becomes empty() or s.top() becomes negative, that means the current asteroids[i] will enter the stack.</li>
</ol>
<p><strong>Code</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="n">Solution</span><span class="w"> </span><span class="err">{</span>
<span class="k">public</span><span class="err">:</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="nc">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">asteroidCollision</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="nc">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ast</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="nc">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ast</span><span class="p">.</span><span class="k">size</span><span class="p">();</span>
<span class="w">        </span><span class="n">stack</span><span class="o">&lt;</span><span class="nc">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">ast</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ast</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="k">while</span><span class="p">(</span><span class="err">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="k">top</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="k">top</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">ast</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">))</span><span class="w"> </span><span class="err">{</span>
<span class="w">                    </span><span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">                </span><span class="err">}</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="err">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="k">top</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">ast</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">))</span><span class="w"> </span><span class="err">{</span>
<span class="w">                    </span><span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">                </span><span class="err">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="err">{</span>
<span class="w">                    </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="k">top</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">                        </span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ast</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">                    </span><span class="err">}</span>
<span class="w">                </span><span class="err">}</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">finally</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="n">returning</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">remains</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nf">reverse</span><span class="w"> </span><span class="k">order</span><span class="p">.</span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="nc">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="k">size</span><span class="p">());</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="k">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="c1">--) {</span>
<span class="w">            </span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="k">top</span><span class="p">();</span>
<span class="w">            </span><span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span><span class="p">;</span>
</code></pre></div>

<p><strong>Do upvote if this post is helpful to you</strong></p>
<p><strong>Edit</strong> - Thanks for the upvote and comments, do follow me on twitter https://twitter.com/DevTalesShrey where I regularly post coding articles.</p></div>


<div class='python-solution'><h2>Python 3 | Stack Simply Clean O(N) | Explanation -- Votes: 99</h2><h4>Explanation</h4>
<ul>
<li>Intuition, when adding a new asteroid, there are 2 situation (collision or no collsion)</li>
<li>Collision (left meaning previous asteroid, right meaning current asteroid)<ul>
<li>Left destroyed right, e.g. <code>3, -1</code></li>
<li>Right destroyed left, e.g. <code>1, -3</code></li>
<li>Both destroyed, e.g. <code>2, -2</code></li>
</ul>
</li>
<li>No collision</li>
<li>It seems like scenarios can be analyzed linearly with some condition check on neighbors, intuitively, <code>stack</code> is a good tool to use</li>
<li>So let's focus on 3 collision situation, for each new <code>right</code> asteroid</li>
<li>If left destroyed right, then no more to destroy, break</li>
<li>If both destroyed, no more to destroy, break</li>
<li>If right destroyed left, then there is a chance it could destroy more on the left, thus<ul>
<li>pop out left from stack, repeat check again</li>
</ul>
</li>
<li>If stack becomes empty, meaning right destroyed all left asteroids, append right to stack</li>
<li>Time Complexity: <code>O(N)</code></li>
</ul>
<h4>Implementation</h4>
<iframe src="https://leetcode.com/playground/ee8uH7fr/shared" frameBorder="0" width="500" height="250"></iframe></div><p style="page-break-before: always" ></p>