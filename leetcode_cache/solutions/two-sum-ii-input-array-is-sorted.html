<div class='cpp-solution'><h4>【Video】Using Two Pointers to solve the question with O(1) space [Votes: 307]</h4><h4>Intuition</h4>
<p>Using two pointers</p>
<h4>Solution Video</h4>
<p>https://youtu.be/fj5ruWT6B5U</p>
<h6>⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️</h6>
<p><strong>■ Subscribe URL</strong>
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>Subscribers: 4,464
Thank you for your support!</p>
<h4>Approach</h4>
<p>If you know Two Sum question that is the first question of LeetCode, you can solve this question with <code>HashMap</code>. But <code>HashMap</code> solution should $$O(n)$$ space. The description says "Your solution must use only constant extra space", so you need to change your strategy.</p>
<p>Let me explain my strategy with this example.</p>
<pre><code>Input: numbers = [2,7,11,15], target = 18
</code></pre>
<p>My strategy is to use two pointers. Let's say <code>left</code> and <code>right</code>.</p>
<pre><code>[2,7,11,15]
 L      R
</code></pre>
<p><code>left</code> pointer starts from index <code>0</code> and <code>right</code> pointer starts from the last index.</p>
<p>Every time we calculate addition with left number + right number.</p>
<pre><code>[2,7,11,15]
 L      R

2 + 15 = 17 
target = 18
</code></pre>
<p>Now current total (= <code>17</code>) is smaller than the target, so current combination is not answer.</p>
<p>After that, we have to move <code>left</code> or <code>right</code> to find the target number.</p>
<p>But how can we decide to move the one of them? </p>
<p>It's simple. Current total is smaller than the target, that's why we should move <code>left</code> pointer to the next, <strong>because input array is sorted, so right number is definitely greater than left number.</strong> If we move <code>left</code> pointer to the next, we will get bigger total next time.</p>
<pre><code>[2,7,11,15]
   L    R

7 + 15 = 22
target = 18
</code></pre>
<p>We got bigger total this time. In that case, we need to move <code>right</code> pointer to the next, because of the same reason above. Input array is sorted, so if we move <code>right</code> pointer to the next, we will get smaller total next time.</p>
<pre><code>[2,7,11,15]
   L R

7 + 11 = 18
target = 18
</code></pre>
<p>Now, current total is equal to the target. The description says "Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2".</p>
<pre><code>return [2, 3]
</code></pre>
<p>Easy! 
Let's see a real algorithm!</p>
<p>⭐️ Related Question</p>
<p>https://youtu.be/MlgFhWvxuJk</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $$O(n)$$</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: $$O(1)$$</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<pre><code class="language-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        left = 0
        right = len(numbers) - 1

        while left &lt; right:
            total = numbers[left] + numbers[right]

            if total == target:
                return [left + 1, right + 1]
            elif total &gt; target:
                right -= 1
            else:
                left += 1
</code></pre>
<pre><code class="language-javascript">var twoSum = function(numbers, target) {
    let left = 0;
    let right = numbers.length - 1;

    while (left &lt; right) {
        let total = numbers[left] + numbers[right];

        if (total === target) {
            return [left + 1, right + 1];
        } else if (total &gt; target) {
            right--;
        } else {
            left++;
        }
    }    
};
</code></pre>
<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;

        while (left &lt; right) {
            int total = numbers[left] + numbers[right];

            if (total == target) {
                return new int[]{left + 1, right + 1};
            } else if (total &gt; target) {
                right--;
            } else {
                left++;
            }
        }
        return new int[]{-1, -1}; // If no solution is found        
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;

        while (left &lt; right) {
            int total = numbers[left] + numbers[right];

            if (total == target) {
                return {left + 1, right + 1};
            } else if (total &gt; target) {
                right--;
            } else {
                left++;
            }
        }
        return {-1, -1}; // If no solution is found        
    }
};
</code></pre>
<h4>Step by Step Algorithm</h4>
<ol>
<li><strong>Initialize Pointers</strong>:</li>
<li>
<p>Set <code>left</code> pointer to the start of the array, i.e., index 0.</p>
<p><code>python
 left = 0</code>
   - Set <code>right</code> pointer to the end of the array, i.e., index <code>len(numbers) - 1</code>.</p>
<p><code>python
 right = len(numbers) - 1</code></p>
</li>
<li>
<p><strong>Loop Until Pointers Meet</strong>:</p>
</li>
<li>
<p>Enter a <code>while</code> loop that continues until the <code>left</code> pointer is less than the <code>right</code> pointer.</p>
<p><code>python
 while left &lt; right:</code></p>
</li>
<li>
<p><strong>Calculate Sum</strong>:</p>
</li>
<li>
<p>Calculate the sum of the elements at indices <code>left</code> and <code>right</code> in the <code>numbers</code> array and store it in the variable <code>total</code>.</p>
<p><code>python
 total = numbers[left] + numbers[right]</code></p>
</li>
<li>
<p><strong>Check Sum Against Target</strong>:</p>
</li>
<li>
<p>Check if the <code>total</code> sum equals the <code>target</code> value.</p>
<p><code>python
 if total == target:</code>
 - If it does, return an array containing the indices <code>left + 1</code> and <code>right + 1</code>. These indices are incremented by 1 to convert them to 1-indexed format as mentioned in the problem statement.</p>
<p><code>python
   return [left + 1, right + 1]</code>
 - If not, proceed to the next steps.</p>
</li>
<li>
<p><strong>Adjust Pointers</strong>:</p>
</li>
<li>
<p>If the <code>total</code> sum is greater than the <code>target</code>, decrement the <code>right</code> pointer. This indicates that we need to decrease the sum, so we move towards smaller values by decreasing the index of the right pointer.</p>
<p><code>python
 elif total &gt; target:
     right -= 1</code>
   - If the <code>total</code> sum is less than the <code>target</code>, increment the <code>left</code> pointer. This indicates that we need to increase the sum, so we move towards larger values by increasing the index of the left pointer.</p>
<p><code>python
 else:
     left += 1</code></p>
</li>
<li>
<p><strong>Repeat</strong>:</p>
</li>
<li>
<p>Repeat steps 3-5 until either the condition <code>left &lt; right</code> becomes false, or a valid pair summing up to the target is found.</p>
</li>
<li>
<p><strong>Return Default Value</strong>:</p>
</li>
<li>
<p>If no valid pair summing up to the target is found within the array, return an array containing <code>-1, -1</code> as there is no solution.</p>
<p><code>python
 return [-1, -1]</code></p>
</li>
</ol>
<p>This algorithm efficiently finds a pair of indices in the given sorted array <code>numbers</code> whose elements sum up to the given <code>target</code>. It utilizes a two-pointer approach to navigate through the array and converge towards the target sum.</p>
<p>Thank you for reading my post. Please upvote it and don't forget to subscribe to my channel!</p>
<h5>⭐️ Subscribe URL</h5>
<p>http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<h5>⭐️ Twitter</h5>
<p>https://twitter.com/CodingNinjaAZ</p>
<h5>⭐️ The question #6 - Zigzag Conversion</h5>
<p>post
https://leetcode.com/problems/zigzag-conversion/solutions/5004842/simple-solution/</p>
<p>video
https://youtu.be/fxhPxvBAvD0</p></div><div class='python-solution'><h4>Python different solutions (two-pointer, dictionary, binary search). [Votes: 803]</h4><pre><code>    
#### two-pointer
def twoSum1(self, numbers, target):
    l, r = 0, len(numbers)-1
    while l &lt; r:
        s = numbers[l] + numbers[r]
        if s == target:
            return [l+1, r+1]
        elif s &lt; target:
            l += 1
        else:
            r -= 1

#### dictionary           
def twoSum2(self, numbers, target):
    dic = {}
    for i, num in enumerate(numbers):
        if target-num in dic:
            return [dic[target-num]+1, i+1]
        dic[num] = i

#### binary search        
def twoSum(self, numbers, target):
    for i in xrange(len(numbers)):
        l, r = i+1, len(numbers)-1
        tmp = target - numbers[i]
        while l &lt;= r:
            mid = l + (r-l)//2
            if numbers[mid] == tmp:
                return [i+1, mid+1]
            elif numbers[mid] &lt; tmp:
                l = mid+1
            else:
                r = mid-1
</code></pre></div>