<div class='cpp-solution'><h4>Beats 100% 3 Line Solution ||  Fully MOST Optimised Code [Votes: 530]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>Start!!</p>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>Example:-1234567 ,k=3
1.first reverse the numbers form index 0 to n-k;
-&gt;4321 567
2.reverse the k elements from the last 
-&gt;4321 765
3.now reverse the whole nums;
-&gt;5671234 Done Answer is here !!!!</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>O(N)
- Space complexity:</p>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>O(1)</p>
<h4>Code</h4>
<pre><code>class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        // vector&lt;int&gt;temp;
        // int len=nums.size();
        // int j=0;
        // k=k%len;
        // for(int i=0;i&lt;abs(len-k);i++)
        // {
        //     //1,2,3,4
        //     cout&lt;&lt;nums[i]&lt;&lt;&quot; &quot;;
        //     temp.push_back(nums[i]);
        // }
        // cout&lt;&lt;endl;
        // for(int i=abs(len-k);i&lt;len;i++)
        // {
        //     //5,6,7

        //     cout&lt;&lt;nums[i]&lt;&lt;endl;
        //     nums[abs(i-abs(len-k))]=nums[i];
        // }
        // for(int i=k;i&lt;len;i++)
        // {
        //     nums[i]=temp[j];
        //     j++;
        // }

        k=k%nums.size();
        reverse(nums.begin(),nums.begin()+(nums.size()-k));

        reverse(nums.begin()+(nums.size()-k),nums.end());

        reverse(nums.begin(),nums.end());







    }
};
</code></pre>
<p><strong>Important -&gt; Search <em>yashsiwach</em> in solutions of any question to get my image Solution thanks!</strong></p>
<h4>Connect on LinkedIn ,link in Leetcode Profile !</h4>
<p><strong>Upvote if it Helped !</strong></p></div><div class='python-solution'><h4>[Java/C++/Python] A very-very well detailed explanation [Votes: 591]</h4><pre><code>Well, to be honest with you all. This is really not a hard problem! It's an easy one
</code></pre>
<p>Alright, what the question is saying that we have <strong>given an array &amp; we have to rotate the array to the right by k steps, where k is non-negative.</strong></p>
<pre><code>Okay so, we have one thing that k will always be &gt; 0.
But, I will teach you, one bonus point as well what if k &lt; 0 i.e. k is -ve then how can you rotate the array.
</code></pre>
<p>Let's undertsand this problem using an example,
<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3
<strong>Output:</strong> [5,6,7,1,2,3,4]</p>
<pre><code>&quot;K all possible rotation&quot;

[7,1,2,3,4,5,6], k = 1
[6,7,1,2,3,4,5], k = 2
[5,6,7,1,2,3,4], k = 3
[4,5,6,7,1,2,3], k = 4
[3,4,5,6,7,1,2], k = 5
[2,3,4,5,6,7,1], k = 6
[1,2,3,4,5,6,7], k = 7
</code></pre>
<p>We have <strong>k is 3</strong>, so it means we have to take <strong>3 values from the back</strong> and <strong>put in the front</strong> of the array values.</p>
<p>So, for that what we will do is, we will break Array into 2 parts. <strong>Part1[P1] &amp; Part2[P2]</strong>
* <code>[P1] is defined as</code> the array part just before the last 3 values. What I mean is something like [1,2,3,4]
* <code>[P2] is defined as</code> the array part just after remaining values which we have to rotate [5,6,7]</p>
<p>So, in order to rotate this Array <strong>k times</strong> what we will do is, we will reverse the <strong>P1 first which become [4,3,2,1]</strong> &amp; then we <strong>reverse P2 which becomes [7,6,5]</strong>
Now finally what we have to do is we gonna <strong>reverse the complete array</strong> by doing that what will happen is our array become <strong>[5,6,7,1,2,3,4]</strong> and that's what we want in our <strong>Output</strong></p>
<p>But, what if we have <strong>k = 101</strong>, then we will <strong>not rotate it</strong> 101 times. It simply means <strong>till 100 times it will be [1,2,3,4,5,6,7]</strong> &amp; we have to <strong>rotate only 1 time i.e. [7,1,2,3,4,5,6]</strong>. So, now your question is how can we handle this, we simply do the <strong>modulo of "k"</strong> with length of array</p>
<pre><code>Okay Bonus point what if we have k = -1, then how can we rotate the array. If k is -1 then we have to rotate the value backward not in the front.
Eg - 
Input : [1,2,3,4,5,6,7], k = -1
Output : [2,3,4,5,6,7,1]

Now how did we figure out this, if you carefully look that k = -1 is equals to k = 6.
Just look at the table which I have made for every possible k values

So, what It represent is that add the -ve value to the length of array. And you will get your answer!
</code></pre>
<p><em>I hope Approach is crystal clear now!</em> <strong>Let's do some dirty work</strong>, <code>"code it up"</code></p>
<p><em>code each line explained :</em> <code>Similar for cpp, Java, Python</code> <strong>{Only Syntax Difference}</strong> approach same
* Step - 1</p>
<pre><code>// reversing the array values
    public static void reverse(int nums[], int i, int j){
        int li = i; // left index;
        int ri = j; // right index

        while(li &lt; ri){
            int temp = nums[li];
            nums[li] = nums[ri];
            nums[ri] = temp;

            li++;
            ri--;
        }
    }
</code></pre>
<ul>
<li>Step - 2</li>
</ul>
<pre><code>public void rotate(int[] nums, int k) {
        k = k % nums.length; // if we have let's say 101 to rotate, then we only rotate it 1 time not 101 times
        if(k &lt; 0){ // if we get -ve value, then -ve is just equals to it's -ve + array.length
            k += nums.length;
        }
        // part 1 reverse
        reverse(nums, 0, nums.length - k - 1);
        // part 2 reverse
        reverse(nums, nums.length - k, nums.length - 1);
        // complete reverse
        reverse(nums, 0, nums.length - 1);
    }
</code></pre>
<p><strong>Java</strong></p>
<pre><code>class Solution {
     public static void reverse(int nums[], int i, int j){
        int li = i;
        int ri = j;

        while(li &lt; ri){
            int temp = nums[li];
            nums[li] = nums[ri];
            nums[ri] = temp;

            li++;
            ri--;
        }
    }
    public void rotate(int[] nums, int k) {
        k = k % nums.length; 
        if(k &lt; 0){ 
            k += nums.length;
        }
        reverse(nums, 0, nums.length - k - 1);
        reverse(nums, nums.length - k, nums.length - 1);
        reverse(nums, 0, nums.length - 1);
    }
}
</code></pre>
<p><strong>cpp</strong></p>
<pre><code>class Solution {
    public :
    void reverse(vector&lt;int&gt;&amp; nums, int i, int j){
        int li = i; // left;
        int ri = j;

        while(li &lt; ri){
            int temp = nums[li];
            nums[li] = nums[ri];
            nums[ri] = temp;

            li++;
            ri--;
        }
    }
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        k = k % nums.size();
        if(k &lt; 0){ 
            k += nums.size();
        }
        reverse(nums, 0, nums.size() - k - 1);
        reverse(nums, nums.size() - k, nums.size() - 1);
        reverse(nums, 0, nums.size() - 1);
    }
};
</code></pre>
<p><strong>Python</strong></p>
<pre><code>class Solution:
    def reverse (self, nums, i, j) : 
        li = i
        ri = j

        while li &lt; ri:
            temp = nums[li]
            nums[li] = nums[ri]
            nums[ri] = temp

            li += 1
            ri -= 1
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        k = k % len(nums)
        if k &lt; 0 : 
            k += len(nums)

        self.reverse(nums, 0, len(nums) - k - 1);
        self.reverse(nums, len(nums) - k, len(nums) - 1);
        self.reverse(nums, 0, len(nums) - 1);
</code></pre>
<p>ANALYSIS :-
* <strong>Time Complexity :-</strong> BigO(N)</p>
<ul>
<li><strong>Space Complexity :-</strong> BigO(1)</li>
</ul></div>