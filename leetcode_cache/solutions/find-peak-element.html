<div class='cpp-solution'><h4>✅☑️ Best C++ 3 Solution || Binary Search || Iterative-Recursive || Brute Force->Optimize. [Votes: 203]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>We can Solved this question using multiple approach. (Here I have explained all the possible solutions of this problem).</p>
<ol>
<li>Solved using Linear Search. Brute Force Approach</li>
<li>Solved using Binary Search (Recursive Approach).</li>
<li>Solved using Binary Search (Iterative Approach). Optimized Approach.</li>
</ol>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>We can easily understand the all the approaches by seeing the code which is easy to understand with comments.</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>Time complexity is given in code comment.</p>
<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>Space complexity is given in code comment.</p>
<h4>Code</h4>
<pre><code>/*

    Time Complexity : O(N), because in the worst case we traverse the &lt;= N element. Where N is the size of the
    Array(nums).

    Space Complexity : O(1), the space complexity is constant.

    Solved using Linear Search.

*/


/***************************************** Approach 1 First Code *****************************************/

class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        for(int i=0; i&lt;n-1; i++){
            if(nums[i] &gt; nums[i+1]){
                return i;
            }
        }
        return n-1;
    }
};






/***************************************** Approach 1 Second Code *****************************************/

class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        return max_element(nums.begin(), nums.end()) - nums.begin();
    }
};






/*

    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity
    is logarithmic.

    Space Complexity : O(logN), Recursion stack space.

    Solved using Binary Search (Recursive Approach).

*/


/***************************************** Approach 2 First Code *****************************************/

class Solution {
private: 
    int recursive_binary_search(vector&lt;int&gt;&amp; nums, int low, int high){
        if(low == high){
            return low;
        }
        int mid = (low + high) &gt;&gt; 1;
        if(nums[mid] &gt; nums[mid+1]){
            return recursive_binary_search(nums, low, mid);
        }
        else{
            return recursive_binary_search(nums, mid+1, high);
        }
    }
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        return recursive_binary_search(nums, 0, nums.size()-1);
    }
};






/*

    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity
    is logarithmic.

    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is
    constant.

    Solved using Binary Search (Iterative Approach).

*/


/***************************************** Approach 3 First Code *****************************************/

class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int low = 0;
        int high = nums.size()-1;
        while(low &lt; high){
            int mid = (low + high) &gt;&gt; 1;
            if(nums[mid] &gt; nums[mid+1]){
                high = mid;
            }
            else{
                low = mid + 1;
            }
        }
        return low;
    }
};

</code></pre>
<p><strong><em>IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.</em></strong></p></div><div class='python-solution'><h4>My clean and readable python solution [Votes: 248]</h4><pre><code>Basic Idea: Binary search

Elaboration: 
 if an element(not the right-most one) is smaller than its right neighbor, then there must be a peak element on its right, because the elements on its right is either 
   1. always increasing  -&gt; the right-most element is the peak
   2. always decreasing  -&gt; the left-most element is the peak
   3. first increasing then decreasing -&gt; the pivot point is the peak
   4. first decreasing then increasing -&gt; the left-most element is the peak

   Therefore, we can find the peak only on its right elements( cut the array to half)

   The same idea applies to that an element(not the left-most one) is smaller than its left neighbor.



Conditions:
     1. array length is 1  -&gt; return the only index 
     2. array length is 2  -&gt; return the bigger number's index 
     3. array length is bigger than 2 -&gt; 
           (1) find mid, compare it with its left and right neighbors  
           (2) return mid if nums[mid] greater than both neighbors
           (3) take the right half array if nums[mid] smaller than right neighbor
           (4) otherwise, take the left half

Run time: O(logn)
Memory: constant
Test cases: 
     [1]
     [1,2]
     [2,1]
     [1,2,3]
     [3,2,1]
     [2,1,3]


def findPeakElement(self, nums):
    left = 0
    right = len(nums)-1

    #### handle condition 3
    while left &lt; right-1:
        mid = (left+right)/2
        if nums[mid] &gt; nums[mid+1] and nums[mid] &gt; nums[mid-1]:
            return mid

        if nums[mid] &lt; nums[mid+1]:
            left = mid+1
        else:
            right = mid-1

    #handle condition 1 and 2
    return left if nums[left] &gt;= nums[right] else right
</code></pre></div>