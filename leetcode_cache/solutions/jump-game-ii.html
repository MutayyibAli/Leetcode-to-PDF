<div class='cpp-solution'><h4>C++‚úÖ‚úÖ | Fasterüß≠ than 75%üî•| Straight Forward MethodüÜó | Clean And Concise Code | [Votes: 525]</h4><h4>Code</h4>
<h4>Please Do Upvote!!!!</h4>
<h6>## Connect with me on Linkedin -&gt; https://www.linkedin.com/in/md-kamran-55b98521a/</h6>
<pre><code>
class Solution {
public:

    int jump(vector&lt;int&gt;&amp; nums) {

      for(int i = 1; i &lt; nums.size(); i++)
      {
        nums[i] = max(nums[i] + i, nums[i-1]);
      }

      int ind = 0;
      int ans = 0;

      while(ind &lt; nums.size() - 1)
      {
        ans++;
        ind = nums[ind];
      }

      return ans;
    }
};


</code></pre></div><div class='python-solution'><h4>„ÄêVideo„ÄëKeep near and far position and get the farthest position [Votes: 508]</h4><h4>Intuition</h4>
<p>Keep near and far position and get the farthest position</p>
<h4>Solution Video</h4>
<p>https://youtu.be/KHtghQD0vII</p>
<h6>‚≠êÔ∏è‚≠êÔ∏è Don't forget to subscribe to my channel! ‚≠êÔ∏è‚≠êÔ∏è</h6>
<p><strong>‚ñ† Subscribe URL</strong>
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>Subscribers: 5,614</p>
<h4>Approach</h4>
<pre><code>Input: nums = [2,3,1,1,4]
</code></pre>
<p>We start from index <code>0</code>. In that case above, we have two choices. I mean jump to index <code>1</code> or index <code>2</code>.</p>
<p>Problem</p>
<p>We don't know whether we should jump to index <code>1</code> or index <code>2</code> to get minimum number of jumps in the end.</p>
<p>Let's think about index <code>1</code> and index <code>2</code> cases.</p>
<p>From index <code>1</code>, We have three choices. Jump to index <code>2</code>, <code>3</code> or <code>4</code>.
From index <code>2</code>, We have one choice. Jump to index <code>3</code>.</p>
<p>‚≠êÔ∏è„ÄÄPoints</p>
<p>Important thing is that farthest position(= index <code>2</code>) from previous jump position(= index <code>0</code>) is not always following the next farthest position.</p>
<p>From index <code>0</code>, the farthest position should be index <code>2</code>, because maximum jump from index <code>0</code> is <code>2</code>. But if we jump from index <code>2</code>, we can jump to the next position(= index <code>3</code>).</p>
<p>On the other hand, if we jump to index <code>1</code> from index <code>0</code>, we can jump to index <code>4</code> from index <code>1</code>. which is farther than index <code>3</code> from index <code>2</code>.</p>
<p>So my strategy is <strong>to have near and far position and we check all jumps between the positions and get the farthest position every time.</strong>  </p>
<p>Let's see one by one.</p>
<pre><code>Input: nums = [2,3,1,1,4]

near = 0
far = 0
jumps = 0
</code></pre>
<p>First of all, the range betwee <code>near</code> and <code>far</code> is <code>0</code>, so we check only index <code>0</code>. The farthest position should be </p>
<pre><code>farthest position = current index + maximum jump
= 0 + 2
= 2
</code></pre>
<p>We check all positions in the range.</p>
<p>Next, before we move to the next range, we should update <code>near</code>, <code>far</code> and <code>jumps</code>.</p>
<p>This question guarantee that we can definitely reach the last index, so at least, we must move forward from the current range, so</p>
<p>The next <code>near</code> position should be </p>
<pre><code>far + 1
</code></pre>
<p>Because far position is the most right position of current range.</p>
<p>The next <code>far</code> position should be </p>
<pre><code>far = current farthest we found = 2
</code></pre>
<p>Of course, add +1 to jump times</p>
<pre><code>jumps += 1
</code></pre>
<p>In the end,</p>
<pre><code>   n f
[2,3,1,1,4]

jumps = 1
</code></pre>
<p>Next we check between index <code>1</code> and index <code>2</code>.</p>
<p>From index <code>1</code>, the farthest position should </p>
<pre><code>farthest = 1 + 3 = 4
</code></pre>
<p>From index <code>2</code>, the farthest position should </p>
<pre><code>farthest = 2 + 1 = 3
</code></pre>
<p>We take index <code>4</code>. Then update <code>near</code>, <code>far</code> and <code>jumps</code>.</p>
<pre><code>near = far + 1 = 3
far = farthest = 4
jumps = 1 + 1 = 2
</code></pre>
<p>In the end,</p>
<pre><code>       n f
[2,3,1,1,4]

jumps = 2
</code></pre>
<p>We will repeat the same algorithm. And now far position is reach the last index, so we stop iteration.</p>
<pre><code>return 2(= jumps)
</code></pre>
<p>Easy!
Let's see solution codes and step by step algorithm!</p>
<p>‚≠êÔ∏è Related Question</p>
<p>I solved Jump Game ‚Ö† the other day. Check it out!</p>
<p>https://youtu.be/m6AymRRYgko</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $$O(n)$$</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: $$O(1)$$</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<pre><code class="language-python">class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        near = far = jumps = 0

        while far &lt; len(nums) - 1:
            farthest = 0
            for i in range(near, far + 1):
                farthest = max(farthest, i + nums[i])

            near = far + 1
            far = farthest
            jumps += 1

        return jumps
</code></pre>
<pre><code class="language-javascript">var jump = function(nums) {
    let near = 0, far = 0, jumps = 0;

    while (far &lt; nums.length - 1) {
        let farthest = 0;
        for (let i = near; i &lt;= far; i++) {
            farthest = Math.max(farthest, i + nums[i]);
        }
        near = far + 1;
        far = farthest;
        jumps++;
    }

    return jumps;    
};
</code></pre>
<pre><code class="language-java">class Solution {
    public int jump(int[] nums) {
        int near = 0, far = 0, jumps = 0;

        while (far &lt; nums.length - 1) {
            int farthest = 0;
            for (int i = near; i &lt;= far; i++) {
                farthest = Math.max(farthest, i + nums[i]);
            }
            near = far + 1;
            far = farthest;
            jumps++;
        }

        return jumps;        
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        int near = 0, far = 0, jumps = 0;

        while (far &lt; nums.size() - 1) {
            int farthest = 0;
            for (int i = near; i &lt;= far; i++) {
                farthest = max(farthest, i + nums[i]);
            }
            near = far + 1;
            far = farthest;
            jumps++;
        }

        return jumps;        
    }
};
</code></pre>
<h4>Step by Step Algorithm</h4>
<ol>
<li><strong>Initialization</strong>:
   <code>python
   near = far = jumps = 0</code></li>
<li><code>near</code>: This variable represents the start of the current range of indices we are considering for jumps.</li>
<li><code>far</code>: This variable represents the end of the current range of indices we are considering for jumps.</li>
<li>
<p><code>jumps</code>: This variable keeps track of the number of jumps made.</p>
</li>
<li>
<p><strong>While Loop</strong>:
   <code>python
   while far &lt; len(nums) - 1:</code></p>
</li>
<li>
<p>The loop continues until the <code>far</code> index reaches or exceeds the last index of the array (<code>len(nums) - 1</code>).</p>
</li>
<li>
<p><strong>Initialization of Farthest</strong>:
   <code>python
   farthest = 0</code></p>
</li>
<li>
<p><code>farthest</code>: This variable will store the farthest index we can reach from the current range of indices (<code>near</code> to <code>far</code>).</p>
</li>
<li>
<p><strong>For Loop</strong>:
   <code>python
   for i in range(near, far + 1):
       farthest = max(farthest, i + nums[i])</code></p>
</li>
<li>This loop iterates through the current range of indices from <code>near</code> to <code>far</code>.</li>
<li>For each index <code>i</code>, it calculates <code>i + nums[i]</code> which is the farthest index we can reach by jumping from index <code>i</code>.</li>
<li>
<p>It updates <code>farthest</code> to be the maximum of its current value and <code>i + nums[i]</code>.</p>
</li>
<li>
<p><strong>Update Near and Far</strong>:
   <code>python
   near = far + 1
   far = farthest
   jumps += 1</code></p>
</li>
<li><code>near</code>: Update the start of the next range to be one index after the current <code>far</code>.</li>
<li><code>far</code>: Update the end of the next range to be <code>farthest</code> calculated in the for loop.</li>
<li>
<p><code>jumps</code>: Increment the number of jumps made by 1.</p>
</li>
<li>
<p><strong>Return Statement</strong>:
   <code>python
   return jumps</code></p>
</li>
<li>After exiting the while loop, the function returns the total number of jumps made to reach the last index.</li>
</ol>
<p>Thank you for reading my post.</p>
<h6>## ‚≠êÔ∏è Subscribe URL</h6>
<p>http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<h6>## ‚≠êÔ∏è Twitter</h6>
<p>https://twitter.com/CodingNinjaAZ</p>
<h6>## ‚≠êÔ∏è My previous post and video</h6>
<h1>36 Valid Sudoku</h1>
<p>video
https://youtu.be/RdakO1_niYE</p></div>