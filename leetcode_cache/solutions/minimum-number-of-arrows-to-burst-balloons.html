<div class='cpp-solution'><h4>✅C++||SHORT AND EASY CODE||EXPLAINED✅ [Votes: 200]</h4><h4>Approach</h4>
<p><strong>Greedy algorithm</strong>
1.An arrow shoots through multiple intervals, all of which are coincident. We try to stack the overlapping intervals together and give a jump.
2.To facilitate identifying coincidence in a single traversal, we sort in ascending order on the right</p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity:O(NlogN)</p>
</li>
<li>
<p>Space complexity:O(1)</p>
</li>
</ul>
<h4>Code</h4>
<pre><code>class Solution {
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; p) {
        sort(p.begin(), p.end());
        int lastpoint = p[0][1];
        int ans = 1;
        for(auto point : p) {
            if(point[0] &gt; lastpoint) {
                ans++;
                lastpoint = point[1];
            }
            lastpoint = min(point[1],lastpoint);
        }
        return ans;
    }
};
</code></pre>
<p><strong><em>IF YOU LIKE THE SOLUTION PLEASE UPVOTE.</em></strong>
let's connnect <a href="https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/">Linkdin</a> AND <a href="https://t.me/mahesh_vishnoi29">Telegram</a></p></div><div class='python-solution'><h4>✅ [C++/Java/Python] 6 Lines || Sort and Greedy || Image Explanation [Votes: 332]</h4><p><strong>PLEASE UPVOTE if you like</strong>  <strong>If you have any question, feel free to ask.</strong> </p>
<ul>
<li>Problem Understanding<ul>
<li>There is some <strong>misleading</strong> in the description of the problem, <strong><code>points</code> are not points but line segments, so I just modify <code>points</code> to <code>segments</code>.</strong></li>
<li>There are several <code>segments</code> on the one-dimensional coordinate axis, find out the minimum number of <code>arrows</code> which are orthogonal to the coordinate axis so that each <code>segment</code> can be shot through by at least one <code>arrow</code>.</li>
</ul>
</li>
<li>Approch<ul>
<li>Sort the <code>segments</code> by the end</li>
<li>put an arrow at the end of the 1-st <code>segment</code></li>
<li>from the 2-nd <code>segment</code>, we check whether the current arrow pass through the current <code>segment</code>, if not add an arrow, put it at the end of the current <code>segment</code></li>
</ul>
</li>
</ul>
<p><strong>Python</strong></p>
<pre><code class="language-py">class Solution(object):
    def findMinArrowShots(self, segments):
        segments.sort(key=lambda p: p[1])
        ans, arrow = 0, 0
        for [start, end] in segments:
            if ans == 0 or start &gt; arrow:
                ans, arrow = ans + 1, end
        return ans
</code></pre>
<p><strong>cpp</strong></p>
<pre><code>bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {return a[1] &lt; b[1];}
class Solution {
public:  
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; segments) {
        sort(segments.begin(), segments.end(), cmp);
        int ans = 0, arrow = 0;
        for (int i = 0; i &lt; segments.size(); i ++) {
            if (ans == 0 || segments[i][0] &gt; arrow) {
                ans ++;
                arrow = segments[i][1];
            }
        }
        return ans;
    }
};
</code></pre>
<p><strong>Java</strong></p>
<pre><code>class Solution {
    public int findMinArrowShots(int[][] segments) {
        Arrays.sort(segments, (a, b) -&gt; Integer.compare(a[1], b[1]));
        int ans = 0, arrow = 0;
        for (int i = 0; i &lt; segments.length; i ++) {
            if (ans == 0 || segments[i][0] &gt; arrow) {
                ans ++;
                arrow = segments[i][1];
            }
        }
        return ans;
    }
}

</code></pre>
<p><strong>PLEASE UPVOTE if you like</strong>  <strong>If you have any question, feel free to ask.</strong></p></div>