<div class='cpp-solution'><h4>✅💯🔥Simple Code🚀📌|| 🔥✔️Easy to understand🎯 || 🎓🧠Beats 100%🔥|| Beginner friendly💀💯 [Votes: 25]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->

<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->

<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Code</h4>
<pre><code>class Solution {
    public int maxOperations(int[] nums, int k) {
        int ops=0;
        int i=0; 
        int j= nums.length-1;
        Arrays.sort(nums);
        while(i&lt;j){
            if(nums[i]+nums[j]==k){
                ops++;
                i++; j--;
            } else if(nums[i]+nums[j]&gt;k){
                j--;
            } else{
                i++;
            }
        }
        return ops;
    }
}
</code></pre></div><div class='python-solution'><h4>Python Two pointer well explain solution quick and still mantain O(1) space complexity [Votes: 104]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>The intuition behind this solution is to use a <code>two-pointer</code> approach on a sorted array. Sorting the array allows us to efficiently find pairs of numbers that sum up to the target value <code>k</code>. The two pointers (<code>left</code> and <code>right</code>) are initialized at the beginning and end of the sorted array, and we move them towards each other based on the sum of the numbers at those positions.</p>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p><strong>Sort the array:</strong> We begin by sorting the input array nums. Sorting is essential for the two-pointer approach. using the <code>nums.sort()</code></p>
<p><strong>Iterate with two pointers:</strong>  Use a while loop to iterate until <code>left</code> pointer is less than <code>right</code> pointer.
    - If the sum of <code>nums[left]</code> and <code>nums[right]</code> is equal to the target k, we have found a pair, so we increment the operation count and move both pointers towards the center
    - If the sum is less than <strong>k</strong>, we need a larger sum, so we move the left pointer to the right.
    - If the sum is greater than <strong>k</strong>, we need a smaller sum, so we move the right pointer to the left.</p>
<p><strong>Return the count:</strong> After the while loop completes, return the operation count, which represents the maximum number of pairs that can be formed to achieve the target sum.</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>The time complexity is dominated by the sorting step, which is typically O(n log n) for the average case. The two-pointer traversal of the sorted array is O(n), so the overall time complexity is <strong>O(n log n)</strong>
- Space complexity:</p>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>The space complexity is <strong>O(1)</strong> because the algorithm uses a constant amount of extra space for the pointers and variables, regardless of the input size.</p>
<h4>Code</h4>
<pre><code>class Solution:
    def maxOperations(self, nums: List[int], k: int) -&gt; int:
        nums.sort()

        left = 0 
        right = len(nums) - 1
        operation = 0 

        while left &lt; right:
            if ((nums[left] + nums[right]) == k):
                operation += 1
                left +=1 
                right -=1
            elif((nums[left] + nums[right]) &lt; k):
                left += 1
            else:
                right -= 1
        return operation

</code></pre>
<h5>Please upvote this solution if you enjoyed it</h5></div>