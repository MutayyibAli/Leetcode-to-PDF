<div class='cpp-solution'><h4>C++ solution beats 100% [Votes: 119]</h4><pre><code>class Solution {
public:
    void flatten(TreeNode* root) {
        if( root )
        {
            /*Move the left node to the right node*/
            TreeNode* temp = root-&gt;right;
            root-&gt;right = root-&gt;left;
            root-&gt;left = nullptr;
            TreeNode* node = root;

            /*Move to the end of the prev left node which is the new right node*/
            while( node-&gt;right )
            {
                node = node-&gt;right;
            }

            /*Append the right node to its end*/
            node-&gt;right = temp;
            flatten( root-&gt;right ); 
        } 
        return;

    }
};
</code></pre></div><div class='python-solution'><h4>JS, Python, Java, C++ | Simple O(1) Space & Recursive Solutions w/ Explanation [Votes: 324]</h4><p><em>(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,</em> <strong><em>please upvote</em></strong> <em>this post.)</em></p>
<h6># <strong><em>Idea:</em></strong></h6>
<p><strong><em>Morris Traversal (O(1) Space, O(N) Time) Approach:</em></strong></p>
<p>There <em>is</em> actually a way to traverse a binary tree with a <strong>space complexity</strong> of <strong>O(1)</strong> while staying at a <strong>time complexity</strong> of <strong>O(N)</strong>, though it does require modifying the tree's structure. In this problem that's specifically being called for, so it's a valid approach, though it won't always be appropriate to modify the source binary tree in other situations.</p>
<p>The approach is called the <strong>Morris traversal</strong>. At its heart, it takes advantage of the basic nature of ordered traversals to iterate through and unwind the tree. In a <strong>pre-order traversal</strong> of a binary tree, each vertex is processed in <strong>(node, left, right)</strong> order. This means that the entire left subtree could be placed between the node and its right subtree.</p>
<p>To do this, however, we'll first have to locate the last node in the left subtree. This is easy enough, since we know that the last node of a pre-order tree can be found by moving right as many times as possible from its root.</p>
<p>So we should be able to move through the binary tree, keeping track of the curent node (<strong>curr</strong>). Whenever we find a left subtree, we can dispatch a <strong>runner</strong> to find its last node, then stitch together both ends of the left subtree into the right path of <strong>curr</strong>, taking heed to sever the left connection at <strong>curr</strong>.</p>
<p>Once that's done, we can continue to move <strong>curr</strong> to the right, looking for the next left subtree. When <strong>curr</strong> can no longer move right, the tree will be successfully flattened.</p>
<ul>
<li><em><strong>Time Complexity: O(N)</strong> where <strong>N</strong> is the number of <strong>nodes</strong> in the binary tree</em></li>
<li><em><strong>Space Complexity: O(1)</strong></em></li>
</ul>
<p><strong><em>O(1) Space Approach:</em></strong></p>
<p>In order to properly connect the <strong>linked list</strong>, we'll need to start at the bottom and work up. This means that we'll need to move in <em>reverse</em> <strong>pre-order traversal</strong> order through the <strong>binary tree</strong>. Since pre-order traversal is normally <strong>"node, left, right"</strong>, we'll have to move in the reverse order of <strong>"right, left, node"</strong>.</p>
<p>In order to complete this solution in <strong>O(1) space</strong>, we won't be able to conveniently backtrack via a <strong>stack</strong>, so the key to this solution will be to retreat all the way back up to the <strong>root</strong> each time we reach a leaf. This will push the <strong>time complexity</strong> to <strong>O(N^2)</strong>.</p>
<p>We'll want to first set up <strong>head</strong> and <strong>curr</strong> to keep track of the head of the linked list we're building and the current node we're visiting. We'll know we're finished once <strong>head = root</strong>.</p>
<p>To follow the reverse pre-order traversal order, we'll first attempt to go right and then left. Since we're backtracking to <strong>root</strong>, however, we'll eventually run back into the same node that we've set as <strong>head</strong> doing this. To prevent this, we'll stop <em>before</em> moving to the <strong>head</strong> node and sever the connection.</p>
<p>Now that we can't run into already-completed territory, we can be confident that any leaf we move to must be the next value for <strong>head</strong>, so we should connect it to the old <strong>head</strong>, update <strong>head</strong>, and reset back to the <strong>root</strong>.</p>
<p>As noted before, once <strong>head = root</strong>, we've finished our traversal and can exit the function.</p>
<ul>
<li><em><strong>Time Complexity: O(N^2)</strong> where <strong>N</strong> is the number of <strong>nodes</strong> in the binary tree, due to repeated backtracking to root</em></li>
<li><em><strong>Space Complexity: O(1)</strong></em></li>
</ul>
<p><strong><em>Recursive Approach:</em></strong></p>
<p>In order to properly connect the <strong>linked list</strong>, we'll need to start at the bottom and work up. This means that we'll need to move in <em>reverse</em> <strong>pre-order traversal</strong> order through the <strong>binary tree</strong>. Since pre-order traversal is normally <strong>"node, left, right"</strong>, we'll have to move in the reverse order of <strong>"right, left, node"</strong>.</p>
<p>Binary tree traversal is prime ground for a <strong>recursive</strong> solution, so let's define a helper (<strong>revPreOrder</strong>) for the purpose. We'll also keep a global variable <strong>head</strong> to keep track of the head of the linked list as we work our way backwards.</p>
<p>Per our reverse pre-order traversal approach, we want to recursively work down the right path first then the left path, if they exist. Once we've flattened the left and right paths recursively, <strong>head</strong> should at this point be equal to the next node after the current one, so we should set it as <strong>node.right</strong>. We shouldn't forget to set <strong>node.left</strong> to <strong>null</strong>, as well.</p>
<p>Once we're done with the current node, we can update <strong>head</strong> to <strong>node</strong> and allow the recursion to complete and move back up to the next layer. Once the recursion stack is exhausted, <strong>head</strong> will be equal to <strong>root</strong> again.</p>
<p>Lastly, we have to deal with an edge case of an empty <strong>root</strong>, so we can just make sure to only call the initial recursion on <strong>root</strong> if <strong>root</strong> actually is a node. There is no need for a <strong>return</strong> statement, because the test suite will evaluate <strong>root</strong> directly.</p>
<ul>
<li><em><strong>Time Complexity: O(N)</strong> where <strong>N</strong> is the number of <strong>nodes</strong> in the binary tree</em></li>
<li><em><strong>Space Complexity: O(N)</strong> for the <strong>recursion stack</strong>, which is as long as the maximum depth of the binary tree, which can go up to <strong>N</strong></em></li>
</ul>
<h6># <strong><em>Javascript Code:</em></strong></h6>
<h6>## <strong><em>w/ Morris Traversal:</em></strong></h6>
<p>The best result for the code below is <strong>84ms / 40.6MB</strong> (beats 96% / 66%).</p>
<pre><code class="language-javascript">var flatten = function(root) {
    let curr = root
    while (curr) {
        if (curr.left) {
            let runner = curr.left
            while (runner.right) runner = runner.right
            runner.right = curr.right, curr.right = curr.left, curr.left = null
        }
        curr = curr.right
    }
};
</code></pre>
<h6>## <strong><em>w/ O(1) Space:</em></strong></h6>
<p>The best result for the code below is <strong>80ms / 40.6MB</strong> (beats 98% / 66%).</p>
<pre><code class="language-javascript">var flatten = function(root) {
    let head = null, curr = root
    while (head != root) {
        if (curr.right === head) curr.right = null
        if (curr.left === head) curr.left = null
        if (curr.right) curr = curr.right
        else if (curr.left) curr = curr.left
        else curr.right = head, head = curr, curr = root
    }
};
</code></pre>
<h6>## <strong><em>w/ Recursion:</em></strong></h6>
<p>The best result for the code below is <strong>84ms / 40.6MB</strong> (beats 96% / 66%).</p>
<pre><code class="language-javascript">var flatten = function(root) {
    let head = null
    const revPreOrder = node =&gt; {
        if (node.right) revPreOrder(node.right)
        if (node.left) revPreOrder(node.left)
        node.left = null, node.right = head, head = node
    }
    if (root) revPreOrder(root)
};
</code></pre>
<h6># <strong><em>Python Code:</em></strong></h6>
<h6>## <strong><em>w/ Morris Traversal:</em></strong></h6>
<p>The best result for the code below is <strong>32ms / 15.0MB</strong> (beats 92% / 91%).</p>
<pre><code class="language-python">class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        curr = root
        while curr:
            if curr.left:
                runner = curr.left
                while runner.right: runner = runner.right
                runner.right, curr.right, curr.left = curr.right, curr.left, None
            curr = curr.right
</code></pre>
<h6>## <strong><em>w/ O(1) Space:</em></strong></h6>
<p>The best result for the code below is <strong>32ms / 15.0MB</strong> (beats 92% / 91%).</p>
<pre><code>class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        head, curr = None, root
        while head != root:
            if curr.right == head: curr.right = None
            if curr.left == head: curr.left = None
            if curr.right: curr = curr.right
            elif curr.left: curr = curr.left
            else: curr.right, head, curr = head, curr, root
</code></pre>
<h6>## <strong><em>w/ Recursion:</em></strong></h6>
<p>The best result for the code below is <strong>28ms / 14.9MB</strong> (beats 98% / 98%).</p>
<pre><code class="language-python">class Solution:
    head = None
    def flatten(self, root: TreeNode) -&gt; None:
        def revPreOrder(node: TreeNode) -&gt; None:
            if node.right: revPreOrder(node.right)
            if node.left: revPreOrder(node.left)
            node.left, node.right, self.head = None, self.head, node
        if root: revPreOrder(root)
</code></pre>
<h6># <strong><em>Java Code:</em></strong></h6>
<h6>## <strong><em>w/ Morris Traversal:</em></strong></h6>
<p>The best result for the code below is <strong>0ms / 37.9MB</strong> (beats 100% / 98%).</p>
<pre><code class="language-java">class Solution {
    public void flatten(TreeNode root) {
        TreeNode curr = root;
        while (curr != null) {
            if (curr.left != null) {
                TreeNode runner = curr.left;
                while (runner.right != null) runner = runner.right;
                runner.right = curr.right;
                curr.right = curr.left;
                curr.left = null;
            }
            curr = curr.right;
        }
    }
}
</code></pre>
<h6>## <strong><em>w/ O(1) Space:</em></strong></h6>
<p>The best result for the code below is <strong>0ms / 37.9MB</strong> (beats 100% / 98%).</p>
<pre><code>class Solution {
    public void flatten(TreeNode root) {
        TreeNode head = null, curr = root;
        while (head != root) {
            if (curr.right == head) curr.right = null;
            if (curr.left == head) curr.left = null;
            if (curr.right != null) curr = curr.right;
            else if (curr.left != null) curr = curr.left;
            else {
                curr.right = head;
                head = curr;
                curr = root;
            }
        }
    }
}
</code></pre>
<h6>## <strong><em>w/ Recursion:</em></strong></h6>
<p>The best result for the code below is <strong>0ms / 38.0MB</strong> (beats 100% / 98%).</p>
<pre><code class="language-java">class Solution {
    TreeNode head = null;
    public void flatten(TreeNode root) {
        if (root != null) revPreOrder(root);
    }
    private void revPreOrder(TreeNode node) {
        if (node.right != null) revPreOrder(node.right);
        if (node.left != null) revPreOrder(node.left);
        node.left = null;
        node.right = head;
        head = node;
    }
}
</code></pre>
<h6># <strong><em>cpp Code:</em></strong></h6>
<h6>## <strong><em>w/ Morris Traversal:</em></strong></h6>
<p>The best result for the code below is <strong>0ms / 12.6MB</strong> (beats 100% / 95%).</p>
<pre><code class="language-c++">class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;
        while (curr) {
            if (curr-&gt;left) {
                TreeNode* runner = curr-&gt;left;
                while (runner-&gt;right != nullptr) runner = runner-&gt;right;
                runner-&gt;right = curr-&gt;right, curr-&gt;right = curr-&gt;left, curr-&gt;left = nullptr;
            }
            curr = curr-&gt;right;
        }
    }
};
</code></pre>
<h6>## <strong><em>w/ O(1) Space:</em></strong></h6>
<p>The best result for the code below is <strong>0ms / 12.6MB</strong> (beats 100% / 95%).</p>
<pre><code>class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode *head = nullptr, *curr = root;
        while (head != root) {
            if (curr-&gt;right == head) curr-&gt;right = nullptr;
            if (curr-&gt;left == head) curr-&gt;left = nullptr;
            if (curr-&gt;right) curr = curr-&gt;right;
            else if (curr-&gt;left) curr = curr-&gt;left;
            else curr-&gt;right = head, head = curr, curr = root;
        }
    }
};
</code></pre>
<h6>## <strong><em>w/ Recursion:</em></strong></h6>
<p>The best result for the code below is <strong>0ms / 12.6MB</strong> (beats 100% / 95%).</p>
<pre><code class="language-c++">class Solution {
public:
    void flatten(TreeNode* root) {
        if (root) revPreOrder(root);
    }
private:
    TreeNode* head = nullptr;
    void revPreOrder(TreeNode* node) {
        if (node-&gt;right) revPreOrder(node-&gt;right);
        if (node-&gt;left) revPreOrder(node-&gt;left);
        node-&gt;left = nullptr, node-&gt;right = head, head = node;
    }
};
</code></pre></div>