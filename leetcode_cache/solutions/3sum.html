<div class='cpp-solution'><h4>Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments [Votes: 1376]</h4><p>the key idea is the same as the <code>TwoSum</code> problem. When we fix the <code>1st</code> number, the <code>2nd</code> and <code>3rd</code> number can be found following the same reasoning as <code>TwoSum</code>. </p>
<p>The only difference is that, the <code>TwoSum</code> problem of LEETCODE has a unique solution. However, in <code>ThreeSum</code>, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could've ended up with a solution with so many duplicates.</p>
<p>The naive solution for the duplicates will be using the STL methods like below :</p>
<pre><code>std::sort(res.begin(), res.end());
res.erase(unique(res.begin(), res.end()), res.end());
</code></pre>
<p>But according to my submissions, this way will cause you double your time consuming almostly.</p>
<p>A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not.</p>
<p>If the three numbers formed a solution, we can safely ignore all the duplicates of them.</p>
<p>We can do this to all the three numbers such that we can remove the duplicates. </p>
<p>Here's my AC cpp Code:</p>
<pre><code>vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) {

    vector&lt;vector&lt;int&gt; &gt; res;

    std::sort(num.begin(), num.end());

    for (int i = 0; i &lt; num.size(); i++) {

        int target = -num[i];
        int front = i + 1;
        int back = num.size() - 1;

        while (front &lt; back) {

            int sum = num[front] + num[back];

            // Finding answer which start from number num[i]
            if (sum &lt; target)
                front++;

            else if (sum &gt; target)
                back--;

            else {
                vector&lt;int&gt; triplet = {num[i], num[front], num[back]};
                res.push_back(triplet);

                // Processing duplicates of Number 2
                // Rolling the front pointer to the next different number forwards
                while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++;

                // Processing duplicates of Number 3
                // Rolling the back pointer to the next different number backwards
                while (front &lt; back &amp;&amp; num[back] == triplet[2]) back--;
            }

        }

        // Processing duplicates of Number 1
        while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) 
            i++;

    }

    return res;

}
</code></pre></div><div class='python-solution'><h4>[Python] 5 Easy Steps - Beats 97.4% - Annotated [Votes: 1084]</h4><pre><code class="language-python">def threeSum(self, nums: List[int]) -&gt; List[List[int]]:

    res = set()

    #1. Split nums into three lists: negative numbers, positive numbers, and zeros
    n, p, z = [], [], []
    for num in nums:
        if num &gt; 0:
            p.append(num)
        elif num &lt; 0: 
            n.append(num)
        else:
            z.append(num)

    #2. Create a separate set for negatives and positives for O(1) look-up times
    N, P = set(n), set(p)

    #3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P
    ####   i.e. (-3, 0, 3) = 0
    if z:
        for num in P:
            if -1*num in N:
                res.add((-1*num, 0, num))

    #3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0
    if len(z) &gt;= 3:
        res.add((0,0,0))

    #4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)
    ####   exists in the positive number set
    for i in range(len(n)):
        for j in range(i+1,len(n)):
            target = -1*(n[i]+n[j])
            if target in P:
                res.add(tuple(sorted([n[i],n[j],target])))

    #5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)
    ####   exists in the negative number set
    for i in range(len(p)):
        for j in range(i+1,len(p)):
            target = -1*(p[i]+p[j])
            if target in N:
                res.add(tuple(sorted([p[i],p[j],target])))

    return res
</code></pre>
<p><img src = "https://assets.leetcode.com/users/images/86c4a895-77e4-45ac-bebe-21a543b1cfe8_1594231844.7854018.png" width = "500px"></p></div>