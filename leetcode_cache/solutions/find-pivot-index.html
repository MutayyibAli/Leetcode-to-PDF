<div class='cpp-solution'><h4>Python/Go/Java/JS/C++ O(n) sol. by Balance scale. [w/ Animation] 有中文解題文章 [Votes: 214]</h4><p><a href="https://www.youtube.com/watch?v=hK9gdtn2zq0">Tutorial video in Chinese 中文解題影片</a></p>
<p><a href="https://vocus.cc/article/655b6d6ffd89780001b34a15">中文詳解 解題文章</a></p>
<p><a href="https://vocus.cc/article/66d59867fd897800014586cd">用Python來實現Prefix Sum</a></p>
<p><a href="https://vocus.cc/article/660402f4fd8978000101b7b4">從"前綴和"查表高速計算"區間和"的教學專欄</a></p>
<p>O(n) sol. by Balance scale.</p>
<h4>Animation of Balance scale algorithm</h4>
<p><strong>Hint</strong>:</p>
<h1>1.</h1>
<p>Think of the <strong>Balance scale</strong> in laboratory or traditional markets.</p>
<h1>2.</h1>
<p>Imagine each <strong>number</strong> from input list as a <strong>weight</strong>.</p>
<h1>3</h1>
<p>Turn the finding of pivot index with left hand sum = right hand sum into the <strong>procedure of reaching the balance on boths sides</strong>.</p>
<p><strong>Algorithm</strong>:</p>
<p>Step_#1:</p>
<p>Let 
<strong>Left hand side be empty</strong>, and
<strong>Right hand side holds all weights</strong>.</p>
<p>Step_#2:</p>
<p>Iterate weight_<em>i</em> from 0 to (n-1)</p>
<p>During each iteration, <strong>take away weight_#i from right hand side</strong>, <strong>check whether balance is met</strong> or not.</p>
<p><strong>If yes</strong>, then the <strong>index <em>i</em></strong> is the <strong>pivot index</strong>.</p>
<p>If no, <strong>put weight_#<em>i</em> on the left hand side</strong>, and <strong>repeat the process</strong> until balance is met or all weights are exchanged.</p>
<p>Step_#3:</p>
<p>Finally, if all weights are exchanged and no balance is met, then pivot index does not exist, return -1.</p>
<pre><code class="language-python">class Solution:
    def pivotIndex(self, nums: List[int]) -&gt; int:

        #### Initialization:
        #### Left hand side be empty, and
        #### Right hand side holds all weights.
        total_weight_on_left, total_weight_on_right = 0, sum(nums)

        for idx, current_weight in enumerate(nums):

            total_weight_on_right -= current_weight

            if total_weight_on_left == total_weight_on_right:
                #### balance is met on both sides
                #### i.e., sum( nums[ :idx] ) == sum( nums[idx+1: ] )
                return idx

            total_weight_on_left += current_weight

        return -1
</code></pre>
<pre><code class="language-javascript">function Accumulation(arr){
    return arr.reduce((a,b)=&gt;a+b);  
}

var pivotIndex = function(nums) {


    // Initialization:
    // Left hand side be empty, and
    // Right hand side holds all weights.

    let totalWeightOnLeft = 0;
    let totalWeightOnRight = Accumulation(nums);

    for( let i = 0 ; i &lt; nums.length ; i++ ){

        let currentWeight = nums[i];

        totalWeightOnRight -= currentWeight;

        if( totalWeightOnLeft == totalWeightOnRight ){
            // balance is met on both sides
            return i;
        }

        totalWeightOnLeft += currentWeight


    }

    return -1;

};
</code></pre>
<pre><code class="language-java">class Solution {
    public int pivotIndex(int[] nums) {

        // Initialization:
        // Left hand side be empty, and
        // Right hand side holds all weights.
        int totalWeightOnLeft = 0;
        int totalWeightOnRight = IntStream.of( nums ).sum();

        for( int i = 0 ; i &lt; nums.length ; i++ ){

            int curWeight = nums[i];

            totalWeightOnRight -= curWeight;

            if( totalWeightOnLeft == totalWeightOnRight ){
                // balance is met on both sides
                return i;
            }

            totalWeightOnLeft  += curWeight;
        }

        return -1;
    }
}
</code></pre>
<pre><code class="language-Go">func accumulation(nums []int) int{

    summation := 0

    for _, num := range nums{
        summation += num    
    }

    return summation
}


func pivotIndex(nums []int) int {

    // Initialization
    // Left hand side be empty
    // Right hand side holds all weights
    totalWeightOnLeft := 0
    totalWeightOnRight := accumulation( nums )

    for idx, currentWeight := range nums{

        totalWeightOnRight -= currentWeight

        if totalWeightOnLeft == totalWeightOnRight{
            // balance is met on both sides
            return idx
        }

        totalWeightOnLeft += currentWeight
    }

    return -1

}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) {

        // Initialization:
        // Left hand side be empty, and
        // Right hand side holds all weights.

        int totalWeightOnLeft = 0;
        int totalWeightOnRight = std::accumulate( nums.begin(), nums.end(), 0);


        for(std::size_t i = 0; i &lt; nums.size() ; i++ ){

            int currentWeight = nums[i];

            totalWeightOnRight -= currentWeight;

            if( totalWeightOnLeft == totalWeightOnRight ){
                // balance is met on both sides
                return i;
            }

            totalWeightOnLeft += currentWeight;
        }


        return -1;
    }
};
</code></pre>
<p>Time Complexity: O(n) on for loop iteration, and summation of input array.</p>
<p>Sapce Complexity: O(1) on fixed size of temp variables.</p>
<p>Share traditional solution based on prefix sum</p>
<pre><code class="language-python">class Solution:
    def pivotIndex(self, nums: List[int]) -&gt; int:

        #### s = prefix sum of array
        #### s[i] = nums[0] + nums[1] + ... + nums[i]
        s = list( itertools.accumulate(nums) )
        total_sum = sum( nums )

        #### Linear scan on each index
        for i in range( len(nums) ):

            left_sum = s[i-1] if i &gt;= 1 else 0
            right_sum = total_sum - s[i]

            #### Find pivot index from definition
            if left_sum == right_sum:
                return i

        return -1
</code></pre>
<p>Time complexity: O(n) on linear scan as well as prefix sum table</p>
<p>Space complexity: O( n ) on the size of prefix sum table </p></div><div class='python-solution'><h4>Very Easy || 100% || Fully Explained || Java, C++, Python, JS, Python3 [Votes: 910]</h4><h4><strong>Java Solution:</strong></h4>
<pre><code>// Runtime: 1 ms, faster than 92.94% of Java online submissions for Find Pivot Index.
// Time Complexity : O(n)
class Solution {
    public int pivotIndex(int[] nums) {
        // Initialize total sum of the given array...
        int totalSum = 0;
        // Initialize 'leftsum' as sum of first i numbers, not including nums[i]...
        int leftsum = 0;
        // Traverse the elements and add them to store the totalSum...
        for (int ele : nums)
            totalSum += ele;
        // Again traverse all the elements through the for loop and store the sum of i numbers from left to right...
        for (int i = 0; i &lt; nums.length; leftsum += nums[i++])
            // sum to the left == leftsum.
            // sum to the right === totalSum - leftsum - nums[i]..
            // check if leftsum == totalSum - leftsum - nums[i]...
            if (leftsum * 2 == totalSum - nums[i])
                return i;       // Return the pivot index...
        return -1;      // If there is no index that satisfies the conditions in the problem statement...
    }
}
</code></pre>
<h4><strong>cpp Solution:</strong></h4>
<pre><code>// Time Complexity : O(n)
class Solution {
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) {
        // Initialize rightSum to store the sum of all the numbers strictly to the index's right...
        int rightSum = accumulate(nums.begin(), nums.end(), 0);
        // Initialize leftSum to store the sum of all the numbers strictly to the index's left...
        int leftSum = 0;
        // Traverse all elements through the loop...
        for (int idx = 0; idx &lt; nums.size(); idx++) {
            // subtract current elements with from rightSum...
            rightSum -= nums[idx];
            // If the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right...
            if (leftSum == rightSum)
                return idx;     // Return the pivot index...
            // add current elements with leftSum...
            leftSum += nums[idx];
        }
        return -1;      // If there is no index that satisfies the conditions in the problem statement...
    }
};
</code></pre>
<h4><strong>Python/Python3 Solution:</strong></h4>
<pre><code>#### Time Complexity : O(n)
#### Space Complexity : O(1)
class Solution(object):
    def pivotIndex(self, nums):
        #### Initialize leftSum &amp; rightSum to store the sum of all the numbers strictly to the index's left &amp; right respectively...
        leftSum, rightSum = 0, sum(nums)
        #### Traverse elements through the loop...
        for idx, ele in enumerate(nums):
            rightSum -= ele
            #### If the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right...
            if leftSum == rightSum:
                return idx      #### Return the pivot index...
            leftSum += ele
        return -1       #### If there is no index that satisfies the conditions in the problem statement...
</code></pre>
<h4><strong>JavaScript Solution:</strong></h4>
<pre><code>// Time Complexity : O(n)
var pivotIndex = function(nums) {
    // Initialize total sum of the given array...
    let totalSum = 0
    // Traverse the elements and add them to store the totalSum...
    for(let i = 0; i &lt; nums.length; i++) {
        totalSum += nums[i]
    }
    // Initialize 'leftsum' as sum of first i numbers, not including nums[i]...
    let leftSum = 0
    // Again traverse all the elements through the for loop and store the sum of i numbers from left to right...
    for (let i = 0; i &lt; nums.length; i++) {
        // sum to the left == leftsum.
        // sum to the right === totalSum - leftsum - nums[i]..
        // check if leftsum == totalSum - leftsum - nums[i]...
        if (leftSum * 2 == totalSum - nums[i])
            return i;       // Return the pivot index...
        leftSum += nums[i]
    }
    return -1      // If there is no index that satisfies the conditions in the problem statement...
};
</code></pre>
<p><strong>I am working hard for you guys...
Please upvote if you found any help with this code...</strong></p></div>