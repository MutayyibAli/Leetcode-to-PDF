<div class='cpp-solution'><h4>‚úîÔ∏è‚úîÔ∏èEasy Solutions in Java ‚úîÔ∏è‚úîÔ∏è, Python ‚úîÔ∏è, and C++ ‚úîÔ∏èüßêLook at once üíª with Exaplanation [Votes: 2798]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>The problem requires us to determine if the given string of brackets is valid or not. We can use a stack data structure to keep track of opening brackets encountered and check if they match with the corresponding closing brackets.</p>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>Here is the step-by-step approach of the algorithm:
1. Initialize an empty stack.</p>
<ol>
<li>
<p>Traverse the input string character by character.</p>
</li>
<li>
<p>If the current character is an opening bracket (i.e., '(', '{', '['), push it onto the stack.</p>
</li>
<li>
<p>If the current character is a closing bracket (i.e., ')', '}', ']'), check if the stack is empty. If it is empty, return false, because the closing bracket does not have a corresponding opening bracket. Otherwise, pop the top element from the stack and check if it matches the current closing bracket. If it does not match, return false, because the brackets are not valid.</p>
</li>
<li>
<p>After traversing the entire input string, if the stack is empty, return true, because all opening brackets have been matched with their corresponding closing brackets. Otherwise, return false, because some opening brackets have not been matched with their corresponding closing brackets.</p>
</li>
</ol>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>The time complexity of the solution is $$O(n)$$, where n is the length of the input string. This is because we traverse the string once and perform constant time operations for each character.</p>
<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>The space complexity of the solution is $$O(n)$$, where n is the length of the input string. This is because the worst-case scenario is when all opening brackets are present in the string and the stack will have to store them all.</p>
<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution. Keep Learning
Please give my solution an upvote! 
It's a simple way to show your appreciation and
keep me motivated. Thank you! 
</code></pre>
<h4>Code</h4>
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // create an empty stack
        for (char c : s.toCharArray()) { // loop through each character in the string
            if (c == '(') // if the character is an opening parenthesis
                stack.push(')'); // push the corresponding closing parenthesis onto the stack
            else if (c == '{') // if the character is an opening brace
                stack.push('}'); // push the corresponding closing brace onto the stack
            else if (c == '[') // if the character is an opening bracket
                stack.push(']'); // push the corresponding closing bracket onto the stack
            else if (stack.isEmpty() || stack.pop() != c) // if the character is a closing bracket
                // if the stack is empty (i.e., there is no matching opening bracket) or the top of the stack
                // does not match the closing bracket, the string is not valid, so return false
                return false;
        }
        // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,
        // so the string is valid, otherwise, there are unmatched opening brackets, so return false
        return stack.isEmpty();
    }
}

</code></pre>
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        // Create an empty stack to keep track of opening brackets
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();

        // Loop through every character in the string
        for (char c : s.toCharArray()) {
            // If the character is an opening bracket, push it onto the stack
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else { // If the character is a closing bracket
                // If the stack is empty, there is no matching opening bracket, so return false
                if (stack.isEmpty()) {
                    return false;
                }
                // Otherwise, get the top of the stack and check if it's the matching opening bracket
                char top = stack.peek();
                if ((c == ')' &amp;&amp; top == '(') || (c == ']' &amp;&amp; top == '[') || (c == '}' &amp;&amp; top == '{')) {
                    // If it is, pop the opening bracket from the stack
                    stack.pop();
                } else { // Otherwise, the brackets don't match, so return false
                    return false;
                }
            }
        }
        // If the stack is empty, all opening brackets have been closed, so return true
        // Otherwise, there are unmatched opening brackets, so return false
        return stack.isEmpty();
    }
}

</code></pre>
<pre><code class="language-python">class Solution(object):
    def isValid(self, s):
        stack = [] #### create an empty stack to store opening brackets
        for c in s: #### loop through each character in the string
            if c in '([{': #### if the character is an opening bracket
                stack.append(c) #### push it onto the stack
            else: #### if the character is a closing bracket
                if not stack or \
                    (c == ')' and stack[-1] != '(') or \
                    (c == '}' and stack[-1] != '{') or \
                    (c == ']' and stack[-1] != '['):
                    return False #### the string is not valid, so return false
                stack.pop() #### otherwise, pop the opening bracket from the stack
        return not stack #### if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,
                         #### so the string is valid, otherwise, there are unmatched opening brackets, so return false
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; st; // create an empty stack to store opening brackets
        for (char c : s) { // loop through each character in the string
            if (c == '(' || c == '{' || c == '[') { // if the character is an opening bracket
                st.push(c); // push it onto the stack
            } else { // if the character is a closing bracket
                if (st.empty() || // if the stack is empty or 
                    (c == ')' &amp;&amp; st.top() != '(') || // the closing bracket doesn't match the corresponding opening bracket at the top of the stack
                    (c == '}' &amp;&amp; st.top() != '{') ||
                    (c == ']' &amp;&amp; st.top() != '[')) {
                    return false; // the string is not valid, so return false
                }
                st.pop(); // otherwise, pop the opening bracket from the stack
            }
        }
        return st.empty(); // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,
                           // so the string is valid, otherwise, there are unmatched opening brackets, so return false
    }
};
</code></pre>
<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    let stack = []; // create an empty stack to store opening brackets
    for (let c of s) { // loop through each character in the string
        if (c === '(' || c === '{' || c === '[') { // if the character is an opening bracket
            stack.push(c); // push it onto the stack
        } else { // if the character is a closing bracket
            if (!stack.length || // if the stack is empty or 
                (c === ')' &amp;&amp; stack[stack.length - 1] !== '(') || // the closing bracket doesn't match the corresponding opening bracket at the top of the stack
                (c === '}' &amp;&amp; stack[stack.length - 1] !== '{') ||
                (c === ']' &amp;&amp; stack[stack.length - 1] !== '[')) {
                return false; // the string is not valid, so return false
            }
            stack.pop(); // otherwise, pop the opening bracket from the stack
        }
    }
    return !stack.length; // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,
                          // so the string is valid, otherwise, there are unmatched opening brackets, so return false
};

</code></pre>
<h4>JAVA solution without using stack</h4>
<pre><code class="language-Java">public class Solution {
    public static boolean isValid(String s) {
        while (true) {
            if (s.contains(&quot;()&quot;)) {
                s = s.replace(&quot;()&quot;, &quot;&quot;);
            } else if (s.contains(&quot;{}&quot;)) {
                s = s.replace(&quot;{}&quot;, &quot;&quot;);
            } else if (s.contains(&quot;[]&quot;)) {
                s = s.replace(&quot;[]&quot;, &quot;&quot;);
            } else {
                // If the string becomes empty, it indicates all brackets are matched.
                return s.isEmpty();
            }
        }
    }
}

</code></pre>
<h6>Please Comment</h6>
<p>Thanks for visiting my solution. Comment below if you like it.  </p>
<p><a href="https://www.linkedin.com/in/vikas-pathak-8499451b0"></a> <strong>Connect on LinkedIn</strong><br />
<a href="https://www.instagram.com/vikas123.vp79/"></a> <strong>Follow on Instagram</strong><br />
<a href="https://github.com/Vikas-Pathak-123"></a> <strong>Check out my GitHub</strong></p>
<p>```</p></div>