<div class='cpp-solution'><h4>C++ | 4 Methods | One line solution | Easy-To-Understand | Clean Code [Votes: 58]</h4><p><strong><em>Method-1 : ( 1-Line )</em></strong></p>
<pre><code>int countNodes(TreeNode* root) {
        return root == NULL ? 0 : countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
    }
};
</code></pre>
<p><strong><em>Method - 2 : ( Effecient Approach )</em></strong></p>
<pre><code>class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root)
            return 0;
        int lh = 0, rh = 0;
        TreeNode* l = root, *r = root;
        while(l){
            lh++;
            l = l-&gt;left;
        }
        while(r){
            rh++;
            r = r-&gt;right;
        }
        if(lh == rh)
            return pow(2, lh) - 1;

        return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);
    }
};
</code></pre>
<p><em>Time Complexity : O( logN  logN )</em></p>
<p><strong><em>Method - 3 : ( Using queue )</em></strong></p>
<pre><code>class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == NULL)
        return 0;

        int res = 0;
        queue&lt;TreeNode *&gt; q;
        q.push(root);
        while(!q.empty())
        {

            for(int i = 0; i &lt; q.size(); ++ i)
            {
                 ++ res;
                TreeNode *p = q.front();
                q.pop();

                if(p -&gt; left != NULL)
                    q.push(p -&gt; left);
                if(p -&gt; right != NULL)
                    q.push(p -&gt; right);
            }
        }

        return res;
    }
};
</code></pre>
<p><strong><em>Method - 4 : ( 0(n) approach )</em></strong></p>
<pre><code>class Solution {
public:
    int count = 0;
    void helper(TreeNode* root){

        if(root)
            count++;

        if(root-&gt;left)
        helper(root-&gt;left);
        if(root-&gt;right)
        helper(root-&gt;right);

    }

    int countNodes(TreeNode* root) {
        if(!root)
            return 0;
       helper(root);
        return count;
    }
};
</code></pre>
<p><em>Time Complexity : O(n)</em></p>
<p>Hope you liked it , kindly upvote !!</p>
<p>Happy Coding </p></div><div class='python-solution'><h4>My python solution in O(lgn * lgn) time [Votes: 441]</h4><p>compare the depth between left sub tree and right sub tree.
A, If it is equal, it means the left sub tree is a full binary tree
B, It it is not , it means the right sub tree is a full binary tree </p>
<pre><code> class Solution:
        #### @param {TreeNode} root
        #### @return {integer}
        def countNodes(self, root):
            if not root:
                return 0
            leftDepth = self.getDepth(root.left)
            rightDepth = self.getDepth(root.right)
            if leftDepth == rightDepth:
                return pow(2, leftDepth) + self.countNodes(root.right)
            else:
                return pow(2, rightDepth) + self.countNodes(root.left)

        def getDepth(self, root):
            if not root:
                return 0
            return 1 + self.getDepth(root.left)
</code></pre></div>