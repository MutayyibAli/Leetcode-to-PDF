<div class='cpp-solution'><h4>C++ bitwise xor solution, 1 line [Votes: 195]</h4><p><strong>Step 1</strong>: <code>a | b</code> is what we have while <code>c</code> is what we want. An XOR operation finds all different bits, i.e. <code>(a | b) ^ c</code> sets the bits where flip(s) is needed. Then we count the set bits.
<strong>Step 2</strong>: There is only one case when two flips are needed: a bit is <code>0</code> in <code>c</code> but is <code>1</code> in both <code>a</code> and <code>b</code>. An AND operation finds all common <code>1</code> bits, i.e. <code>a &amp; b &amp; ((a | b) ^ c)</code> sets the common <code>1</code> bits in <code>a</code>, <code>b</code> and the must-flip bits found in Step 1.</p>
<pre><code class="language-cpp">int minFlips(int a, int b, int c) {
    return popcount&lt;uint&gt;((a | b) ^ c) + popcount&lt;uint&gt;(a &amp; b &amp; ((a | b) ^ c));
}
</code></pre>
<p>or simplify with an assignment:</p>
<pre><code class="language-cpp">int minFlips(int a, int b, int c) {
    return popcount&lt;uint&gt;(c ^= a | b) + popcount&lt;uint&gt;(a &amp; b &amp; c);
}
</code></pre>
<p>Note: The <code>popcount</code> function is a cpp 20 standard builtin function that counts set bits. LeetCode uses g++ compiler with the cpp17 standard so we can use <code>__builtin_popcount</code> instead. For other compilers please use <code>bitset&lt;32&gt;().count()</code>.</p>
<p>Update (02/03/2024): LeetCode now uses clang compiler 17 with cpp20 standard support, but it does not automatically convert signed argument types into unsigned ones. So we have to explicitly specify the type <code>&lt;uint&gt;</code>. Also, now that we have to perform the conversion, we can actually use <code>ulong</code> instead and combine two <code>popcount</code> calls into one, which makes the code even shorter:</p>
<pre><code class="language-cpp">int minFlips(int a, int b, int c) {
    return popcount((ulong)(c ^= a | b) &lt;&lt; 32 | a &amp; b &amp; c);
}
</code></pre>
<p>An even shorter way for conversion:</p>
<pre><code class="language-cpp">int minFlips(int a, int b, int c) {
    return popcount(0ul + (c ^= a | b) &lt;&lt; 32 | a &amp; b &amp; c);
}
</code></pre></div><div class='python-solution'><h4>[Java/Python 3] Bit manipulation w/ explanation and analysis. [Votes: 68]</h4><p><strong>Method 1:</strong></p>
<p><strong>Credit to @codedayday:</strong> for contribution to remove redundant part of the code.</p>
<p>-
<strong>Q &amp; A</strong>
Q1: What is the <code>mask</code>? is it <code>00...01</code> at the beginning, and move bit <code>1</code> to the left when <code>i</code> is increasing?
A1: Exactly. <code>mask</code> changes as the following during iteration:</p>
<pre><code>00...01 -&gt; 00...010 -&gt; 00...0100 -&gt; 00...01000 -&gt; ...
</code></pre>
<p>Q2: Is the <code>31</code> here because in cpp int is 32-bit long and there's a sign bit?
A2: Because the question said that <code>a,b,c</code> are positive numbers. -- <strong>Credit to @KHVic</strong></p>
<p>-
1. if <code>(a | b) ^ c</code> is <code>0</code>, <code>a | b</code> and <code>c</code> are equal, otherwise not equal and we need to check them bit by bit;
2. For <code>ith</code> bit of <code>(a | b) ^ c</code>, use <code>1 &lt;&lt; i</code> as mask to do <code>&amp;</code> operation to check if the bit is <code>0</code>; if not, <code>ith</code> bits of <code>a | b</code> and <code>c</code> are not same and we need at least <code>1</code> flip; there are 3 cases:
    i) the <code>ith</code> bit of <code>a | b</code>  less than that of <code>c</code>; then <code>ith</code> bit of <code>a | b</code> must be <code>0</code>, we only need to flip the <code>ith</code> bit of either <code>a</code> or <code>b</code>;
    ii) the <code>ith</code> bit of <code>a | b</code>  bigger than that of <code>c</code>; then <code>ith</code> bit of <code>a | b</code> must be <code>1</code>, but if only one of <code>a</code> or <code>b</code>'s <code>ith</code> bit is <code>1</code>, we only need to flip one of them;
    iii) Other case, we need to flip both set bit of <code>a</code> and <code>b</code>, hence need <code>2</code> flips.
    In short, <strong>if <code>ith</code> bits of <code>a | b</code> and <code>c</code> are not same, then only if  <code>ith</code> bits of <code>a</code> and <code>b</code> are both <code>1</code> and  that of <code>c</code> is <code>0</code>, we need <code>2</code> flips; otherwise only <code>1</code> flip needed.</strong></p>
<pre><code class="language-java">    public int minFlips(int a, int b, int c) {
        int ans = 0, ab = a | b, equal = ab ^ c;
        for (int i = 0; i &lt; 31; ++i) {
            int mask = 1 &lt;&lt; i;
            if ((equal &amp; mask) &gt; 0)  // ith bits of a | b and c are not same, need at least 1 flip.
             // ans += (ab &amp; mask) &lt; (c &amp; mask) || (a &amp; mask) != (b &amp; mask) ? 1 : 2;
                ans += (a &amp; mask) == (b &amp; mask) &amp;&amp; (c &amp; mask) == 0 ? 2 : 1; // ith bits of a and b are both 1 and that of c is 0?
        }
        return ans;
    }
</code></pre>
<pre><code class="language-python">    def minFlips(self, a: int, b: int, c: int) -&gt; int:
        ab, equal, ans = a | b, (a | b) ^ c, 0
        for i in range(31):
            mask = 1 &lt;&lt; i
            if equal &amp; mask &gt; 0:
              #### ans += 1 if (ab &amp; mask) &lt; (c &amp; mask) or (a &amp; mask) != (b &amp; mask) else 2
                ans += 2 if (a &amp; mask) == (b &amp; mask) and (c &amp; mask) == 0 else 1
        return ans
</code></pre>
<p>-
<strong>Method 2:</strong></p>
<p>The following idea and simple codes are from <strong>@mzchen</strong>:</p>
<p><strong>Step 1</strong>: <code>a | b</code> is what we have while <code>c</code> is what we want. An XOR operation finds all different bits, i.e. <code>(a | b) ^ c</code> sets the bits where flip(s) is needed. Then we count the set bits.
<strong>Step 2</strong>: There is only one case when two flips are needed: a bit is <code>0</code> in <code>c</code> but is <code>1</code> in both <code>a</code> and <code>b</code>. An AND operation finds all common <code>1</code> bits, i.e. <code>a &amp; b &amp; ((a | b) ^ c)</code> sets the common <code>1</code> bits in <code>a</code>, <code>b</code> and the must-flip bits found in Step 1.</p>
<pre><code class="language-java">    public int minFlips(int a, int b, int c) {
        return Integer.bitCount(c ^= (a | b)) + Integer.bitCount(a &amp; b &amp; c);
    }
</code></pre>
<pre><code class="language-python">    def minFlips(self, a: int, b: int, c: int) -&gt; int:
        return (c := (a | b) ^ c).bit_count() + (a &amp; b &amp; c).bit_count()
</code></pre>
<p><strong>Analysis:</strong>
Time: O(L), space: O(1), where L is the number of bits in an integer.</p></div>