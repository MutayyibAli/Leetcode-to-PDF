<div class='cpp-solution'><h4>âœ…3 Method's ðŸ¤¯ || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥ [Votes: 2102]</h4><h4>Intuition:</h4>
<p>The Intuition is to determine if two strings are anagrams, compare the characters in both strings and check if they have the same characters but in a different order. By tracking the count of each character, if the counts match for all characters, the strings are anagrams; otherwise, they are not.</p>
<h4>Approach 1: Sorting</h4>
<h4>Explanation:</h4>
<ol>
<li><code>sort(s.begin(), s.end());</code> sorts the characters in string <code>s</code> in ascending order. This rearranges the characters in <code>s</code> so that they are in alphabetical order.</li>
<li><code>sort(t.begin(), t.end());</code> sorts the characters in string <code>t</code> in ascending order. Similarly, this rearranges the characters in <code>t</code> to be in alphabetical order.</li>
<li><code>return s == t;</code> compares the sorted strings <code>s</code> and <code>t</code> using the equality operator (<code>==</code>). If the sorted strings are equal, it means that the original strings <code>s</code> and <code>t</code> have the same characters in the same order, indicating that they are anagrams. In this case, the function returns <code>true</code>. Otherwise, if the sorted strings are not equal, the function returns <code>false</code>, indicating that the strings are not anagrams.</li>
</ol>
<p>This code takes advantage of the fact that anagrams have the same characters, but in different orders. By sorting the characters, the code transforms the problem into a comparison of the sorted strings, simplifying the anagram check.</p>
<p>However, it's worth noting that this approach has a time complexity of O(n log n) due to the sorting operation, where n is the length of the strings.</p>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
</code></pre>
<pre><code class="language-Java">import java.util.Arrays;

class Solution {
    public boolean isAnagram(String s, String t) {
        char[] sChars = s.toCharArray();
        char[] tChars = t.toCharArray();

        Arrays.sort(sChars);
        Arrays.sort(tChars);

        return Arrays.equals(sChars, tChars);
    }
}
</code></pre>
<pre><code class="language-Python3">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        sorted_s = sorted(s)
        sorted_t = sorted(t)
        return sorted_s == sorted_t
</code></pre>
<h4>Approach 2: Hash Table</h4>
<h4>Explanation:</h4>
<ol>
<li>Create an unordered map <code>count</code> to store the character frequencies. The key of the map represents a character, and the value represents its frequency.</li>
<li>Iterate over each character <code>x</code> in string <code>s</code>. For each character, increment its frequency in the <code>count</code> map by using the <code>count[x]++</code> expression.</li>
<li>Iterate over each character <code>x</code> in string <code>t</code>. For each character, decrement its frequency in the <code>count</code> map by using the <code>count[x]--</code> expression.</li>
<li>Iterate over each pair <code>x</code> in the <code>count</code> map. Each pair consists of a character and its corresponding frequency. Check if any frequency (<code>x.second</code>) is non-zero. If any frequency is non-zero, it means there is a character that appears more times in one string than the other, indicating that the strings are not anagrams. In that case, return <code>false</code>.</li>
<li>If all frequencies in the <code>count</code> map are zero, it means the strings <code>s</code> and <code>t</code> have the same characters in the same frequencies, making them anagrams. In this case, the function returns <code>true</code>.</li>
</ol>
<p>This approach counts the frequency of characters in one string and then adjusts the count by decrementing for the other string. If the strings are anagrams, the frequency of each character will cancel out, resulting in a map with all zero frequencies.</p>
<p>The time complexity of this solution is O(n), where n is the total number of characters in both strings. It iterates over each character once to count the frequencies and then compares the frequencies in the map, making it an efficient solution for the problem.</p>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map&lt;char, int&gt; count;

        // Count the frequency of characters in string s
        for (auto x : s) {
            count[x]++;
        }

        // Decrement the frequency of characters in string t
        for (auto x : t) {
            count[x]--;
        }

        // Check if any character has non-zero frequency
        for (auto x : count) {
            if (x.second != 0) {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public boolean isAnagram(String s, String t) {
        Map&lt;Character, Integer&gt; count = new HashMap&lt;&gt;();

        // Count the frequency of characters in string s
        for (char x : s.toCharArray()) {
            count.put(x, count.getOrDefault(x, 0) + 1);
        }

        // Decrement the frequency of characters in string t
        for (char x : t.toCharArray()) {
            count.put(x, count.getOrDefault(x, 0) - 1);
        }

        // Check if any character has non-zero frequency
        for (int val : count.values()) {
            if (val != 0) {
                return false;
            }
        }

        return true;
    }
}
</code></pre>
<pre><code class="language-Python3">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        count = defaultdict(int)

        #### Count the frequency of characters in string s
        for x in s:
            count[x] += 1

        #### Decrement the frequency of characters in string t
        for x in t:
            count[x] -= 1

        #### Check if any character has non-zero frequency
        for val in count.values():
            if val != 0:
                return False

        return True
</code></pre>
<h4>Approach 3: Hash Table (Using Array)</h4>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    bool isAnagram(string s, string t) {
        int count[26] = {0};

        // Count the frequency of characters in string s
        for (char x : s) {
            count[x - 'a']++;
        }

        // Decrement the frequency of characters in string t
        for (char x : t) {
            count[x - 'a']--;
        }

        // Check if any character has non-zero frequency
        for (int val : count) {
            if (val != 0) {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count = new int[26];

        // Count the frequency of characters in string s
        for (char x : s.toCharArray()) {
            count[x - 'a']++;
        }

        // Decrement the frequency of characters in string t
        for (char x : t.toCharArray()) {
            count[x - 'a']--;
        }

        // Check if any character has non-zero frequency
        for (int val : count) {
            if (val != 0) {
                return false;
            }
        }

        return true;
    }
}
</code></pre>
<pre><code class="language-Python3">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        count = [0] * 26

        #### Count the frequency of characters in string s
        for x in s:
            count[ord(x) - ord('a')] += 1

        #### Decrement the frequency of characters in string t
        for x in t:
            count[ord(x) - ord('a')] -= 1

        #### Check if any character has non-zero frequency
        for val in count:
            if val != 0:
                return False

        return True
</code></pre>
<p><strong>If you are a beginner solve these problems which makes concepts clear for future coding:</strong>
1. <a href="https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/">Two Sum</a>
2. <a href="https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/">Roman to Integer</a>
3. <a href="https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/">Palindrome Number</a>
4. <a href="https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/">Maximum Subarray</a>
5. <a href="https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/">Remove Element</a>
6. <a href="https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/">Contains Duplicate</a>
7. <a href="https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/">Add Two Numbers</a>
8. <a href="https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/">Majority Element</a>
9. <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/">Remove Duplicates from Sorted Array</a>
10. <a href="https://leetcode.com/problems/valid-anagram/solutions/3687854/3-methods-c-java-python-beginner-friendly/">Valid Anagram</a>
11. <a href="https://leetcode.com/problems/group-anagrams/solutions/3687735/beats-100-c-java-python-beginner-friendly/">Group Anagrams</a>
12. <strong>Practice them in a row for better understanding and please Upvote for more questions.</strong></p>
<p><strong>If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.</strong></p></div>