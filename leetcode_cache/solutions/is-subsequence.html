<div class='cpp-solution'><h4>【Video】Two Pointer Solution [Votes: 401]</h4><h4>Intuition</h4>
<p>Check both strings one by one.</p>
<h4>Solution Video</h4>
<p>In the video, the steps of approach below are visualized using diagrams and drawings. I'm sure you understand the solution easily!</p>
<p>https://youtu.be/2FYJxatZnxE</p>
<p>■ Timeline
<code>0:00</code> Read the question of Is Subsequence
<code>1:26</code> Explain a basic idea to solve Is Subsequence
<code>4:04</code> Coding
<code>5:28</code> Time Complexity &amp; Space Complexity </p>
<h6>⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️</h6>
<p><strong>■ Subscribe URL</strong>
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>Subscribers: 4,177
Thank you for your support!</p>
<h4>Approach</h4>
<p><strong>How I think about a solution:</strong></p>
<p>Simply, all we have to do is just to count characters for each string <code>s</code> and <code>t</code> and check if <code>t</code> has all characters of <code>s</code>, but problem is there is an order to find the characters.</p>
<pre><code>Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;
</code></pre>
<p>In this case, we need to find <code>a</code> in <code>t</code> at first. The next character we must find is <code>b</code> at the position after <code>a</code>, the last character is <code>c</code> at the position after <code>b</code>. That is kind of a challenging part of this question. It might be tough to use simple <code>HashMap</code> or <code>Set</code> because they don't have order of data.</p>
<p>That's why I just started thinking it with a very simple example like this.</p>
<pre><code>Input: s = &quot;abc&quot;, t = &quot;abc&quot;
</code></pre>
<p>In this case, if we check each character one by one in the both strings from beginning, we can return <code>true</code> and this simple example gave me a hint to solve this question.</p>
<p>I realized that if I have the same index number as length of <code>s</code> after I iterate though all characters, I can prove that I have subsequence in <code>t</code>. </p>
<p>To prove that, I also check a simple <code>false</code> case like this.</p>
<pre><code>Input: s = &quot;abc&quot;, t = &quot;abd&quot;
</code></pre>
<p>In this case, when I iterate thorugh both strings from beginning, I stopped at index <code>2</code> in <code>s</code> which means I didn't find the last character <code>c</code> in <code>t</code>, so this is a <code>false</code> case because <code>index number for s(2)</code> is not equal to <code>length of s(3)</code>. I couldn't get to <code>the last position of s</code>. </p>
<p><code>The last position</code> means <code>the last index number + 1</code> because index usually starts from <code>0</code> and counting length of string starts from <code>1</code>.</p>
<p>From my thought process above, I tried to iterate thorough both strings from beginning at the same time. </p>
<p>Let's recap what I said with this example.</p>
<pre><code>Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;
</code></pre>
<pre><code>target: a
s index: 0
t index: 0
</code></pre>
<p>The first target is <code>a</code>. Luckily, the first character of <code>t</code> is also <code>a</code>. </p>
<pre><code>found: a
Now I can think inputs like this Input: s = &quot;bc&quot;, t = &quot;hbgdc&quot;

after the above,

s index: 1
t index: 1
</code></pre>
<p>Then, the next target is <code>b</code> but the next character of <code>t</code> is <code>h</code>, so now </p>
<pre><code>target: b

found: a
Now I can think inputs like this Input: s = &quot;bc&quot;, t = &quot;bgdc&quot;

after the above,

s index: 1
t index: 2

</code></pre>
<p>The next character of <code>t</code> is <code>b</code>, I found <code>b</code> in <code>t</code>.</p>
<pre><code>target: b

found: ab
Now I can think inputs like this Input: s = &quot;c&quot;, t = &quot;gdc&quot;

after the above,

s index: 2
t index: 3
</code></pre>
<p>The next and next next character in <code>t</code> are <code>g</code> and <code>d</code>, so just increment <code>t index</code> from <code>3</code> to <code>5</code>.</p>
<p>Finally, I reached the last character in <code>t</code> and found <code>c</code></p>
<pre><code>target: c

found abc
Now I can think inputs like this Input: s = &quot;&quot;, t = &quot;&quot;

after the above,

s index: 3
t index: 6
</code></pre>
<p>After the process, all I have to do is just to check if <code>s index(3)</code> is equal to <code>length of s(3)</code>.</p>
<pre><code>Output: true
</code></pre>
<p>That's how I think about my solution. Let's see a real algorithm below.</p>
<p><strong>Algorithm Overview:</strong></p>
<ol>
<li>Initialize two pointers, <code>sp</code> and <code>tp</code>, to 0 to represent the starting positions of the strings <code>s</code> and <code>t</code> respectively.</li>
<li>Iterate through the characters of both strings <code>s</code> and <code>t</code>, comparing characters at the corresponding positions.</li>
<li>If a matching character is found, move the pointer in <code>s</code> forward.</li>
<li>Always move the pointer in <code>t</code> forward.</li>
<li>Check if all characters in <code>s</code> have been matched in <code>t</code>.</li>
<li>Return <code>True</code> if <code>s</code> is a subsequence of <code>t</code>, <code>False</code> otherwise.</li>
</ol>
<p><strong>Detailed Explanation:</strong></p>
<ol>
<li>
<p>Set <code>sp</code> and <code>tp</code> to 0, indicating the starting positions of <code>s</code> and <code>t</code> respectively.</p>
</li>
<li>
<p>Iterate through the characters of <code>s</code> and <code>t</code> using a while loop until either all characters in <code>s</code> have been matched or we reach the end of <code>t</code>.</p>
</li>
</ol>
<p>a. Check if the characters at <code>sp</code> in <code>s</code> and <code>tp</code> in <code>t</code> are equal.</p>
<p>b. If they are equal, increment <code>sp</code> to move to the next character in <code>s</code>.</p>
<p>c. Always increment <code>tp</code> to move forward in <code>t</code>.</p>
<ol>
<li>After the loop, check if all characters in <code>s</code> have been matched. If <code>sp</code> is equal to the length of <code>s</code>, then <code>s</code> is a subsequence of <code>t</code>.</li>
</ol>
<p>a. Return <code>True</code> if <code>s</code> is a subsequence of <code>t</code>.</p>
<p>b. Return <code>False</code> if <code>s</code> is not a subsequence of <code>t</code>.</p>
<p>https://youtu.be/Abdq3lNRocc</p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity: O(n)
<code>n</code> is longer length of input string (<code>s</code> or <code>t</code>).</p>
</li>
<li>
<p>Space complexity: O(1)</p>
</li>
</ul>
<pre><code class="language-python">class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        sp = tp = 0

        while sp &lt; len(s) and tp &lt; len(t):
            if s[sp] == t[tp]:
                sp += 1
            tp += 1

        return sp == len(s)
</code></pre>
<pre><code class="language-javascript">/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    let sp = 0;
    let tp = 0;

    while (sp &lt; s.length &amp;&amp; tp &lt; t.length) {
        if (s[sp] === t[tp]) {
            sp++;
        }
        tp++;
    }

    return sp === s.length;    
};
</code></pre>
<pre><code class="language-java">class Solution {
    public boolean isSubsequence(String s, String t) {
        int sp = 0;
        int tp = 0;

        while (sp &lt; s.length() &amp;&amp; tp &lt; t.length()) {
            if (s.charAt(sp) == t.charAt(tp)) {
                sp++;
            }
            tp++;
        }

        return sp == s.length();        
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    bool isSubsequence(string s, string t) {
        int sp = 0;
        int tp = 0;

        while (sp &lt; s.length() &amp;&amp; tp &lt; t.length()) {
            if (s[sp] == t[tp]) {
                sp++;
            }
            tp++;
        }

        return sp == s.length();        
    }
};
</code></pre>
<p>Thank you for reading my post. Please upvote it and don't forget to subscribe to my channel!</p>
<h5>⭐️ Subscribe URL</h5>
<p>http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<h5>⭐️ Twitter</h5>
<p>https://twitter.com/CodingNinjaAZ</p>
<h5>⭐️ My previous post - #55. Jump Game</h5>
<p>post
https://leetcode.com/problems/jump-game/solutions/4920717/video-move-goal-position/</p>
<p>video
https://youtu.be/m6AymRRYgko</p></div><div class='python-solution'><h4>[Python , Javascript]  Easy solution with very clear Explanation [Votes: 662]</h4><p><strong>Please dont downvote guys if cannot support,We are putting lot of effort in it</strong></p>
<pre><code>Question asking us to return true if s is a subsequence of t, or false otherwise.

Example:
    s='code'
    t='leetcode'
    here s is subsequence of t ,we can get code from leetcode.


What is subsequence and subString?
    Subsequence: a sequence that appears in the same relative order, but not necessarily contiguous.
    SubString: a contiguous sequence of symbols that appears in the same relative order as the original string.


  Big O:
    Time: O(n) #### n is the length of t
    Space: O(1)
</code></pre>
<p><code>JavaScript</code></p>
<pre><code>const isSubsequence = (s, t) =&gt; {
  //! Edge case
  if (s.length &gt; t.length) return false; //! if len of s is greater than len of t, return false because s cant be a subsequence of t
  `
  Example:
    s='Leetcode'
    t='Code'
    here we are trying to find if 'Leetcode' is a subsequence of 'Code' which is not possible because 'Leetcode' is longer than 'Code'

  `;
  const t_length = t.length;
  let subsequence = 0;
  for (let i = 0; i &lt; t_length; i++) {
    if (s[subsequence] === t[i]) {
      // ! if it is matching, increment subsequence
      subsequence++;
    }
  }
  return subsequence === s.length
};
</code></pre>
<p><code>Python</code></p>
<pre><code>class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        if len(s) &gt; len(t):return False
        if len(s) == 0:return True
        subsequence=0
        for i in range(0,len(t)):
            if subsequence &lt;= len(s) -1:
                print(s[subsequence])
                if s[subsequence]==t[i]:

                    subsequence+=1
        return  subsequence == len(s) 
</code></pre>
<p><code>UPVOTE if you like  , If you have any question, feel free to ask.</code></p></div>