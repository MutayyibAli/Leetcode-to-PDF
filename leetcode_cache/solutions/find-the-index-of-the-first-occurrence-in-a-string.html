<div class='cpp-solution'><h4>C++ Brute-Force and KMP [Votes: 483]</h4><p>Traverse all the possible starting points of <code>haystack</code> (from <code>0</code> to <code>haystack.length() - needle.length()</code>) and see if the following characters in <code>haystack</code> match those of <code>needle</code>.</p>
<pre><code class="language-cpp">class Solution {
public:
    int strStr(string haystack, string needle) {
        int m = haystack.size(), n = needle.size();
        for (int i = 0; i &lt;= m - n; i++) {
            int j = 0;
            for (; j &lt; n; j++) {
                if (haystack[i + j] != needle[j]) {
                    break;
                }
            }
            if (j == n) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>
<p>The following is another implementation, shorter but harder to understand.</p>
<pre><code class="language-cpp">class Solution {
public:
    int strStr(string haystack, string needle) {
        int m = haystack.size(), n = needle.size(), p = 0;
        while (p + n - 1 &lt; m) {
            if (haystack.substr(p, n) == needle) {
                return p;
            }
            while (p++ + n - 1 &lt; m &amp;&amp; haystack[p] != needle[0]);
        }
        return -1;
    }
};
</code></pre>
<p>Finally comes the KMP algorithm. You may refer to <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/">KMP on jBoxer's blog</a> and <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/">KMP on geeksforgeeks</a> for some explanations. I rewrote the code from the second link.</p>
<pre><code class="language-cpp">class Solution {
public:
    int strStr(string haystack, string needle) {
        int m = haystack.size(), n = needle.size();
        if (!n) {
            return 0;
        }
        vector&lt;int&gt; lps = kmpProcess(needle);
        for (int i = 0, j = 0; i &lt; m;) {
            if (haystack[i] == needle[j]) { 
                i++, j++;
            }
            if (j == n) {
                return i - j;
            }
            if (i &lt; m &amp;&amp; haystack[i] != needle[j]) {
                j ? j = lps[j - 1] : i++;
            }
        }
        return -1;
    }
private:
    vector&lt;int&gt; kmpProcess(string needle) {
        int n = needle.size();
        vector&lt;int&gt; lps(n, 0);
        for (int i = 1, len = 0; i &lt; n;) {
            if (needle[i] == needle[len]) {
                lps[i++] = ++len;
            } else if (len) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        return lps;
    }
};
</code></pre></div><div class='python-solution'><h4>【Video】Slicing approach [Votes: 435]</h4><h4>Intuition</h4>
<p>Slice a string of haystack.</p>
<h4>Solution Video</h4>
<p>https://youtu.be/lnTAVa8A7XI</p>
<h6>⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️</h6>
<p><strong>■ Subscribe URL</strong>
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>Subscribers: 5,241
Thank you for your support!</p>
<h4>Approach</h4>
<p>Problem here is that we don't know where to start. That's why we iterate through all characters one by one.</p>
<pre><code>haystack = &quot;abcxyz&quot;, needle = &quot;xyz&quot;
</code></pre>
<p>We start from index <code>0</code>.</p>
<pre><code>&quot;abcxyz&quot;
 i
</code></pre>
<p>My strategy is to check a part of string. Formula for the part is</p>
<p>⭐️ Points</p>
<pre><code>sliced string = haystack[i: i+ length of needle] 
</code></pre>
<p>Why?</p>
<p>That's because we need to find a part of string which is length <code>3</code>, since length of needle is <code>3</code>.</p>
<p>One more important thing is that in Python ending number is not included. If current index is <code>0</code>, slicing range should be from index <code>0</code> to index  <code>2</code> in this case.</p>
<p>Let's see how it works!</p>
<pre><code> 012345 → index
&quot;abcxyz&quot;
 i

slicing string: haystack[0:3] → &quot;abc&quot;

if &quot;abc&quot; == &quot;xyz&quot; → False, move next
</code></pre>
<pre><code> 012345 → index
&quot;abcxyz&quot;
  i

slicing string: haystack[1:4] → &quot;bcx&quot;

if &quot;bcx&quot; == &quot;xyz&quot; → False, move next
</code></pre>
<pre><code> 012345 → index
&quot;abcxyz&quot;
   i

slicing string: haystack[2:5] → &quot;cxy&quot;

if &quot;cxy&quot; == &quot;xyz&quot; → False, move next
</code></pre>
<pre><code> 012345 → index
&quot;abcxyz&quot;
    i

slicing string: haystack[3:6] → &quot;xyz&quot;

if &quot;xyz&quot; == &quot;xyz&quot; → True
</code></pre>
<pre><code>return 3
</code></pre>
<p>Easy!
Let's see solution codes and step by step algorithm!</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $$O(n * m)$$</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: $$O(1)$$</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<pre><code class="language-python">class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:

        if len(haystack) &lt; len(needle):
            return -1

        for i in range(len(haystack)):
            if haystack[i:i+len(needle)] == needle:
                return i

        return -1 
</code></pre>
<pre><code class="language-javascript">var strStr = function(haystack, needle) {
    if (haystack.length &lt; needle.length) {
        return -1;
    }

    for (let i = 0; i &lt;= haystack.length - needle.length; i++) {
        if (haystack.substring(i, i + needle.length) === needle) {
            return i;
        }
    }

    return -1;    
};
</code></pre>
<pre><code class="language-java">class Solution {
    public int strStr(String haystack, String needle) {
        if (haystack.length() &lt; needle.length()) {
            return -1;
        }

        for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) {
            if (haystack.substring(i, i + needle.length()).equals(needle)) {
                return i;
            }
        }

        return -1;        
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int strStr(string haystack, string needle) {
        if (haystack.length() &lt; needle.length()) {
            return -1;
        }

        for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) {
            if (haystack.substr(i, needle.length()) == needle) {
                return i;
            }
        }

        return -1;        
    }
};
</code></pre>
<h4>Step by Step Algorithm</h4>
<ol>
<li>
<p><strong>Check Lengths</strong>:</p>
<ul>
<li>Before proceeding with the search, the function checks if the length of <code>haystack</code> is less than the length of <code>needle</code>.</li>
<li>If <code>haystack</code> is shorter, it's impossible for <code>needle</code> to be found within <code>haystack</code>, so the function returns <code>-1</code> immediately.</li>
</ul>
<p><code>python
if len(haystack) &lt; len(needle):
    return -1</code></p>
</li>
<li>
<p><strong>Loop Through <code>haystack</code></strong>:</p>
<ul>
<li>The function uses a <code>for</code> loop to iterate through <code>haystack</code>.</li>
<li>The loop runs from the beginning of <code>haystack</code> to the point where the remaining substring is at least as long as <code>needle</code>.</li>
<li>This is achieved by setting the loop condition to <code>range(len(haystack) - len(needle) + 1)</code>, ensuring that we do not run out of characters to compare.</li>
</ul>
<p><code>python
for i in range(len(haystack) - len(needle) + 1):</code></p>
</li>
<li>
<p><strong>Compare Substrings</strong>:</p>
<ul>
<li>Inside the loop, a substring of <code>haystack</code> starting at the current index <code>i</code> and of length equal to <code>needle</code> is extracted and compared to <code>needle</code>.</li>
<li>If they match, the function returns the current index <code>i</code>, which is the starting position of the first occurrence of <code>needle</code> in <code>haystack</code>.</li>
</ul>
<p><code>python
if haystack[i:i+len(needle)] == needle:
    return i</code></p>
</li>
<li>
<p><strong>Return -1 if Not Found</strong>:</p>
<ul>
<li>If the loop completes without finding a match, the function returns <code>-1</code>.</li>
<li>This indicates that <code>needle</code> was not found in <code>haystack</code>.</li>
</ul>
<p><code>python
return -1</code></p>
</li>
</ol>
<p>Thank you for reading my post.</p>
<h6>⭐️ Subscribe URL</h6>
<p>http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<h6>⭐️ Twitter</h6>
<p>https://twitter.com/CodingNinjaAZ</p>
<h6>⭐️ My previous video</h6>
<p>Remove Duplicates from Sorted List #83</p>
<p>https://youtu.be/uyd5vc0TZmA</p></div>