<div class='cpp-solution'><h4>C++ || Binary Search || Easiest Beginner Friendly Sol [Votes: 52]</h4><h4>Intuition of this Problem:</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p><strong>NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.</strong></p>
<h4>Approach for this Problem:</h4>
<ol>
<li>Initialize first to 1 and last to n.</li>
<li>While first is less than or equal to last, do the following:
    a. Compute mid as first + (last - first) / 2.
    b. If guess(mid) returns 0, return mid.
    c. If guess(mid) returns -1, update last to mid - 1.
    d. If guess(mid) returns 1, update first to mid + 1.</li>
<li>Return -1.</li>
</ol>
<!-- Describe your approach to solving the problem. -->

<h4>Humble Request:</h4>
<ul>
<li>If my solution is helpful to you then please <strong>UPVOTE</strong> my solution, your <strong>UPVOTE</strong> motivates me to post such kind of solution.</li>
<li>Please let me know in comments if there is need to do any improvement in my approach, code....anything.</li>
<li><strong>Let's connect on</strong> https://www.linkedin.com/in/abhinash-singh-1b851b188</li>
</ul>
<h4>Code:</h4>
<pre><code class="language-cpp">/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return       -1 if num is higher than the picked number
 *                1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

class Solution {
public:
    int guessNumber(int n) {
        int first = 1, last = n;
        while (first &lt;= last) {
            int mid = first + (last - first) / 2;
            if (guess(mid) == 0)
                return mid;
            else if (guess(mid) == -1)
                last = mid - 1;
            else
                first = mid + 1;
        }
        return -1;
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int first = 1, last = n;
        while (first &lt;= last) {
            int mid = first + (last - first) / 2;
            int res = guess(mid);
            if (res == 0) {
                return mid;
            } else if (res == -1) {
                last = mid - 1;
            } else {
                first = mid + 1;
            }
        }
        return -1;
    }
}

</code></pre>
<pre><code class="language-Python">class Solution(GuessGame):
    def guessNumber(self, n: int) -&gt; int:
        first, last = 1, n
        while first &lt;= last:
            mid = first + (last - first) // 2
            res = self.guess(mid)
            if res == 0:
                return mid
            elif res == -1:
                last = mid - 1
            else:
                first = mid + 1
        return -1

</code></pre>
<h4>Time Complexity and Space Complexity:</h4>
<ul>
<li>Time complexity: <strong>O(logn)</strong></li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: <strong>O(1)</strong></li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ --></div><div class='python-solution'><h4>Python: Beats 99% solutions O(log(n)) (w/ comments and using Walrus Operator) [Votes: 54]</h4><pre><code>def guessNumber(self, n: int) -&gt; int:
    lowerBound, upperBound = 1, n
    #### Binary division faster than (lowerBound + upperBound) //2
    myGuess = (lowerBound+upperBound) &gt;&gt; 1
    #### walrus operator ':=' - assigns value of the function to the variable 'res'
    #### and then compare res with 0
    while (res := guess(myGuess)) != 0:
        if res == 1:
            lowerBound = myGuess+1
        else:
            upperBound = myGuess-1
        myGuess = (lowerBound+upperBound) &gt;&gt; 1

    return myGuess
</code></pre></div>