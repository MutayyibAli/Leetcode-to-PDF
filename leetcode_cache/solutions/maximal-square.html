<div class='cpp-solution'><h4>C++ space-optimized DP [Votes: 853]</h4><p>To appy DP, we define the state as the maximal <strong>size</strong> (square = size * size) of the square that can be formed till point <code>(i, j)</code>, denoted as <code>dp[i][j]</code>.</p>
<p>For the topmost row (<code>i = 0</code>) and the leftmost column (<code>j = 0</code>), we have <code>dp[i][j] = matrix[i][j] - '0'</code>, meaning that it can at most form a square of size 1 when the matrix has a <code>'1'</code> in that cell.</p>
<p>When <code>i &gt; 0</code> and <code>j &gt; 0</code>, if <code>matrix[i][j] = '0'</code>, then <code>dp[i][j] = 0</code> since no square will be able to contain the <code>'0'</code> at that cell. If <code>matrix[i][j] = '1'</code>, we will have <code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code>, which means that the square will be limited by its left, upper and upper-left neighbors.</p>
<pre><code class="language-cpp">class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0;
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (!i || !j || matrix[i][j] == '0') {
                    dp[i][j] = matrix[i][j] - '0';
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
                sz = max(dp[i][j], sz);
            }
        }
        return sz * sz;
    }
};
</code></pre>
<p>In the above code, it uses <code>O(mn)</code> space. Actually each time when we update <code>dp[i][j]</code>, we only need <code>dp[i-1][j-1]</code>, <code>dp[i-1][j]</code> (the previous row) and <code>dp[i][j-1]</code> (the current row). So we may just keep two rows.</p>
<pre><code class="language-cpp">class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0;
        vector&lt;int&gt; pre(n, 0), cur(n, 0);
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (!i || !j || matrix[i][j] == '0') {
                    cur[j] = matrix[i][j] - '0';
                } else {
                    cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1;
                }
                sz = max(cur[j], sz);
            }
            fill(pre.begin(), pre.end(), 0);
            swap(pre, cur);
        }
        return sz * sz;
    }
};
</code></pre>
<p>Furthermore, we may only use just one <code>vector</code> (thanks to @stellari for sharing the idea).</p>
<pre><code class="language-cpp">class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0, pre;
        vector&lt;int&gt; cur(n, 0);
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                int temp = cur[j];
                if (!i || !j || matrix[i][j] == '0') {
                    cur[j] = matrix[i][j] - '0';
                } else {
                    cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1;
                }
                sz = max(cur[j], sz);
                pre = temp;
            }
        }
        return sz * sz;
    }
};
</code></pre></div><div class='python-solution'><h4>[Python] Thinking Process Diagrams - DP Approach [Votes: 1880]</h4><p><strong>Understanding basics</strong></p>
<ul>
<li>Here I want to mention that we are drawing squares from top left corner to bottom right corner. Therefore, when I mention, "surrounding elements", I am saying cells above the corner cell and the cells on the left of the corner cell.</li>
</ul>
<p><strong>Building DP grid to memoize</strong>
* We are going to create a <code>dp</code> grid with initial values of 0.
* We are going to update <code>dp</code> as described in the following figure. </p>
<p><strong>Bigger Example</strong>
* Let's try to see a bigger example.
* We go over one cell at a time row by row in the <code>matrix</code> and then update our <code>dp</code> grid accordingly. 
* Update <code>max_side</code> with the maximum <code>dp</code> cell value as you update.</p>
<p>In the code, I create a <code>dp</code> grid which has one additional column and one additional row. The reason is to facilitate the index dp[r-1][c] dp[r][c-1] and dp[r-1][c-1] for cells in first row and first column in <code>matrix</code>.</p>
<pre><code class="language-python">class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        if matrix is None or len(matrix) &lt; 1:
            return 0

        rows = len(matrix)
        cols = len(matrix[0])

        dp = [[0]*(cols+1) for _ in range(rows+1)]
        max_side = 0

        for r in range(rows):
            for c in range(cols):
                if matrix[r][c] == '1':
                    dp[r+1][c+1] = min(dp[r][c], dp[r+1][c], dp[r][c+1]) + 1 #### Be careful of the indexing since dp grid has additional row and column
                    max_side = max(max_side, dp[r+1][c+1])

        return max_side * max_side

</code></pre>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity : <code>O(mn)</code>. Single pass - <code>row x col (m=row; n=col)</code>
Space complexity : <code>O(mn)</code>. Additional space for <code>dp</code> grid (don't need to worry about additional 1 row and col).</p>
<p><strong>Follow up</strong>
Space can be optimized as we don't need to keep the whole <code>dp</code> grid as we progress down the rows in <code>matrix</code>.</p>
<p>Aren't Dynamic Programming problems much like this joke? :D</p></div>