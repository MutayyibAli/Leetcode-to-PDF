<div class='cpp-solution'><h4>✅☑️ Best C++ 2 Solution || Floyd's Cycle-Finding Algorithm || Hash Table || One Stop Solution. [Votes: 278]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>We can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).</p>
<ol>
<li>Solved using Math + Hash Table..</li>
<li>Solved using Floyd's Cycle-Finding Algorithm.</li>
</ol>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>We can easily understand the all the approaches by seeing the code which is easy to understand with comments.</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>Time complexity is given in code comment.</p>
<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>Space complexity is given in code comment.</p>
<h4>Code</h4>
<pre><code>/*

    Time Complexity : O(logN) where N is the number.

    Space Complexity : O(logN), Hash Table(unordered_set(set)) space.

    Solved using Math + Hash Table.

*/


/***************************************** Approach 1 *****************************************/

class Solution {
private:
    int nextNumber(int n){
        int newNumber = 0;
        while(n!=0){
            int num = n%10;
            newNumber += num*num;
            n = n/10;
        }
        return newNumber;
    }
public:
    bool isHappy(int n) {
        unordered_set&lt;int&gt; set;
        while(n!=1 &amp;&amp; !set.count(n)){
            set.insert(n);
            n = nextNumber(n);
        }
        return n==1;
    }
};






/*

    Time Complexity : O(logN) where N is the number.

    Space Complexity : O(1), Constant space.

    Solved using Floyd's Cycle-Finding Algorithm.

*/


/***************************************** Approach 2 *****************************************/

class Solution {
private:
    int nextNumber(int n){
        int newNumber = 0;
        while(n!=0){
            int num = n%10;
            newNumber += num*num;
            n = n/10;
        }
        return newNumber;
    }
public:
    bool isHappy(int n) {
        int slowPointer = n;
        int fastPointer = nextNumber(n);
        while(fastPointer != 1 &amp;&amp; fastPointer != slowPointer){
            slowPointer = nextNumber(slowPointer);
            fastPointer = nextNumber(nextNumber(fastPointer));
        }
        return fastPointer==1;
    }
};

</code></pre>
<p><strong><em>IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.</em></strong></p></div><div class='python-solution'><h4>My Python Solution [Votes: 256]</h4><pre><code>def isHappy(self, n):
    mem = set()
    while n != 1:
        n = sum([int(i) ** 2 for i in str(n)])
        if n in mem:
            return False
        else:
            mem.add(n)
    else:
        return True
</code></pre></div>