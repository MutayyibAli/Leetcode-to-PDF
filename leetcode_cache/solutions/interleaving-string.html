<div class='cpp-solution'><h4>✅ 99.78% 2-Approaches DP & Recursion [Votes: 342]</h4><h4>Interview Guide: "Interleaving String" Problem</h4>
<h5>Problem Understanding</h5>
<p>In the "Interleaving String" problem, you are given three strings: <code>s1</code>, <code>s2</code>, and <code>s3</code>. Your task is to determine whether <code>s3</code> can be formed by interleaving <code>s1</code> and <code>s2</code>. For example, if <code>s1 = "aabcc"</code> and <code>s2 = "dbbca"</code>, then <code>s3 = "aadbbcbcac"</code> should return <code>true</code>, but <code>s3 = "aadbbbaccc"</code> should return <code>false</code>.</p>
<h5>Key Points to Consider</h5>
<h6>1. Understand the Constraints</h6>
<p>Before diving into the solution, make sure you understand the problem's constraints. The lengths of the strings will not be more than 100 for <code>s1</code> and <code>s2</code>, and not more than 200 for <code>s3</code>. This can help you gauge the time complexity you should aim for.</p>
<h6>2. Multiple Approaches</h6>
<p>There are multiple ways to solve this problem, including:</p>
<ul>
<li>2D Dynamic Programming</li>
<li>1D Dynamic Programming</li>
<li>Recursion with Memoization</li>
</ul>
<p>Each method has its own time and space complexity, so choose based on the problem's constraints.</p>
<h6>3. Space Optimization</h6>
<p>While 2D Dynamic Programming is the most intuitive approach, you can reduce the space complexity to (O(\min(m, n))) by employing 1D Dynamic Programming. In an interview setting, discussing this optimization can impress your interviewer.</p>
<h6>4. Early Exit</h6>
<p>If the sum of the lengths of <code>s1</code> and <code>s2</code> does not match the length of <code>s3</code>, you can immediately return <code>false</code>. This can save computation time and demonstrate that you're mindful of edge cases.</p>
<h6>5. Explain Your Thought Process</h6>
<p>Always explain your thought process and why you chose a particular approach. Discuss the trade-offs you're making in terms of time and space complexity.</p>
<h5>Conclusion</h5>
<p>The "Interleaving String" problem is an excellent example of a problem that can be tackled through Dynamic Programming or Recursion. Knowing the trade-offs between different approaches and optimizing for space can give you an edge in interviews. By taking the time to understand the problem, choosing the appropriate data structures, and optimizing your approach, you'll not only solve the problem but also demonstrate a well-rounded skill set.</p>
<h4>Live Coding &amp; Explenation: 1D Dynamic Programming</h4>
<p>https://youtu.be/iv_cTwwsRxs</p>
<h4>Approach: 2D Dynamic Programming</h4>
<p>To solve the "Interleaving String" problem using 2D Dynamic Programming, we utilize a 2D array <code>dp[i][j]</code> to represent whether the substring <code>s3[:i+j]</code> can be formed by interleaving <code>s1[:i]</code> and <code>s2[:j]</code>.</p>
<h5>Key Data Structures:</h5>
<ul>
<li><strong>dp</strong>: A 2D list to store the results of subproblems.</li>
</ul>
<h5>Enhanced Breakdown:</h5>
<ol>
<li><strong>Initialization</strong>:</li>
<li>Calculate lengths of <code>s1</code>, <code>s2</code>, and <code>s3</code>.</li>
<li>If the sum of lengths of <code>s1</code> and <code>s2</code> is not equal to the length of <code>s3</code>, return false.</li>
<li>
<p>Initialize the <code>dp</code> array with dimensions <code>(m+1) x (n+1)</code>, setting <code>dp[0][0] = True</code>.</p>
</li>
<li>
<p><strong>Base Cases</strong>:</p>
</li>
<li>Fill in the first row of <code>dp</code> array, considering only the characters from <code>s1</code>.</li>
<li>
<p>Fill in the first column of <code>dp</code> array, considering only the characters from <code>s2</code>.</p>
</li>
<li>
<p><strong>DP Loop</strong>:</p>
</li>
<li>Loop through each possible <code>(i, j)</code> combination, starting from <code>(1, 1)</code>.</li>
<li>
<p>Update <code>dp[i][j]</code> based on the transition <code>dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])</code>.</p>
</li>
<li>
<p><strong>Wrap-up</strong>:</p>
</li>
<li>Return the value stored in <code>dp[m][n]</code>, which indicates whether <code>s3</code> can be formed by interleaving <code>s1</code> and <code>s2</code>.</li>
</ol>
<h4>Complexity:</h4>
<p><strong>Time Complexity:</strong> 
- The solution iterates over each possible $$ (i, j) $$ combination, leading to a time complexity of $$ O(m \times n) $$.</p>
<p><strong>Space Complexity:</strong> 
- The space complexity is $$ O(m \times n) $$ due to the 2D $$ dp $$ array.</p>
<h4>Approach: 1D Dynamic Programming</h4>
<p>The optimization from 2D to 1D DP is based on the observation that the state of <code>dp[i][j]</code> in the 2D DP array depends only on <code>dp[i-1][j]</code> and <code>dp[i][j-1]</code>. Therefore, while iterating through the strings, the current state only depends on the states in the previous row of the 2D DP array, which means we can optimize our space complexity by just keeping track of one row (1D DP).</p>
<h5>Key Data Structures:</h5>
<ul>
<li><strong>dp</strong>: A 1D list that stores whether the substring <code>s3[:i+j]</code> can be formed by interleaving <code>s1[:i]</code> and <code>s2[:j]</code>. Initially, all values are set to <code>False</code> except <code>dp[0]</code>, which is set to <code>True</code>.</li>
</ul>
<h5>Enhanced Breakdown:</h5>
<ol>
<li><strong>Initialization</strong>:</li>
<li>First, calculate the lengths of <code>s1</code>, <code>s2</code>, and <code>s3</code>.</li>
<li>
<p>Check if the sum of the lengths of <code>s1</code> and <code>s2</code> equals the length of <code>s3</code>. If it doesn't, return <code>False</code> as <code>s3</code> cannot be formed by interleaving <code>s1</code> and <code>s2</code>.</p>
</li>
<li>
<p><strong>Optimization Check</strong>:</p>
</li>
<li>
<p>If <code>m &lt; n</code>, swap <code>s1</code> and <code>s2</code>. This is to ensure that <code>s1</code> is not longer than <code>s2</code>, which helps in optimizing the space complexity to <code>O(min(m, n))</code>.</p>
</li>
<li>
<p><strong>Base Cases</strong>:</p>
</li>
<li>Initialize a 1D array <code>dp</code> of length <code>n+1</code> with <code>False</code>.</li>
<li>
<p>Set <code>dp[0] = True</code> because an empty <code>s1</code> and <code>s2</code> can interleave to form an empty <code>s3</code>.</p>
</li>
<li>
<p><strong>Single-Row DP Transition</strong>:</p>
</li>
<li>Iterate through <code>s1</code> and <code>s2</code> to update the <code>dp</code> array.</li>
<li>For each character in <code>s1</code>, iterate through <code>s2</code> and update the <code>dp</code> array based on the transition rule: <code>dp[j] = (dp[j] and s1[i] == s3[i+j]) or (dp[j-1] and s2[j] == s3[i+j])</code>.</li>
<li>
<p>The transition rule checks if the current <code>s3[i+j]</code> can be matched by either <code>s1[i]</code> or <code>s2[j]</code>, relying solely on the previous values in the <code>dp</code> array.</p>
</li>
<li>
<p><strong>Wrap-up</strong>:</p>
</li>
<li>The final value in the <code>dp</code> array will indicate whether the entire <code>s3</code> can be formed by interleaving <code>s1</code> and <code>s2</code>.</li>
<li>Return <code>dp[n]</code>.</li>
</ol>
<h4>Complexity:</h4>
<p>The primary advantage of this 1D DP approach is its space efficiency. While it maintains the same time complexity as the 2D DP approach $$O(m \times n)$$, the space complexity is optimized to $$O(\min(m, n))$$.</p>
<p><strong>Time Complexity:</strong> 
- The solution iterates over each character of <code>s1</code> and <code>s2</code> once, leading to a complexity of $$O(m \times n)$$.</p>
<p><strong>Space Complexity:</strong> 
- The space complexity is optimized to $$O(\min(m,n))$$ as we're only using a single 1D array instead of a 2D matrix.</p>
<h4>Approach: Recursion with Memoization</h4>
<p>In this approach, we recursively check whether the substring <code>s3[k:]</code> can be formed by interleaving <code>s1[i:]</code> and <code>s2[j:]</code>. We store the results of these sub-problems in a dictionary named <code>memo</code>.</p>
<h5>Key Data Structures:</h5>
<ul>
<li><strong>memo</strong>: A dictionary to store the results of subproblems.</li>
</ul>
<h5>Enhanced Breakdown:</h5>
<ol>
<li><strong>Initialization</strong>:</li>
<li>Calculate lengths of <code>s1</code>, <code>s2</code>, and <code>s3</code>.</li>
<li>
<p>If the sum of lengths of <code>s1</code> and <code>s2</code> is not equal to the length of <code>s3</code>, return false.</p>
</li>
<li>
<p><strong>Recursive Function</strong>:</p>
</li>
<li>Define a recursive function <code>helper</code> which takes indices <code>i</code>, <code>j</code>, and <code>k</code> as inputs.</li>
<li>The function checks whether the substring <code>s3[k:]</code> can be formed by interleaving <code>s1[i:]</code> and <code>s2[j:]</code>.</li>
<li>
<p>Store the result of each subproblem in the <code>memo</code> dictionary.</p>
</li>
<li>
<p><strong>Wrap-up</strong>:</p>
</li>
<li>Return the result of the recursive function for the initial values <code>i=0, j=0, k=0</code>.</li>
</ol>
<h4>Complexity:</h4>
<p><strong>Time Complexity:</strong> 
- Each combination of (i, j) is computed once and stored in the memo, leading to a time complexity of $$O(m \times n)$$.</p>
<p><strong>Space Complexity:</strong> 
- The space complexity is $$O(m \times n)$$ for storing the memoization results.</p>
<h4>Performance</h4>
<p>| Language  | Runtime (ms) | Memory (MB) |
|-----------|--------------|-------------|
| Rust      | 0            | 2.1         |
| cpp       | 0            | 6.4         |
| Go        | 1            | 1.9         |
| Java      | 3            | 40.5        |
| Python3 (1D DP) | 31     | 16.4        |
| Python3 (2D DP) | 34     | 16.5        |
| Python3 (Recursion) | 45 | 17.4        |
| C####        | 54           | 38.4        |
| JavaScript| 61           | 43.1        |</p>
<h4>Code 1D Dynamic Programming</h4>
<pre><code class="language-Python">class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool:
        m, n, l = len(s1), len(s2), len(s3)
        if m + n != l:
            return False

        if m &lt; n:
            return self.isInterleave(s2, s1, s3)

        dp = [False] * (n + 1)
        dp[0] = True

        for j in range(1, n + 1):
            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]

        for i in range(1, m + 1):
            dp[0] = dp[0] and s1[i-1] == s3[i-1]
            for j in range(1, n + 1):
                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])

        return dp[n]
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int m = s1.length(), n = s2.length(), l = s3.length();
        if (m + n != l) return false;

        if (m &lt; n) return isInterleave(s2, s1, s3);

        vector&lt;bool&gt; dp(n + 1, false);
        dp[0] = true;

        for (int j = 1; j &lt;= n; ++j) {
            dp[j] = dp[j - 1] &amp;&amp; s2[j - 1] == s3[j - 1];
        }

        for (int i = 1; i &lt;= m; ++i) {
            dp[0] = dp[0] &amp;&amp; s1[i - 1] == s3[i - 1];
            for (int j = 1; j &lt;= n; ++j) {
                dp[j] = (dp[j] &amp;&amp; s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] &amp;&amp; s2[j - 1] == s3[i + j - 1]);
            }
        }

        return dp[n];
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length(), l = s3.length();
        if (m + n != l) return false;

        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int j = 1; j &lt;= n; ++j) {
            dp[j] = dp[j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(j - 1);
        }

        for (int i = 1; i &lt;= m; ++i) {
            dp[0] = dp[0] &amp;&amp; s1.charAt(i - 1) == s3.charAt(i - 1);
            for (int j = 1; j &lt;= n; ++j) {
                dp[j] = (dp[j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1));
            }
        }

        return dp[n];
    }
}
</code></pre>
<pre><code class="language-Rust">impl Solution {
    pub fn is_interleave(s1: String, s2: String, s3: String) -&gt; bool {
        let (m, n, l) = (s1.len(), s2.len(), s3.len());
        if m + n != l { return false; }

        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());
        let mut dp = vec![false; n + 1];
        dp[0] = true;

        for j in 1..=n {
            dp[j] = dp[j - 1] &amp;&amp; s2[j - 1] == s3[j - 1];
        }

        for i in 1..=m {
            dp[0] = dp[0] &amp;&amp; s1[i - 1] == s3[i - 1];
            for j in 1..=n {
                dp[j] = (dp[j] &amp;&amp; s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] &amp;&amp; s2[j - 1] == s3[i + j - 1]);
            }
        }

        dp[n]
    }
}
</code></pre>
<pre><code class="language-Go">func isInterleave(s1 string, s2 string, s3 string) bool {
    m, n, l := len(s1), len(s2), len(s3)
    if m + n != l {
        return false
    }

    dp := make([]bool, n+1)
    dp[0] = true

    for j := 1; j &lt;= n; j++ {
        dp[j] = dp[j-1] &amp;&amp; s2[j-1] == s3[j-1]
    }

    for i := 1; i &lt;= m; i++ {
        dp[0] = dp[0] &amp;&amp; s1[i-1] == s3[i-1]
        for j := 1; j &lt;= n; j++ {
            dp[j] = (dp[j] &amp;&amp; s1[i-1] == s3[i+j-1]) || (dp[j-1] &amp;&amp; s2[j-1] == s3[i+j-1])
        }
    }

    return dp[n]
}
</code></pre>
<pre><code class="language-C####">public class Solution {
    public bool IsInterleave(string s1, string s2, string s3) {
        int m = s1.Length, n = s2.Length, l = s3.Length;
        if (m + n != l) return false;

        bool[] dp = new bool[n + 1];
        dp[0] = true;

        for (int j = 1; j &lt;= n; ++j) {
            dp[j] = dp[j - 1] &amp;&amp; s2[j - 1] == s3[j - 1];
        }

        for (int i = 1; i &lt;= m; ++i) {
            dp[0] = dp[0] &amp;&amp; s1[i - 1] == s3[i - 1];
            for (int j = 1; j &lt;= n; ++j) {
                dp[j] = (dp[j] &amp;&amp; s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] &amp;&amp; s2[j - 1] == s3[i + j - 1]);
            }
        }

        return dp[n];
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function(s1, s2, s3) {
    let m = s1.length, n = s2.length, l = s3.length;
    if (m + n !== l) return false;

    let dp = new Array(n + 1).fill(false);
    dp[0] = true;

    for (let j = 1; j &lt;= n; ++j) {
        dp[j] = dp[j - 1] &amp;&amp; s2[j - 1] === s3[j - 1];
    }

    for (let i = 1; i &lt;= m; ++i) {
        dp[0] = dp[0] &amp;&amp; s1[i - 1] === s3[i - 1];
        for (let j = 1; j &lt;= n; ++j) {
            dp[j] = (dp[j] &amp;&amp; s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] &amp;&amp; s2[j - 1] === s3[i + j - 1]);
        }
    }

    return dp[n];
};
</code></pre>
<h4>Code 2D Dynamic Programming</h4>
<pre><code class="language-Python">class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool:
        m, n, l = len(s1), len(s2), len(s3)
        if m + n != l:
            return False

        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True

        for i in range(1, m + 1):
            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]

        for j in range(1, n + 1):
            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])

        return dp[m][n]

</code></pre>
<h4>Code Recursion with Memoization</h4>
<pre><code class="language-Python">class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool:
        m, n, l = len(s1), len(s2), len(s3)
        if m + n != l:
            return False

        memo = {} 

        def helper(i: int, j: int, k: int) -&gt; bool:
            if k == l:
                return True

            if (i, j) in memo:
                return memo[(i, j)]

            ans = False
            if i &lt; m and s1[i] == s3[k]:
                ans = ans or helper(i + 1, j, k + 1)

            if j &lt; n and s2[j] == s3[k]:
                ans = ans or helper(i, j + 1, k + 1)

            memo[(i, j)] = ans
            return ans

        return helper(0, 0, 0)
</code></pre>
<p>Both the given approaches provide efficient ways to solve the problem, with the first approach focusing on optimizing space and the second leveraging the power of memoization to save time. Choosing between them depends on the specific constraints and requirements of the application. ‍‍</p></div>