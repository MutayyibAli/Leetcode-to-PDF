<div class='cpp-solution'><h4>C++ Trie solution, 99.62% faster. [Votes: 67]</h4><p>cpp implementation in this <a href="https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00)">post</a></p>
<pre><code>class Solution {
    struct TrieNode {
        TrieNode *children[26];
        string word;

        TrieNode() : word(&quot;&quot;) {
            for (int i = 0; i &lt; 26; i++) {
                children[i] = nullptr;
            }
        }
    };

public:
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt; &amp;board, vector&lt;string&gt; &amp;words) {
        TrieNode *root = buildTrie(words);
        vector&lt;string&gt; result;
        for (int i = 0; i &lt; board.size(); i++) {
            for (int j = 0; j &lt; board[0].size(); j++) {
                dfs(board, i, j, root, result);
            }
        }
        return result;
    }

    /** Inserts a word into the trie. */
    TrieNode *buildTrie(vector&lt;string&gt; &amp;words) {
        TrieNode *root = new TrieNode();
        for (int j = 0; j &lt; words.size(); j++) {
            string word = words[j];
            TrieNode *curr = root;
            for (int i = 0; i &lt; word.length(); i++) {
                char c = word[i] - 'a';
                if (curr-&gt;children[c] == nullptr) {
                    curr-&gt;children[c] = new TrieNode();
                }
                curr = curr-&gt;children[c];
            }
            curr-&gt;word = word;
        }
        return root;
    }

    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, TrieNode *p, vector&lt;string&gt; &amp;result) {
        char c = board[i][j];
        if (c == '#' || !p-&gt;children[c - 'a']) return;
        p = p-&gt;children[c - 'a'];
        if (p-&gt;word.size() &gt; 0) {
            result.push_back(p-&gt;word);
            p-&gt;word = &quot;&quot;;
        }

        board[i][j] = '#';
        if (i &gt; 0) dfs(board, i - 1, j, p, result);
        if (j &gt; 0) dfs(board, i, j - 1, p, result);
        if (i &lt; board.size() - 1) dfs(board, i + 1, j, p, result);
        if (j &lt; board[0].size() - 1) dfs(board, i, j + 1, p, result);
        board[i][j] = c;
    }
};
</code></pre></div><div class='python-solution'><h4>Python dfs solution (directly use Trie implemented). [Votes: 384]</h4><p>Here is an implementation based on  <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie</a> in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. </p>
<pre><code>class TrieNode():
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.isWord = False

class Trie():
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isWord = True

    def search(self, word):
        node = self.root
        for w in word:
            node = node.children.get(w)
            if not node:
                return False
        return node.isWord

class Solution(object):
    def findWords(self, board, words):
        res = []
        trie = Trie()
        node = trie.root
        for w in words:
            trie.insert(w)
        for i in xrange(len(board)):
            for j in xrange(len(board[0])):
                self.dfs(board, node, i, j, "", res)
        return res

    def dfs(self, board, node, i, j, path, res):
        if node.isWord:
            res.append(path)
            node.isWord = False
        if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]):
            return 
        tmp = board[i][j]
        node = node.children.get(tmp)
        if not node:
            return 
        board[i][j] = "#"
        self.dfs(board, node, i+1, j, path+tmp, res)
        self.dfs(board, node, i-1, j, path+tmp, res)
        self.dfs(board, node, i, j-1, path+tmp, res)
        self.dfs(board, node, i, j+1, path+tmp, res)
        board[i][j] = tmp
</code></pre></div>