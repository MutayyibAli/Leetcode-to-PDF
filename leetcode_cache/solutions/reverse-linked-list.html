<div class='cpp-solution'><h4>[C++] Iterative vs. Recursive Solutions Compared and Explained, ~99% Time, ~85% Space [Votes: 1008]</h4><p>Not sure how this problem is expecting me to use less memory than this, but here is the deal:
* we are going to use 3 variables: <code>prevNode</code>, <code>head</code> and <code>nextNode</code>, that you can easily guess what are meant to represent as we go;
* we will initialise <code>prevNode</code> to <code>NULL</code>, while <code>nextNode</code> can stay empty;
* we are then going to loop until our current main iterator (<code>head</code>) is truthy (ie: not <code>NULL</code>), which would imply we reached the end of the list;
* during the iteration, we first of all update <code>nextNode</code> so that it acquires its namesake value, the one of the next node indeed: <code>head-&gt;next</code>;
* we then proceeding "reversing" <code>head-&gt;next</code> and assigning it the value of <code>prevNode</code>, while <code>prevNode</code> will become take the current value of <code>head</code>;
* finally, we update <code>head</code> with the value we stored in <code>nextNode</code> and go on with the loop until we can. After the loop, we return <code>prevNode</code>.</p>
<p>I know it is complex, but I find this gif from another platform to make the whole logic much easier to understand (bear in mind we do not need <code>curr</code> and will just use <code>head</code> in its place):</p>
<p>The code:</p>
<pre><code class="language-cpp">class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *nextNode, *prevNode = NULL;
        while (head) {
            nextNode = head-&gt;next;
            head-&gt;next = prevNode;
            prevNode = head;
            head = nextNode;
        }
        return prevNode;
    }
};
</code></pre>
<p>Relatively trivial refactor (the function does basically the same) with recursion and comma operator to make it one-line:</p>
<pre><code class="language-cpp">class Solution {
public:
    ListNode* reverseList(ListNode *head, ListNode *nextNode = NULL, ListNode *prevNode = NULL) {
        return head ? reverseList(head-&gt;next, (head-&gt;next = prevNode, nextNode), head) : prevNode;
    }
};
</code></pre></div><div class='python-solution'><h4>Easy || 0 ms || 100% || Fully Explained || Java, C++, Python, JS, C, Python3 (Recursive & Iterative) [Votes: 396]</h4><h4><strong>Java Solution (Recursive Approach):</strong></h4>
<p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.</p>
<pre><code>class Solution {
    public ListNode reverseList(ListNode head) {
        // Special case...
        if (head == null || head.next == null) return head;
        // Create a new node to call the function recursively and we get the reverse linked list...
        ListNode res = reverseList(head.next);
        // Set head node as head.next.next...
        head.next.next = head;
        //set head's next to be null...
        head.next = null;
        return res;     // Return the reverse linked list...
    }
}
</code></pre>
<h4><strong>cpp Solution (Iterative Approach):</strong></h4>
<pre><code>class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // Special case...
        if(head == NULL || head-&gt;next == NULL)  return head;
        // Initialize prev pointer as the head...
        ListNode* prev = head;
        // Initialize curr pointer as the next pointer of prev...
        ListNode* curr = prev-&gt;next;
        // Initialize next of head pointer as NULL...
        head-&gt;next = NULL;
        // Run a loop till curr and prev points to NULL...
        while(prev != NULL &amp;&amp; curr != NULL){
            // Initialize next pointer as the next pointer of curr...
            ListNode* next = curr-&gt;next;
            // Now assign the prev pointer to curr’s next pointer.
            curr-&gt;next = prev;
            // Assign curr to prev, next to curr...
            prev = curr;
            curr = next;
        }
        return prev;    // Return the prev pointer to get the reverse linked list...
    }
};
</code></pre>
<h4><strong>Python Solution (Iterative Approach):</strong></h4>
<p>Runtime: 18 ms, faster than 97.75% of Python online submissions for Reverse Linked List.</p>
<pre><code>class Solution(object):
    def reverseList(self, head):
        #### Initialize prev pointer as NULL...
        prev = None
        #### Initialize the curr pointer as the head...
        curr = head
        #### Run a loop till curr points to NULL...
        while curr:
            #### Initialize next pointer as the next pointer of curr...
            next = curr.next
            #### Now assign the prev pointer to curr’s next pointer.
            curr.next = prev
            #### Assign curr to prev, next to curr...
            prev = curr
            curr = next
        return prev       #### Return the prev pointer to get the reverse linked list...
</code></pre>
<h4><strong>JavaScript Solution (Recursive Approach):</strong></h4>
<pre><code>var reverseList = function(head) {
    // Special case...
    if (head == null || head.next == null) return head;
    // Create a new node to call the function recursively and we get the reverse linked list...
    var res = reverseList(head.next);
    // Set head node as head.next.next...
    head.next.next = head;
    //set head's next to be null...
    head.next = null;
    return res;     // Return the reverse linked list...
};
</code></pre>
<h4><strong>C Language (Iterative Approach):</strong></h4>
<pre><code>struct ListNode* reverseList(struct ListNode* head){
    // Special case...
    if(head == NULL || head-&gt;next == NULL)  return head;
    // Initialize prev pointer as the head...
    struct ListNode* prev = head;
    // Initialize curr pointer as the next pointer of prev...
    struct ListNode* curr = prev-&gt;next;
    // Initialize next of head pointer as NULL...
    head-&gt;next = NULL;
    // Run a loop till curr and prev points to NULL...
    while(prev != NULL &amp;&amp; curr != NULL){
        // Initialize next pointer as the next pointer of curr...
        struct ListNode* next = curr-&gt;next;
        // Now assign the prev pointer to curr’s next pointer.
        curr-&gt;next = prev;
        // Assign curr to prev, next to curr...
        prev = curr;
        curr = next;
    }
    return prev;    // Return the prev pointer to get the reverse linked list...
}
</code></pre>
<h4><strong>Python3 Solution (Iterative Approach):</strong></h4>
<pre><code>class Solution:
    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        #### Initialize prev pointer as NULL...
        prev = None
        #### Initialize the curr pointer as the head...
        curr = head
        #### Run a loop till curr points to NULL...
        while curr:
            #### Initialize next pointer as the next pointer of curr...
            next = curr.next
            #### Now assign the prev pointer to curr’s next pointer.
            curr.next = prev
            #### Assign curr to prev, next to curr...
            prev = curr
            curr = next
        return prev       #### Return the prev pointer to get the reverse linked list...
</code></pre>
<p><strong>I am working hard for you guys...
Please upvote if you found any help with this code...</strong></p></div>