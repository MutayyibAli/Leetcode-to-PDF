<div class='cpp-solution'><h4>ðŸ”¥ [LeetCode The Hard Way] ðŸ”¥ Explained Line By Line [Votes: 25]</h4><p>Check out <a href="https://wingkwong.github.io/leetcode-the-hard-way/">LeetCode The Hard Way</a> for more solution explanations and tutorials. 
 Check out our <a href="https://discord.gg/Nqm4jJcyBf">Discord</a> for live discussion.
 Give a star on <a href="https://github.com/wingkwong/leetcode-the-hard-way">Github Repository</a> and upvote this post if you like it.</p>
<iframe src="https://leetcode.com/playground/9GjRQFxZ/shared" frameBorder="0" width="100%" height="500"></iframe></div><div class='python-solution'><h4>[Python] Easy DFS MEMOIZATION & BFS [Votes: 32]</h4><h4><strong>Nearest Exit from Entrance in Maze</strong></h4>
<h5>DFS Idea</h5>
<ul>
<li>We search from entrance cell for the nearest boundary cell in all four directions and after getting the distance from all direction, it returns <em>minimum</em> of them.</li>
<li>Function <code>reached</code> checks if currect cell is boundary and not the entrance cell</li>
<li>Here <code>@lru_cache(None)</code> is used for top-down memoization approach</li>
</ul>
<p><strong>Complexity</strong>
* Time Complexity :- <code>O(m*n)</code>
* Space Complexity :- <code>O(m*n)</code> because of  <code>@lru_cache(None)</code></p>
<pre><code>class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -&gt; int:
        x, y = entrance
        m, n, infi = len(maze), len(maze[0]), int(1e5)
        reached = lambda p, q: (not p==x or not q==y) and (p==0 or q==0 or p==m-1 or q==n-1)
        @lru_cache(None)
        def dfs(i, j):
            if i&lt;0 or j&lt;0 or i==m or j==n or maze[i][j]=='+':
                return infi
            if reached(i, j):
                return 0
            maze[i][j] = '+'
            ans = 1+min(dfs(i+1, j), dfs(i-1, j), dfs(i, j+1), dfs(i, j-1))
            maze[i][j] = '.'
            return ans
        ans = dfs(x, y)
        return -1 if ans&gt;=infi else ans
</code></pre>
<p><em>why DFS with dp sometimes give WA explained in the end</em>.</p>
<h5>BFS Idea</h5>
<ul>
<li>We search from entrance cell for the nearest boundary cell in all four directions level by level i.e. 0, 1.... until we get boundary</li>
<li>Function <code>reached</code> checks if currect cell is boundary and not the entrance cell</li>
</ul>
<p><strong>Complexity</strong>
* Time Complexity :- <code>O(m*n)</code>
* Space Complexity :- <code>O(m*n)</code></p>
<pre><code>class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -&gt; int:
        x, y = entrance
        m, n, infi = len(maze), len(maze[0]), int(1e5)
        reached = lambda p, q: (not p==x or not q==y) and (p==0 or q==0 or p==m-1 or q==n-1)
        q, ans = deque(), 0
        q.append((x, y, ans))
        directions = [1, 0, -1, 0, 1]
        while q:
            row, col, ans = q.popleft()
            for i in range(4):
                r, c = row+directions[i], col+directions [i+1]
                if r&lt;0 or c&lt;0 or r==m or c==n or maze[r][c]=='+':
                    continue
                if reached(r, c):
                    return ans+1
                maze[r][c] = '+'
                q.append((r, c, ans+1))
        return -1
</code></pre>
<p><strong>Why DFS with Memoization sometimes gives WA</strong>:-.</p>
<p>For <strong>DFS without memoization</strong> all test case will give correct answer as it search every path but may give <strong>TLE</strong>, and for <strong>DFS with dp</strong> it totally depends on luck , what you search first.
For better understanding let's take example:-</p>
<p><strong>e</strong> denotes Entrance</p>
<pre><code>++++
.e.+
.+.+
...+
++++
</code></pre>
<p><code>Condition -&gt; 1+min((i, j+1), .............)</code>
After operations it will look like</p>
<pre><code>++++
7e1+
6+2+
543+
++++
</code></pre>
<p><code>ans = 1+min(7, 7, infinite, infinite)</code>
instead of 
<code>ans = 1+min(7, 1, infinite, infinite)</code></p>
<p>[Note] =&gt; <em>This example is just for intuition. For real example please see https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4115</em></p>
<p><strong>Conclusion</strong>:-
* DFS without memoization works fine but gives TLE
* DFS with memoization may give correct but not necessary
* BFS searches level wise and gives result as soon as finds exit which is best for this problem</p>
<p><em>Please upvote if you like the solution and comment if have queries</em></p></div>