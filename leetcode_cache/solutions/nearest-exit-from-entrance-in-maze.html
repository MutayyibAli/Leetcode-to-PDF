<div class='cpp-solution'><h2>ðŸ”¥ [LeetCode The Hard Way] ðŸ”¥ Explained Line By Line -- Votes: 25</h2><p>Check out <a href="https://wingkwong.github.io/leetcode-the-hard-way/">LeetCode The Hard Way</a> for more solution explanations and tutorials.<br />
Check out our <a href="https://discord.gg/Nqm4jJcyBf">Discord</a> for live discussion.<br />
Give a star on <a href="https://github.com/wingkwong/leetcode-the-hard-way">Github Repository</a> and upvote this post if you like it.</p>
<hr />
<iframe src="https://leetcode.com/playground/9GjRQFxZ/shared" frameBorder="0" width="100%" height="500"></iframe></div>


<div class='python-solution'><h2>[Python] Easy DFS MEMOIZATION & BFS -- Votes: 32</h2><h2><strong>Nearest Exit from Entrance in Maze</strong></h2>
<h3>DFS Idea</h3>
<ul>
<li>We search from entrance cell for the nearest boundary cell in all four directions and after getting the distance from all direction, it returns <em>minimum</em> of them.</li>
<li>Function <code>reached</code> checks if currect cell is boundary and not the entrance cell</li>
<li>Here <code>@lru_cache(None)</code> is used for top-down memoization approach</li>
</ul>
<p><strong>Complexity</strong></p>
<ul>
<li>Time Complexity :- <code>O(m*n)</code></li>
<li>Space Complexity :- <code>O(m*n)</code> because of <code>@lru_cache(None)</code></li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nl">Solution</span><span class="p">:</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">nearestExit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="nl">maze</span><span class="p">:</span><span class="w"> </span><span class="n">List</span><span class="o">[</span><span class="n">List[str</span><span class="o">]</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="nl">entrance</span><span class="p">:</span><span class="w"> </span><span class="n">List</span><span class="o">[</span><span class="n">int</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">int</span><span class="err">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entrance</span>
<span class="w">        </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">infi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">maze</span><span class="p">),</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">maze</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">),</span><span class="w"> </span><span class="nc">int</span><span class="p">(</span><span class="mf">1e5</span><span class="p">)</span>
<span class="w">        </span><span class="n">reached</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nl">q</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="ow">not</span><span class="w"> </span><span class="n">p</span><span class="o">==</span><span class="n">x</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">q</span><span class="o">==</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">q</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">p</span><span class="o">==</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">q</span><span class="o">==</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="nv">@lru_cache</span><span class="p">(</span><span class="k">None</span><span class="p">)</span>
<span class="w">        </span><span class="n">def</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">i</span><span class="o">==</span><span class="n">m</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">j</span><span class="o">==</span><span class="n">n</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">maze</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]==</span><span class="s1">&#39;+&#39;</span><span class="err">:</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">infi</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">reached</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="err">:</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span>
<span class="w">            </span><span class="n">maze</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;+&#39;</span>
<span class="w">            </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="nf">min</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="w">            </span><span class="n">maze</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;.&#39;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span>
<span class="w">        </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">ans</span><span class="o">&gt;=</span><span class="n">infi</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">ans</span>
</code></pre></div>

<p><em>why DFS with dp sometimes give WA explained in the end</em>.</p>
<h3>BFS Idea</h3>
<ul>
<li>We search from entrance cell for the nearest boundary cell in all four directions level by level i.e. 0, 1.... until we get boundary</li>
<li>Function <code>reached</code> checks if currect cell is boundary and not the entrance cell</li>
</ul>
<p><strong>Complexity</strong></p>
<ul>
<li>Time Complexity :- <code>O(m*n)</code></li>
<li>Space Complexity :- <code>O(m*n)</code></li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nl">Solution</span><span class="p">:</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">nearestExit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="nl">maze</span><span class="p">:</span><span class="w"> </span><span class="n">List</span><span class="o">[</span><span class="n">List[str</span><span class="o">]</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="nl">entrance</span><span class="p">:</span><span class="w"> </span><span class="n">List</span><span class="o">[</span><span class="n">int</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">int</span><span class="err">:</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entrance</span>
<span class="w">        </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">infi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">maze</span><span class="p">),</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">maze</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">),</span><span class="w"> </span><span class="nc">int</span><span class="p">(</span><span class="mf">1e5</span><span class="p">)</span>
<span class="w">        </span><span class="n">reached</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nl">q</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="ow">not</span><span class="w"> </span><span class="n">p</span><span class="o">==</span><span class="n">x</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">q</span><span class="o">==</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">q</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">p</span><span class="o">==</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">q</span><span class="o">==</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deque</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="p">))</span>
<span class="w">        </span><span class="n">directions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">1, 0, -1, 0, 1</span><span class="o">]</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="nl">q</span><span class="p">:</span>
<span class="w">            </span><span class="k">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">:</span>
<span class="w">                </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">row</span><span class="o">+</span><span class="n">directions</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">+</span><span class="n">directions</span><span class="w"> </span><span class="o">[</span><span class="n">i+1</span><span class="o">]</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">r</span><span class="o">==</span><span class="n">m</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">c</span><span class="o">==</span><span class="n">n</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">maze</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]==</span><span class="s1">&#39;+&#39;</span><span class="err">:</span>
<span class="w">                    </span><span class="k">continue</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">reached</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="err">:</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="o">+</span><span class="mi">1</span>
<span class="w">                </span><span class="n">maze</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;+&#39;</span>
<span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
</code></pre></div>

<p><strong>Why DFS with Memoization sometimes gives WA</strong>:-.</p>
<p>For <strong>DFS without memoization</strong> all test case will give correct answer as it search every path but may give <strong>TLE</strong>, and for <strong>DFS with dp</strong> it totally depends on luck , what you search first.<br />
For better understanding let's take example:-</p>
<p><strong>e</strong> denotes Entrance</p>
<div class="codehilite"><pre><span></span><code><span class="err">++++</span>
<span class="na">.e.</span><span class="err">+</span>
<span class="err">.+.+</span>
<span class="na">...</span><span class="err">+</span>
<span class="err">++++</span>
</code></pre></div>

<p><code>Condition -&gt; 1+min((i, j+1), .............)</code><br />
After operations it will look like</p>
<div class="codehilite"><pre><span></span><code>++++
7e1+
6+2+
543+
++++
</code></pre></div>

<p><code>ans = 1+min(7, 7, infinite, infinite)</code><br />
instead of<br />
<code>ans = 1+min(7, 1, infinite, infinite)</code></p>
<p>[Note] =&gt; <em>This example is just for intuition. For real example please see https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4115</em></p>
<p><strong>Conclusion</strong>:-</p>
<ul>
<li>DFS without memoization works fine but gives TLE</li>
<li>DFS with memoization may give correct but not necessary</li>
<li>BFS searches level wise and gives result as soon as finds exit which is best for this problem</li>
</ul>
<p><em>Please upvote if you like the solution and comment if have queries</em></p></div><p style="page-break-before: always" ></p>