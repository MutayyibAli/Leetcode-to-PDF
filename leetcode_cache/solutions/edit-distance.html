<div class='cpp-solution'><h4>C++ O(n)-space DP [Votes: 1248]</h4><p>To apply DP, we define the state <code>dp[i][j]</code> to be the minimum number of operations to convert <code>word1[0..i)</code> to <code>word2[0..j)</code>.</p>
<p>For the base case, that is, to convert a string to an empty string, the mininum number of operations (deletions) is just the length of the string. So we have <code>dp[i][0] = i</code> and <code>dp[0][j] = j</code>.</p>
<p>For the general case to convert <code>word1[0..i)</code> to <code>word2[0..j)</code>, we break this problem down into sub-problems. Suppose we have already known how to convert <code>word1[0..i - 1)</code> to <code>word2[0..j - 1)</code> (<code>dp[i - 1][j - 1]</code>), if  <code>word1[i - 1] == word2[j - 1]</code>, then no more operation is needed and <code>dp[i][j] = dp[i - 1][j - 1]</code>.</p>
<p>If <code>word1[i - 1] != word2[j - 1]</code>, we need to consider three cases.</p>
<ol>
<li><strong>Replace</strong> <code>word1[i - 1]</code> by <code>word2[j - 1]</code> (<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>);</li>
<li>If <code>word1[0..i - 1) = word2[0..j)</code> then <strong>delete</strong> <code>word1[i - 1]</code> (<code>dp[i][j] = dp[i - 1][j] + 1</code>);</li>
<li>If <code>word1[0..i) + word2[j - 1] = word2[0..j)</code> then <strong>insert</strong> <code>word2[j - 1]</code> to <code>word1[0..i)</code> (<code>dp[i][j] = dp[i][j - 1] + 1</code>).</li>
</ol>
<p>So when <code>word1[i - 1] != word2[j - 1]</code>, <code>dp[i][j]</code> will just be the minimum of the above three cases.</p>
<pre><code class="language-cpp">class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
        for (int i = 1; i &lt;= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 1; j &lt;= n; j++) {
            dp[0][j] = j;
        }
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;
                }
            }
        }
        return dp[m][n];
    }
};
</code></pre>
<p>Note that each time when we update <code>dp[i][j]</code>, we only need <code>dp[i - 1][j - 1]</code>, <code>dp[i][j - 1]</code> and <code>dp[i - 1][j]</code>. We may optimize the space of the code to use only two vectors.</p>
<pre><code class="language-cpp">class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector&lt;int&gt; pre(n + 1, 0), cur(n + 1, 0);
        for (int j = 1; j &lt;= n; j++) {
            pre[j] = j;
        }
        for (int i = 1; i &lt;= m; i++) {
            cur[0] = i;
            for (int j = 1; j &lt;= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    cur[j] = pre[j - 1];
                } else {
                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;
                }
            }
            fill(pre.begin(), pre.end(), 0);
            swap(pre, cur);
        }
        return pre[n];
    }
};
</code></pre>
<p>Or even just one vector.</p>
<pre><code class="language-cpp">class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size(), pre;
        vector&lt;int&gt; cur(n + 1, 0);
        for (int j = 1; j &lt;= n; j++) {
            cur[j] = j;
        }
        for (int i = 1; i &lt;= m; i++) {
            pre = cur[0];
            cur[0] = i;
            for (int j = 1; j &lt;= n; j++) {
                int temp = cur[j];
                if (word1[i - 1] == word2[j - 1]) {
                    cur[j] = pre;
                } else {
                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;
                }
                pre = temp;
            }
        }
        return cur[n];
    }
};
</code></pre></div><div class='python-solution'><h4>Clean CodesðŸ”¥ðŸ”¥|| Full Explanationâœ…|| Dynamic Programmingâœ…|| C++|| Java|| Python3 [Votes: 626]</h4><h4>Intuition :</h4>
<ul>
<li>Here we have to find the minimum edit distance problem between two strings word1 and word2. </li>
<li>The minimum edit distance is defined as the minimum number of operations required to transform one string into another.</li>
</ul>
<!-- Describe your first thoughts on how to solve this problem. -->

<h4>Approach :</h4>
<ul>
<li>The approach here that I am using is dynamic programming. The idea is to build a 2D matrix dp where <code>dp[i][j]</code>represents the minimum number of operations required to transform the substring <code>word1[0...i-1]</code> into the substring <code>word2[0...j-1].</code></li>
</ul>
<h4>How is Matrix built :</h4>
<ul>
<li>The matrix is built iteratively using the following recurrence relation:</li>
<li>If <code>word1[i-1] == word2[j-1]</code>, then <code>dp[i][j] = dp[i-1][j-1]</code>. That is, no operation is required because the characters at positions <code>i-1</code> and <code>j-1</code> are already the same.</li>
<li>Otherwise, <code>dp[i][j]</code> is the minimum of the following three values:</li>
<li><code>dp[i-1][j-1] + 1</code>: replace the character at position <code>i-1</code> in <code>word1</code> with the character at position <code>j-1</code> in<code>word2</code>.</li>
<li><code>dp[i-1][j] + 1</code>: delete the character at position <code>i-1</code> in <code>word1.</code></li>
<li><code>dp[i][j-1] + 1</code>: insert the character at position <code>j-1</code> in <code>word2</code> into <code>word1</code> at position <code>i</code>.</li>
</ul>
<h4>The base cases are:</h4>
<ul>
<li><code>dp[i][0] = i</code>: transforming <code>word1[0...i-1]</code> into an empty string requires <code>i</code> deletions.</li>
<li><code>dp[0][j] = j</code>: transforming an empty string into <code>word2[0...j-1]</code>requires <code>j</code> insertions.</li>
</ul>
<!-- Describe your approach to solving the problem. -->
<h4>Final Step :</h4>
<ul>
<li>Finally, return <code>dp[m][n]</code>, which represents the minimum number of operations required to transform <code>word1</code>into <code>word2</code>, where <code>m</code> is the length of <code>word1</code> and <code>n</code> is the length of <code>word2</code>.</li>
</ul>
<h4>Complexity</h4>
<ul>
<li>Time complexity : O(mn)</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity : O(mn)</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution.
</code></pre>
<h4>Codes [cpp |Java |Python3] : With Comments</h4>
<pre><code class="language-cpp">class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int m = word1.length();//first word length
    const int n = word2.length();//second word length
    // dp[i][j] := min #### of operations to convert word1[0..i) to word2[0..j)
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));

    for (int i = 1; i &lt;= m; ++i)
      dp[i][0] = i;

    for (int j = 1; j &lt;= n; ++j)
      dp[0][j] = j;

    for (int i = 1; i &lt;= m; ++i)
      for (int j = 1; j &lt;= n; ++j)
        if (word1[i - 1] == word2[j - 1])//same characters
          dp[i][j] = dp[i - 1][j - 1];//no operation
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                             //replace       //delete        //insert
    return dp[m][n];
  }
};
</code></pre>
<pre><code class="language-Java">class Solution {
  public int minDistance(String word1, String word2) {
    final int m = word1.length();//first word length
    final int n = word2.length();///second word length
    // dp[i][j] := min #### of operations to convert word1[0..i) to word2[0..j)
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 1; i &lt;= m; ++i)
      dp[i][0] = i;

    for (int j = 1; j &lt;= n; ++j)
      dp[0][j] = j;

    for (int i = 1; i &lt;= m; ++i)
      for (int j = 1; j &lt;= n; ++j)
        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters
          dp[i][j] = dp[i - 1][j - 1];//no operation
        else
          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert

    return dp[m][n];
  }
}

</code></pre>
<pre><code class="language-Python">class Solution:
  def minDistance(self, word1: str, word2: str) -&gt; int:
    m = len(word1)
    n = len(word2)
    #### dp[i][j] := min #### Of operations to convert word1[0..i) to word2[0..j)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      dp[i][0] = i

    for j in range(1, n + 1):
      dp[0][j] = j

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if word1[i - 1] == word2[j - 1]:
          dp[i][j] = dp[i - 1][j - 1]
        else:
          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

    return dp[m][n]
</code></pre>
<h4>Please Upvote</h4></div>