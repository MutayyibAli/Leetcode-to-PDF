<div class='cpp-solution'><h4>ðŸš€[Animation] - Understand in 30 seconds [Votes: 1326]</h4><p><em>upvoting the answer will motivate me to create more animations! Thanks.</em></p>
<h4>Approach</h4>
<p>2 Steps to rotate image
- Transpose the matrix
- Swap the columns </p>
<h4>Code</h4>
<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int row = matrix.size();
        for(int i=0;i&lt;row; i++){
            for(int j=0; j&lt;=i;j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i=0;i&lt;row;i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
</code></pre></div><div class='python-solution'><h4>Seven Short Solutions (1 to 7 lines) [Votes: 1186]</h4><p>While these solutions are Python, I think they're understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix <code>matrix</code>, so I'll use the usual <code>A</code>. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far.</p>
<p><strong>Most Pythonic - <code>[::-1]</code> and <code>zip</code></strong> - 44 ms</p>
<p>The most pythonic solution is a simple one-liner using <code>[::-1]</code> to flip the matrix upside down and then <code>zip</code> to transpose it. It assigns the result back into <code>A</code>, so it's "in-place" in a sense and the OJ accepts it as such, though some people might not.</p>
<pre><code>class Solution:
    def rotate(self, A):
        A[:] = zip(*A[::-1])
</code></pre>
<p><strong>Most Direct</strong> - 52 ms</p>
<p>A 100% in-place solution. It even reads and writes each matrix element only once and doesn't even use an extra temporary variable to hold them. It walks over the <em>"top-left quadrant"</em> of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I'm moving the four elements in parallel and that <code>[~i]</code> is way nicer than <code>[n-1-i]</code>.</p>
<pre><code>class Solution:
    def rotate(self, A):
        n = len(A)
        for i in range(n/2):
            for j in range(n-n/2):
                A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \
                         A[~j][i], A[~i][~j], A[j][~i], A[i][j]
</code></pre>
<p><strong>Clean Most Pythonic</strong> - 56 ms</p>
<p>While the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it's a bit dirty. To fix this, we can just apply <code>list</code> to every row:</p>
<pre><code>class Solution:
    def rotate(self, A):
        A[:] = map(list, zip(*A[::-1]))
</code></pre>
<p><strong>List Comprehension</strong> - 60 ms</p>
<p>If you don't like <code>zip</code>, you can use a nested list comprehension instead:</p>
<pre><code>class Solution:
    def rotate(self, A):
        A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))]
</code></pre>
<p><strong>Almost as Direct</strong> - 40 ms</p>
<p>If you don't like the little repetitive code of the above "Most Direct" solution, we can instead do each four-cycle of elements by using three swaps of just two elements.</p>
<pre><code>class Solution:
    def rotate(self, A):
        n = len(A)
        for i in range(n/2):
            for j in range(n-n/2):
                for _ in '123':
                    A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i
                i = ~j
</code></pre>
<p><strong>Flip Flip</strong> - 40 ms</p>
<p>Basically the same as the first solution, but using <code>reverse</code> instead of <code>[::-1]</code> and transposing the matrix with loops instead of <code>zip</code>. It's 100% in-place, just instead of only moving elements around, it also moves the rows around.</p>
<pre><code>class Solution:
    def rotate(self, A):
        A.reverse()
        for i in range(len(A)):
            for j in range(i):
                A[i][j], A[j][i] = A[j][i], A[i][j]
</code></pre>
<p><strong>Flip Flip, all by myself</strong> - 48 ms</p>
<p>Similar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements.</p>
<pre><code>class Solution:
    def rotate(self, A):
        n = len(A)
        for i in range(n):
            for j in range(i):
                A[i][j], A[j][i] = A[j][i], A[i][j]
        for row in A:
            for j in range(n/2):
                row[j], row[~j] = row[~j], row[j]
</code></pre></div>