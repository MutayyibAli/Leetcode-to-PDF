<div class='cpp-solution'><h4>C++ Best and easy DP Solution [Votes: 68]</h4><p>Similar idea from the problem <a href="https://leetcode.com/problems/coin-change-2/">coin-change-2</a> .
it is simplest and fastest dp solution, we don't need to sort elements </p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; nums, int target) {
        // dp vector to store all possible combinations of the target sum
        vector &lt;vector &lt;vector &lt;int&gt;&gt;&gt; dp(target+1);
        dp[0]={{}};
        for(int &amp;i:nums)
        {
        // Iterating through all the elements from array nums aka candidates
            for(int j=i;j&lt;=target;j++)
            {
            // Finding all possible ways to achieve sum j from element i
                for(auto v:dp[j-i])
                {
                    v.push_back(i);
                    dp[j].push_back(v);
                }
            }
        }
        // Finally, returning our ans 
        return dp[target];
    }
};
</code></pre>
<p>If you liked this solution please upvote if you have any query plz comment below </p></div><div class='python-solution'><h4>Python dfs solution. [Votes: 613]</h4><pre><code>class Solution(object):
    def combinationSum(self, candidates, target):
        ret = []
        self.dfs(candidates, target, [], ret)
        return ret

    def dfs(self, nums, target, path, ret):
        if target &lt; 0:
            return 
        if target == 0:
            ret.append(path)
            return 
        for i in range(len(nums)):
            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)
</code></pre></div>