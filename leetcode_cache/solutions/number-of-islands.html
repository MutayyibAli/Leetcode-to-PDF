<div class='cpp-solution'><h4>C++ BFS/DFS [Votes: 585]</h4><p>I saw many peope post DFS solutions but fewer BFS ones. So I wrote one below. Each time when I see a <code>'1'</code>, I increment the counter and then erase all connected <code>'1'</code>s using a <code>queue</code>.</p>
<pre><code class="language-cpp">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (grid[i][j] == '1') {
                    islands++;
                    grid[i][j] = '0';
                    queue&lt;pair&lt;int, int&gt;&gt; todo;
                    todo.push({i, j});
                    while (!todo.empty()) {
                        pair&lt;int, int&gt; p = todo.front();
                        todo.pop();
                        for (int k = 0; k &lt; 4; k++) {
                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];
                            if (r &gt;= 0 &amp;&amp; r &lt; m &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == '1') {
                                grid[r][c] = '0';
                                todo.push({r, c});
                            }
                        }
                    }
                }
            }
        }
        return islands;
    }
};
</code></pre>
<p>Or I can erase all the connected <code>'1'</code>s using DFS.</p>
<pre><code class="language-cpp">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (grid[i][j] == '1') {
                    islands++;
                    eraseIslands(grid, i, j);
                }
            }
        }
        return islands;
    }
private:
    void eraseIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) {
        int m = grid.size(), n = grid[0].size();
        if (i &lt; 0 || i == m || j &lt; 0 || j == n || grid[i][j] == '0') {
            return;
        }
        grid[i][j] = '0';
        eraseIslands(grid, i - 1, j);
        eraseIslands(grid, i + 1, j);
        eraseIslands(grid, i, j - 1);
        eraseIslands(grid, i, j + 1);
    }
};
</code></pre></div><div class='python-solution'><h4>Python Simple DFS Solution [Votes: 1653]</h4><p>Iterate through each of the cell and if it is an island, do dfs to mark all adjacent islands, then increase the counter by 1.</p>
<pre><code>def numIslands(self, grid):
    if not grid:
        return 0

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                self.dfs(grid, i, j)
                count += 1
    return count

def dfs(self, grid, i, j):
    if i&lt;0 or j&lt;0 or i&gt;=len(grid) or j&gt;=len(grid[0]) or grid[i][j] != '1':
        return
    grid[i][j] = '#'
    self.dfs(grid, i+1, j)
    self.dfs(grid, i-1, j)
    self.dfs(grid, i, j+1)
    self.dfs(grid, i, j-1)
</code></pre></div>