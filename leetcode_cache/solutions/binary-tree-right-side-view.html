<div class='cpp-solution'><h2>Solution -- Votes: 226</h2><div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span>
<span class="n">class</span><span class="w"> </span><span class="n">Solution</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ans</span><span class="p">;</span>
<span class="w">        </span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="w">        </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="w">            </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">temp</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">Language</span><span class="p">:</span> <span class="n">Python3</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rightSideView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> 

        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> 
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">child_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">child_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">child_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

                <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">child_queue</span>

        <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">Java</span><span class="w"> </span>
<span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">maxlevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">right</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">list</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">right</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="p">){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">maxlevel</span><span class="o">&lt;</span><span class="n">level</span><span class="p">){</span>
<span class="w">            </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">val</span><span class="p">);</span>
<span class="w">            </span><span class="n">maxlevel</span><span class="o">=</span><span class="n">level</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">right</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">right</span><span class="p">,</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">list</span><span class="p">);</span>
<span class="w">        </span><span class="n">right</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="na">left</span><span class="p">,</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">list</span><span class="p">);</span>

<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


<div class='python-solution'><h2>5-9 Lines Python, 48+ ms -- Votes: 311</h2><p>Solution 1: <strong>Recursive, combine right and left:</strong> 5 lines, 56 ms</p>
<p>Compute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span><span class="w"> </span><span class="nv">rightSideView</span><span class="ss">(</span><span class="nv">self</span>,<span class="w"> </span><span class="nv">root</span><span class="ss">)</span>:
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">root</span>:
<span class="w">        </span><span class="k">return</span><span class="w"> </span>
<span class="w">    </span><span class="nv">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">self</span>.<span class="nv">rightSideView</span><span class="ss">(</span><span class="nv">root</span>.<span class="nv">right</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">self</span>.<span class="nv">rightSideView</span><span class="ss">(</span><span class="nv">root</span>.<span class="nv">left</span><span class="ss">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>[<span class="nv">root</span>.<span class="nv">val</span>]<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">left</span>[<span class="nv">len</span><span class="ss">(</span><span class="nv">right</span><span class="ss">)</span>:]
</code></pre></div>

<hr />
<p>Solution 2: <strong>Recursive, first come first serve:</strong> 9 lines, 48 ms</p>
<p>DFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n).</p>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span><span class="w"> </span><span class="nv">rightSideView</span><span class="ss">(</span><span class="nv">self</span>,<span class="w"> </span><span class="nv">root</span><span class="ss">)</span>:
<span class="w">    </span><span class="nv">def</span><span class="w"> </span><span class="nv">collect</span><span class="ss">(</span><span class="nv">node</span>,<span class="w"> </span><span class="nv">depth</span><span class="ss">)</span>:
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">node</span>:
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">len</span><span class="ss">(</span><span class="nv">view</span><span class="ss">)</span>:
<span class="w">                </span><span class="nv">view</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">node</span>.<span class="nv">val</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">collect</span><span class="ss">(</span><span class="nv">node</span>.<span class="nv">right</span>,<span class="w"> </span><span class="nv">depth</span><span class="o">+</span><span class="mi">1</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">collect</span><span class="ss">(</span><span class="nv">node</span>.<span class="nv">left</span>,<span class="w"> </span><span class="nv">depth</span><span class="o">+</span><span class="mi">1</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="nv">collect</span><span class="ss">(</span><span class="nv">root</span>,<span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">view</span>
</code></pre></div>

<hr />
<p>Solution 3: <strong>Iterative, level-by-level:</strong> 7 lines, 48 ms</p>
<p>Traverse the tree level by level and add the last value of each level to the view. This is O(n).</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">rightSideView</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nl">root</span><span class="p">:</span>
<span class="w">        </span><span class="k">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">root</span><span class="o">]</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="k">level</span><span class="err">:</span>
<span class="w">            </span><span class="k">view</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">level</span><span class="o">[</span><span class="n">-1</span><span class="o">]</span><span class="p">.</span><span class="n">val</span><span class="p">,</span>
<span class="w">            </span><span class="k">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">kid for node in level for kid in (node.left, node.right) if kid</span><span class="o">]</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">view</span>
</code></pre></div></div><p style="page-break-before: always" ></p>