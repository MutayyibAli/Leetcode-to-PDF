<div class='cpp-solution'><h4>Solution [Votes: 226]</h4><pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt;ans;
        queue&lt;TreeNode*&gt; q;
        if(root==NULL)
        return ans;
        q.push(root);
        while(1)
        {
            int size=q.size();
            if(size==0)
            return ans;
            vector&lt;int&gt; data;
            while(size--)
            {
                TreeNode* temp=q.front();
                q.pop();
                data.push_back(temp-&gt;val);
                if(temp-&gt;left!=NULL)
                q.push(temp-&gt;left);
                if(temp-&gt;right!=NULL)
                q.push(temp-&gt;right);
            }
            ans.push_back(data.back());
        }
    }
};
</code></pre>
<pre><code class="language-Python3">from collections import deque
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:
        queue = deque()
        if root is None:
            return []

        if root.left is None and root.right is None:
            return [root.val]

        result = []
        queue.append(root)
        while queue:
            child_queue = deque()
            prev = -1
            while queue:
                curr = queue.popleft()

                if curr.left is not None:
                    child_queue.append(curr.left)

                if curr.right is not None:
                    child_queue.append(curr.right)

                prev = curr

            result.append(prev.val)
            queue = child_queue

        return result
</code></pre>
<pre><code class="language-Java">class Solution {
    int maxlevel = 0;
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; list  = new ArrayList&lt;&gt;();
        right(root,1,list);
        return list ;
    }
    void right(TreeNode root,int level,List&lt;Integer&gt; list){
        if(root==null){
            return ;
        }
        if(maxlevel&lt;level){
            list.add(root.val);
            maxlevel=level;
        }
        right(root.right,level+1,list);
        right(root.left,level+1,list);

    }
}
</code></pre></div><div class='python-solution'><h4>5-9 Lines Python, 48+ ms [Votes: 311]</h4><p>Solution 1: <strong>Recursive, combine right and left:</strong> 5 lines, 56 ms</p>
<p>Compute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though.</p>
<pre><code>def rightSideView(self, root):
    if not root:
        return []
    right = self.rightSideView(root.right)
    left = self.rightSideView(root.left)
    return [root.val] + right + left[len(right):]
</code></pre>
<p>Solution 2: <strong>Recursive, first come first serve:</strong> 9 lines, 48 ms</p>
<p>DFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n).</p>
<pre><code>def rightSideView(self, root):
    def collect(node, depth):
        if node:
            if depth == len(view):
                view.append(node.val)
            collect(node.right, depth+1)
            collect(node.left, depth+1)
    view = []
    collect(root, 0)
    return view
</code></pre>
<p>Solution 3: <strong>Iterative, level-by-level:</strong> 7 lines, 48 ms</p>
<p>Traverse the tree level by level and add the last value of each level to the view. This is O(n).</p>
<pre><code>def rightSideView(self, root):
    view = []
    if root:
        level = [root]
        while level:
            view += level[-1].val,
            level = [kid for node in level for kid in (node.left, node.right) if kid]
    return view
</code></pre></div>