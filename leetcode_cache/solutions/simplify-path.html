<div class='cpp-solution'><h4>‚úÖ C++ || Easy || Stack || Simple || Explained || Algorithm [Votes: 722]</h4><h4>71. Simplify Path</h4>
<p><strong>KNOCKCAT</strong></p>
<p>Please ALso have a look to my Leetcode Repository Link Given Below :)</p>
<pre><code>1. Easy cpp
2. Line by Line Explanation with Comments.
3. Detailed Explanation ‚úÖ
4. Stack Problem with Initution.
5. Please Upvote if it helps‚¨ÜÔ∏è
6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. ‚¨áÔ∏è
    // If you Like the repository don't foget to star &amp; fork the repository
</code></pre>
<p><code></code>
<a href="https://github.com/knockcat/Leetcode">LeetCode</a>     <strong>LINK TO LEETCODE REPOSITORY</strong></p>
<p>Please upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.
<strong>Happy new Year 2023 to all of you</strong>
<strong>keep solving keep improving</strong>
Link To comment
<a href="https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919">Leetcode Give away comment</a>
<code></code></p>
<p><strong>EXPLANATION</strong>
* Create a <strong>Stack of String</strong> with following condition.
    * <strong>Iterate the loop till you doesn't reaches the end of string.</strong>
    * If you <strong>encounter a  "/" then ignore it.</strong>
    * <strong>Create a temp String</strong> &amp; <strong>Iterate the while loop</strong> till you <strong>doesn't find  "/"</strong> and <strong>append it to temp</strong>.
    * Now check if <strong>temp  == "."</strong> , t<strong>hen ignore it</strong>.
    * If <strong>temp == ".."</strong> then <strong>pop the element from the stack if it exists.</strong>
    * If <strong>no of the above 2 matches</strong> <strong>push temp to stack</strong> as you find a valid path.
    * <strong>Check out temp</strong> string on <strong>basis of above conditions till you doesn't find "/".</strong>
*   Now <strong>add all stack elements</strong> to result as <strong>res = "/" + st.top() + res</strong>
*   If <strong>res.size() is 0</strong> then <strong>return "/"</strong>  if no directory or file is present.
*   At last <strong>return res</strong>.</p>
<pre><code>Input: path = &quot;/../&quot;
Output: &quot;/&quot;
Input: path = &quot;/home//foo/&quot;
Output: &quot;/home/foo&quot;
</code></pre>
<p><strong>ALGORITHM</strong>
* By looking at examples we can see that the above <strong>simplification process</strong> just <strong>behaves like a stack</strong>.
* <strong>Whenever we encounter any file‚Äôs name</strong>, <strong>we simply push it into the stack</strong>.
* when we come across <strong>‚Äù . ‚Äù</strong> <strong>we do nothing</strong>
* When <strong>we find ‚Äú..‚Äù</strong> in our path, <strong>we simply pop the topmost element</strong> as we <strong>have to jump back to parent‚Äôs directory.</strong>
* When we <strong>see multiple ‚Äú////‚Äù</strong> we <strong>just ignore them</strong> as <strong>they are equivalent to one single ‚Äú/‚Äù.</strong> 
* After <strong>iterating through the whole string</strong> the <strong>elements remaining in the stack</strong> is our <strong>simplified absolute path.</strong></p>
<p><code></code>
<strong>CODE WITH EXPLANATION</strong></p>
<pre><code>                    // Please upvote if it helps 
class Solution {
public:
    string simplifyPath(string path) {

        stack&lt;string&gt; st;
        string res;

        for(int i = 0;  i&lt;path.size(); ++i)
        {
            if(path[i] == '/')    
                continue;
            string temp;
            // iterate till we doesn't traverse the whole string and doesn't encounter the last /
            while(i &lt; path.size() &amp;&amp; path[i] != '/')
            {
                // add path to temp string
                temp += path[i];
                ++i;
            }
            if(temp == &quot;.&quot;)
                continue;
            // pop the top element from stack if exists
            else if(temp == &quot;..&quot;)
            {
                if(!st.empty())
                    st.pop();
            }
            else
            // push the directory file name to stack
                st.push(temp);
        }

        // adding all the stack elements to res
        while(!st.empty())
        {
            res = &quot;/&quot; + st.top() + res;
            st.pop();
        }

        // if no directory or file is present
        if(res.size() == 0)
            return &quot;/&quot;;

        return res;
    }
};
</code></pre></div><div class='python-solution'><h4>‚úîÔ∏è‚úîÔ∏èEasy Solutions in Java ‚úîÔ∏è‚úîÔ∏è, Python ‚úîÔ∏è, and C++ ‚úîÔ∏èüßêLook at once üíª with Exaplanation [Votes: 194]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>The problem requires to convert a given absolute path to a simplified canonical path. The simplified canonical path should have the following format:
- The path starts with a single slash '/'.</p>
<ul>
<li>
<p>Any two directories are separated by a single slash '/'.</p>
</li>
<li>
<p>The path does not end with a trailing '/'.</p>
</li>
<li>
<p>The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..').</p>
</li>
</ul>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>The problem can be solved using a stack to keep track of the directories in the path. We split the input path by slash '/', iterate over the directories, and perform the following operations:</p>
<ul>
<li>Ignore the current directory '.' and empty directories.</li>
<li>Go one level up for double period '..' by popping the top element from the stack if it is not empty.</li>
<li>For any other directory, push it to the stack.</li>
<li>Finally, we join the directories in the stack with slash '/' and add a slash at the beginning to form the simplified canonical path.</li>
</ul>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>The time complexity of the algorithm is $$O(n)$$, where n is the length of the input path. This is because we iterate over each directory in the path only once.</p>
<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>The space complexity of the algorithm is $$O(n)$$ where n is the length of</p>
<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution. Keep Learning
Please give my solution an upvote! 
It's a simple way to show your appreciation and
keep me motivated. Thank you! 
</code></pre>
<h4>Code</h4>
<pre><code class="language-Java">class Solution {
    public String simplifyPath(String path) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;(); // create a stack to keep track of directories
        String[] directories = path.split(&quot;/&quot;); // split the path by slash '/'
        for (String dir : directories) { // iterate over the directories
            if (dir.equals(&quot;.&quot;) || dir.isEmpty()) { // ignore the current directory '.' and empty directories
                continue;
            } else if (dir.equals(&quot;..&quot;)) { // go one level up for double period '..'
                if (!stack.isEmpty()) { // if stack is not empty, pop the top element
                    stack.pop();
                }
            } else { // for any other directory, push it to the stack
                stack.push(dir);
            }
        }
        return &quot;/&quot; + String.join(&quot;/&quot;, stack); // join the directories in the stack with slash '/' and add a slash at the beginning
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    const stack = [];
    const directories = path.split(&quot;/&quot;);
    for (const dir of directories) {
        if (dir === &quot;.&quot; || !dir) {
            continue;
        } else if (dir === &quot;..&quot;) {
            if (stack.length &gt; 0) {
                stack.pop();
            }
        } else {
            stack.push(dir);
        }
    }
    return &quot;/&quot; + stack.join(&quot;/&quot;);
};

</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    string simplifyPath(string path) {
        stack&lt;string&gt; s;
        stringstream ss(path);
        string dir;
        while (getline(ss, dir, '/')) {
            if (dir.empty() || dir == &quot;.&quot;) {
                continue;
            } else if (dir == &quot;..&quot;) {
                if (!s.empty()) {
                    s.pop();
                }
            } else {
                s.push(dir);
            }
        }
        string res;
        while (!s.empty()) {
            res = &quot;/&quot; + s.top() + res;
            s.pop();
        }
        return res.empty() ? &quot;/&quot; : res;
    }
};

</code></pre>
<pre><code class="language-Python">class Solution(object):
    def simplifyPath(self, path):
        stack = []
        directories = path.split(&quot;/&quot;)
        for dir in directories:
            if dir == &quot;.&quot; or not dir:
                continue
            elif dir == &quot;..&quot;:
                if stack:
                    stack.pop()
            else:
                stack.append(dir)
        return &quot;/&quot; + &quot;/&quot;.join(stack)

</code></pre>
<h4>Please Comment</h4>
<pre><code>Thanks for visiting my solution comment below if you like it.
</code></pre></div>