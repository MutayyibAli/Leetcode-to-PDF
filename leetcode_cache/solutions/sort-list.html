<div class='cpp-solution'><h2>[Python/C/C++/Java] Legit iterative solutions. O(1) space! No recursion! With detailed explaination -- Votes: 443</h2><h2><strong>TL;DR</strong></h2>
<h4><strong>Short and sweet. O(nlogn) time, O(1) space.</strong></h4>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
  <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">dummy</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

  <span class="c1"># Grab sublists of size 1, then 2, then 4, etc, until fully merged</span>
  <span class="n">steps</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># Record the progress of the current pass into a single semi sorted list by updating</span>
    <span class="c1"># the next of the previous node (or the dummy on the first loop)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">dummy</span>

    <span class="c1"># Keep track of how much is left to process on this pass of the list</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span>

    <span class="c1"># While the current pass though the list has not been completed</span>
    <span class="n">num_loops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">remaining</span><span class="p">:</span>
      <span class="n">num_loops</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="c1"># Split 2 sublists of steps length from the front</span>
      <span class="n">sublists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
      <span class="n">sublists_tail</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="n">substeps</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">while</span> <span class="n">substeps</span> <span class="ow">and</span> <span class="n">remaining</span><span class="p">:</span>
          <span class="n">substeps</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
          <span class="n">remaining</span> <span class="o">=</span> <span class="n">remaining</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># Ensure the subslist (if one was made) is terminated</span>
        <span class="k">if</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

      <span class="c1"># We have two sublists of (upto) length step that are sorted, merge them onto </span>
      <span class="c1"># the end into a single list of (upto) step * 2</span>
      <span class="k">while</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
          <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span>

      <span class="c1"># One list has been finished, attach what ever is left of the other to the end</span>
      <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Double the steps each go around</span>
    <span class="n">steps</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="c1"># If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">num_loops</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">){</span>
<span class="w">  </span><span class="cm">/* Grab sublists of size 1, then 2, then 4, etc, until fully merged */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Keep track of how much is left to process on this pass of the list */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="cm">    of the previous node (or the head on the first loop)</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Split 2 sublists of steps length from the front */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* Ensure the subslist (if one was made) is terminated */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span><span class="w">   </span>

<span class="w">      </span><span class="cm">/* One list has been finished, attach what ever is left of the other to the end */</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Grab sublists of size 1, then 2, then 4, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split 2 sublists of steps length from the front</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">};</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span><span class="w">   </span>

<span class="w">      </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">ListNode</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w"> </span><span class="n">dummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then 2, then 4, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating</span>
<span class="w">    </span><span class="c1">// the next of the previous node (or the dummy on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split 2 sublists of steps length from the front</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w">   </span>

<span class="w">      </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4><strong>Using a holding buffer for extra speed. O(nlogn) time, O(1) space, with lower constant.</strong></h4>
<p>Code is a little more complex, can make a big performance difference. See desciption below.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
  <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">8</span>

  <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">dummy</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

  <span class="c1"># Grab sublists of size 1, then buffer_size, then buffer_size^2, etc, until fully merged</span>
  <span class="n">steps</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># Record the progress of the current pass into a single semi sorted list by updating</span>
    <span class="c1"># the next of the previous node (or the dummy on the first loop)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">dummy</span>

    <span class="c1"># Keep track of how much is left to process on this pass of the list</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span>

    <span class="c1"># While the current pass though the list has not been completed</span>
    <span class="n">num_loops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">remaining</span><span class="p">:</span>
      <span class="n">num_loops</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="c1"># Split buffer_size sublists of upto steps length from the front</span>
      <span class="n">sublists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">buffer_size</span>
      <span class="n">sublists_tail</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">buffer_size</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">):</span>
        <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="n">substeps</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">while</span> <span class="n">substeps</span> <span class="ow">and</span> <span class="n">remaining</span><span class="p">:</span>
          <span class="n">substeps</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
          <span class="n">remaining</span> <span class="o">=</span> <span class="n">remaining</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># Ensure the subslist (if one was made) is terminated</span>
        <span class="k">if</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

      <span class="c1"># Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
      <span class="c1"># That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
      <span class="n">num_sublists</span> <span class="o">=</span> <span class="n">buffer_size</span>
      <span class="k">while</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">num_sublists</span><span class="p">:</span>
        <span class="c1"># Merge each pair of sublists</span>
        <span class="n">subdummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_sublists</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
          <span class="n">subprev</span> <span class="o">=</span> <span class="n">subdummy</span><span class="p">;</span>
          <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

          <span class="c1"># We have two sublists of (upto) length step that are sorted, merge them onto </span>
          <span class="c1"># the end into a single list of (upto) step * 2</span>
          <span class="k">while</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
              <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
              <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
              <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
            <span class="n">subprev</span> <span class="o">=</span> <span class="n">subprev</span><span class="o">.</span><span class="n">next</span>

          <span class="c1"># One list has been finished, attach what ever is left of the other to the end</span>
          <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

          <span class="c1"># Record the head of our new longer sublist in the correct location for the next loop around</span>
          <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdummy</span><span class="o">.</span><span class="n">next</span><span class="p">;</span>

        <span class="c1"># Half the sublists remain now that we have merged each pair of lists</span>
        <span class="n">num_sublists</span> <span class="o">//=</span> <span class="mi">2</span>

      <span class="c1"># Attach the single sublist into this passes progress</span>
      <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="c1"># Increase the steps each go around</span>
    <span class="n">steps</span> <span class="o">*=</span> <span class="n">buffer_size</span>

    <span class="c1"># If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">num_loops</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">){</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Grab sublists of size 1, then 2, then 4, etc, until fully merged */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Keep track of how much is left to process on this pass of the list */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="cm">    of the previous node (or the head on the first loop)</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Split BUFFER_SIZE sublists of upto steps length from the front */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* Ensure the subslist (if one was made) is terminated */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="cm">      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="cm">      */</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Merge each pair of sublists */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">subhead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">          </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subhead</span><span class="p">;</span>

<span class="w">          </span><span class="cm">/* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="cm">/* One list has been finished, attach what ever is left of the other to the end */</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="cm">/* Record the head of our new longer sublist in the correct location for the next loop around */</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subhead</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* Attach the single sublist into this passes progress */</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split BUFFER_SIZE sublists of upto steps length from the front</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="w">      </span><span class="c1">// That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Merge each pair of sublists</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">subhead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">          </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subhead</span><span class="p">;</span>

<span class="w">          </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// Record the head of our new longer sublist in the correct location for the next loop around</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subhead</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Attach the single sublist into this passes progress</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">java</span><span class="w"> </span>
<span class="kd">public</span><span class="w"> </span><span class="n">ListNode</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="n">ListNode</span><span class="w"> </span><span class="n">dummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w"> </span><span class="n">subdummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="n">BUFFER_SIZE</span><span class="o">]</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="n">BUFFER_SIZE</span><span class="o">]</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating</span>
<span class="w">    </span><span class="c1">// the next of the previous node (or the dummy on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split BUFFER_SIZE sublists of upto steps length from the front</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="w">      </span><span class="c1">// That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Merge each pair of sublists</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">ListNode</span><span class="w"> </span><span class="n">subprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subdummy</span><span class="p">;</span>
<span class="w">          </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="w">          </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">subprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// Record the head of our new longer sublist in the correct location for the next loop around</span>
<span class="w">          </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subdummy</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Attach the single sublist into this passes progress</span>
<span class="w">      </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">      </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4><strong>Using a holding buffer for extra speed. O(nlogn) time, O(1) space, with lower constant. Using subfunctions</strong></h4>
<p>Same idea as the holding buffer above, but using subfunctions to <code>split_list</code> to extract the sublists and <code>merge_lists</code> for the merge step. It might help demonstrate the main loop better.</p>
<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="c1">/// Take a list and split it into sublists of the requested size, return the remainder of the input list</span>
<span class="k">static</span>
<span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">lists_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_lists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_lists</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lists_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Ensure the subslist (if one was made) is terminated */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Merge two sorted lists into one, the head and tail of the new list is returned</span>
<span class="k">static</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">merge_lists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l1</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">l2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="p">;</span>
<span class="w">      </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="p">;</span>
<span class="w">      </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">    </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split BUFFER_SIZE sublists of upto steps length from the front</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span><span class="w"> </span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="n">sublists</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="w">      </span><span class="c1">// That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Merge each pair of sublists</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">subhead</span><span class="p">,</span><span class="w"> </span><span class="n">subtail</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge_lists</span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>

<span class="w">          </span><span class="c1">// Record the head of our new longer sublist in the correct location for the next loop around</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subhead</span><span class="p">;</span>
<span class="w">          </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtail</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Attach the single sublist into this passes progress</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span>

<span class="cm">/* Take a list and split it into sublists of the requested size, return the remainder of the input list */</span>
<span class="k">static</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">lists_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_lists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_lists</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lists_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* Ensure the subslist (if one was made) is terminated */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Merge two sorted lists into one, the head and tail of the new list is returned */</span>
<span class="k">static</span>
<span class="kt">void</span><span class="w"> </span><span class="n">merge_lists</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l1</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l2</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">head_out</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">tail_out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">l2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="p">;</span>
<span class="w">      </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="p">;</span>
<span class="w">      </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">    </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">*</span><span class="n">head_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">tail_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Split BUFFER_SIZE sublists of upto steps length from the front */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span><span class="w"> </span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="n">sublists</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">);</span>

<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="cm">      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="cm">      */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Merge each pair of sublists */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">merge_lists</span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* Attach the single sublist into this passes progress */</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4><strong>Short quicksort for fun. O(nlogn) time, O(logn) stack space.</strong></h4>
<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Use head node as the pivot node</span>
<span class="w">      </span><span class="c1">// Everything in the _smaller_ list will be less than _head_</span>
<span class="w">      </span><span class="c1">// and everything appearing after _head_ in the list is greater or equal</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="w">          </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">smaller_next</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Remove smaller node from original list</span>
<span class="w">          </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// Correct position, skip over</span>
<span class="w">          </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Connect the end of smaller list to the head (which is the partition node)</span>
<span class="w">      </span><span class="c1">// We now have. [smaller list...] -&gt; head -&gt; [larger list]</span>
<span class="w">      </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">      </span><span class="c1">// Continue to sort everything after head</span>
<span class="w">      </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Sort everything upto head</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">smaller</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>

<h2>Details</h2>
<h4><strong>Basic description</strong></h4>
<p>The problem calls for O(1) space. Therefore a solution that does not use recursion is required. Quicksort is out, merge sort is in.<br />
The idea is to merge progressively larger sublists together until the resulting list is sorted. A walkthough will help explain.</p>
<p>Imagine the input list [3, 45, 2, 15, 37, 19, 39, 20], first process the list as sublists of length <em>1</em>, [3], [45], [2], [15], [37], [19], [39], [20]. As they are size <em>1</em>, they are obviously sorted sublists. Merge each pair of sublists together to produce 4 sorted sublists of size <em>2</em> [3, 45], [2, 15], [19, 37], [20, 39], these are reassemble into the original list to produce [3, 45, 2, 15, 19, 37, 20, 39]. After this pass first pass, every 2 nodes is sorted. That is 3 is before 45, 2 is before 15, 19 is before 37, etc. Increasing the step size to <em>2</em> and repeat. This produces the following table;<br />
|Progress|Step size|Sublists|Merged|<br />
|---|---|---|---|<br />
|[3, 45, 2, 15, 37, 19, 39, 20]|1|[3], [45], [2], [15], [37], [19], [39], [20]|[3, 45], [2, 15], [19, 37], [20, 39]|<br />
|[3, 45, 2, 15, 19, 37, 20, 39]|2|[3, 45], [2, 15], [19, 37], [20, 39]|[2, 3, 15, 45], [19, 20, 37, 39]|<br />
|[2, 3, 15, 45, 19, 20, 37, 39]|4|[2, 3, 15, 45], [19, 20, 37, 39]|[2, 3, 15, 19, 20, 37, 39, 45]|</p>
<p>Since recursion is out, the process must be done inplace as we go. Basically for each pass;</p>
<ol>
<li>Grab two sorted lists of size <em>step</em></li>
<li>Merge the two lists into a single sorted list of size <em>step * 2</em> and reattach to input list</li>
<li>Repeat from step 1. until entire list has been sorted (which will be when step * 2 &gt;= length)</li>
</ol>
<p>This produces the first relatively compact solution shown above.</p>
<h4><strong>Complexity</strong></h4>
<h5><strong>Space complexity</strong></h5>
<p>There are only a few fixed, stack allocated, variables whose creation is not based on the length of the input list and there is no recursion. Therefore it is O(1) space complexity.</p>
<h5><strong>Time complexity</strong></h5>
<p>The list will be completely sorted once <em>step</em> * 2 becomes greater than <em>n</em>, with <em>step</em> doubling each pass (1, 2, 4, 8, ...). Therefore it will take logn passes to sort the list. Each pass though requires <em>n</em> moves to produce the sublists and the merge of two sorted lists takes <em>step</em> moves for <em>n/step</em> sublists. Therefore it takes <em>n</em> time for each of the logn passes. Therefore the time complexity is O(nlogn).</p>
<h4><strong>Improvements</strong></h4>
<p>In practice, in the real world no one would implement the initial solution as is, instead it would be improved substansually (without impacting space complexity), by using a small holding buffer. Allowing for larger sorted sublists to be created with each full pass of the list. This is the second solution presented above.</p>
<p>Consider the first solution, the output of each pass produces the input of the next pass. For example, the first pass, when <em>step</em> is 1, produces sublists of <em>step * 2</em>, which is exactly what is needed for the next pass. However, there is nowhere to hold this in O(1) space so we must reassemble the list fully ready for the next pass. However, with a small working buffer we can leaverage this and focus on sorting blocks of nodes. By that I mean, we grab <em>buf_sz</em> sublists, and keep merging them together until we have a single, sorted, sublist in our holding buffer. The sublist is then linked back into the input list before progressing onto the next set of <em>buf_sz</em> sublists.</p>
<p>With a working buffer of 4, using the input [6, 38, 25, 46, 45, 90, 97, 52, 75, 18] an initial pass would progress as follows;<br />
|Progress|State 1, grab 4 sublists of <em>step</em> size (1)|State 2, merge into 2 sublists|State 3, merge into 1 sublist|<br />
|---|---|---|---|<br />
|[6, 38, 25, 46, 45, 90, 97, 52, 75, 18]|[6], [38], [25], [46], [45, 90, 97, 52, 75, 18]|[6, 38], [25, 46], [45, 90, 97, 52, 75, 18]|[6, 25, 38, 46], [45, 90, 97, 52, 75, 18]|<br />
|[6, 25, 38, 46, 45, 90, 97, 52, 75, 18]|[6, 25, 38, 46], [45], [90], [97], [52], [75, 18]|[6, 25, 38, 46], [45, 90], [52, 97], [75, 18]|[6, 25, 38, 46], [45, 52, 90, 97], [75, 18]|<br />
|[6, 25, 38, 46, 45, 52, 90, 97, 75, 18]|[6, 25, 38, 46, 45, 52, 90, 97], [75], [18]|[6, 25, 38, 46, 45, 52, 90, 97], [18, 75]|[6, 25, 38, 46, 45, 52, 90, 97], [18, 75]|</p>
<p>The end of the list has been reached, so <em>step</em> is increased, but this time, instead of doubling, it is multiplied by 4, as we now know every 4 nodes forms a sorted sublist. The next pass then becomes;</p>
<table>
<thead>
<tr>
<th>Progress</th>
<th>State 1, grab 4 sublists of <em>step</em> size (4)</th>
<th>State 2, merge into 2 sublists</th>
<th>State 3, merge into 1 sublist</th>
</tr>
</thead>
<tbody>
<tr>
<td>[6, 25, 38, 46, 45, 52, 90, 97, 18, 75]</td>
<td>[6, 25, 38, 46], [45, 52, 90, 97], [18, 75]</td>
<td>[6, 25, 38, 45, 46, 52, 90, 97], [18, 75]</td>
<td>[6, 18, 25, 38, 45, 46, 52, 75, 90, 97]</td>
</tr>
</tbody>
</table>
<p>Finished!<br />
Increasing the buffer to 8 or 16 makes a huge difference as we will be sorting blocks of nodes as follows;<br />
|Buffer size|Pass 1|Pass 2|Pass 3|<br />
|---|---|---|---|<br />
|2|2|4|8|<br />
|4|4|16|64|<br />
|8|8|64|512|<br />
|16|16|256|4096|</p>
<p>So after 3 passes of the list, with a buffer size of 8, we will have divided the input list into sorted sublists of size 512. Where as with buffer size of 2, we will only have sublists of size 8. Making processing a huge lists considerably faster.</p>
<h3><strong>Quicksort</strong></h3>
<p>I added the quicksort solution for fun as it is quite compact, even if it doesn't fullfil the requirements of O(1) space. It does of course suffer from the normal problems of quicksort, that being a worst case of O(n^2) if the input list is already sorted.</p>
<p>Basically, grab the <em>head</em> of the list and use it as a pivot. Then using code adopted from <a href="https://leetcode.com/problems/partition-list/discuss/155293/Short-single-pass-iterative-c++-solution.-No-allocation-or-dummy-required.-O(n)-time-O(1)-space">partition list</a>, divide into two sublists, those nodes less than <em>head-&gt;val</em> and those greater or equal. Recurse around, partitioning those lists around a new pivot. Rince and repeat until each sublist is down to a size of 1 and is hence sorted.</p>
<p>I did it more for fun as the code is really small. Without comments it is;</p>
<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="w">          </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">smaller_next</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>
<span class="w">          </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">      </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">);</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">smaller</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>

<p><strong>Please give me a thumbs up if this helped explain this problem for you</strong></p></div>


<div class='python-solution'><h2>[Python/C/C++/Java] Legit iterative solutions. O(1) space! No recursion! With detailed explaination -- Votes: 443</h2><h2><strong>TL;DR</strong></h2>
<h4><strong>Short and sweet. O(nlogn) time, O(1) space.</strong></h4>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
  <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">dummy</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

  <span class="c1"># Grab sublists of size 1, then 2, then 4, etc, until fully merged</span>
  <span class="n">steps</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># Record the progress of the current pass into a single semi sorted list by updating</span>
    <span class="c1"># the next of the previous node (or the dummy on the first loop)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">dummy</span>

    <span class="c1"># Keep track of how much is left to process on this pass of the list</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span>

    <span class="c1"># While the current pass though the list has not been completed</span>
    <span class="n">num_loops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">remaining</span><span class="p">:</span>
      <span class="n">num_loops</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="c1"># Split 2 sublists of steps length from the front</span>
      <span class="n">sublists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
      <span class="n">sublists_tail</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="n">substeps</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">while</span> <span class="n">substeps</span> <span class="ow">and</span> <span class="n">remaining</span><span class="p">:</span>
          <span class="n">substeps</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
          <span class="n">remaining</span> <span class="o">=</span> <span class="n">remaining</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># Ensure the subslist (if one was made) is terminated</span>
        <span class="k">if</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

      <span class="c1"># We have two sublists of (upto) length step that are sorted, merge them onto </span>
      <span class="c1"># the end into a single list of (upto) step * 2</span>
      <span class="k">while</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
          <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span>

      <span class="c1"># One list has been finished, attach what ever is left of the other to the end</span>
      <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Double the steps each go around</span>
    <span class="n">steps</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="c1"># If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">num_loops</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">){</span>
<span class="w">  </span><span class="cm">/* Grab sublists of size 1, then 2, then 4, etc, until fully merged */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Keep track of how much is left to process on this pass of the list */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="cm">    of the previous node (or the head on the first loop)</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Split 2 sublists of steps length from the front */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* Ensure the subslist (if one was made) is terminated */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span><span class="w">   </span>

<span class="w">      </span><span class="cm">/* One list has been finished, attach what ever is left of the other to the end */</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Grab sublists of size 1, then 2, then 4, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split 2 sublists of steps length from the front</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">};</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span><span class="w">   </span>

<span class="w">      </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="n">ListNode</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w"> </span><span class="n">dummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then 2, then 4, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating</span>
<span class="w">    </span><span class="c1">// the next of the previous node (or the dummy on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split 2 sublists of steps length from the front</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w">   </span>

<span class="w">      </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4><strong>Using a holding buffer for extra speed. O(nlogn) time, O(1) space, with lower constant.</strong></h4>
<p>Code is a little more complex, can make a big performance difference. See desciption below.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
  <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">8</span>

  <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">dummy</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>

  <span class="c1"># Grab sublists of size 1, then buffer_size, then buffer_size^2, etc, until fully merged</span>
  <span class="n">steps</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="c1"># Record the progress of the current pass into a single semi sorted list by updating</span>
    <span class="c1"># the next of the previous node (or the dummy on the first loop)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">dummy</span>

    <span class="c1"># Keep track of how much is left to process on this pass of the list</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">next</span>

    <span class="c1"># While the current pass though the list has not been completed</span>
    <span class="n">num_loops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">remaining</span><span class="p">:</span>
      <span class="n">num_loops</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="c1"># Split buffer_size sublists of upto steps length from the front</span>
      <span class="n">sublists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">buffer_size</span>
      <span class="n">sublists_tail</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">buffer_size</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">):</span>
        <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="n">substeps</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">while</span> <span class="n">substeps</span> <span class="ow">and</span> <span class="n">remaining</span><span class="p">:</span>
          <span class="n">substeps</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span>
          <span class="n">remaining</span> <span class="o">=</span> <span class="n">remaining</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># Ensure the subslist (if one was made) is terminated</span>
        <span class="k">if</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
          <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

      <span class="c1"># Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
      <span class="c1"># That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
      <span class="n">num_sublists</span> <span class="o">=</span> <span class="n">buffer_size</span>
      <span class="k">while</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">num_sublists</span><span class="p">:</span>
        <span class="c1"># Merge each pair of sublists</span>
        <span class="n">subdummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_sublists</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
          <span class="n">subprev</span> <span class="o">=</span> <span class="n">subdummy</span><span class="p">;</span>
          <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

          <span class="c1"># We have two sublists of (upto) length step that are sorted, merge them onto </span>
          <span class="c1"># the end into a single list of (upto) step * 2</span>
          <span class="k">while</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
              <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
              <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
              <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">next</span>
            <span class="n">subprev</span> <span class="o">=</span> <span class="n">subprev</span><span class="o">.</span><span class="n">next</span>

          <span class="c1"># One list has been finished, attach what ever is left of the other to the end</span>
          <span class="k">if</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">subprev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

          <span class="c1"># Record the head of our new longer sublist in the correct location for the next loop around</span>
          <span class="n">sublists</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdummy</span><span class="o">.</span><span class="n">next</span><span class="p">;</span>

        <span class="c1"># Half the sublists remain now that we have merged each pair of lists</span>
        <span class="n">num_sublists</span> <span class="o">//=</span> <span class="mi">2</span>

      <span class="c1"># Attach the single sublist into this passes progress</span>
      <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="c1"># Increase the steps each go around</span>
    <span class="n">steps</span> <span class="o">*=</span> <span class="n">buffer_size</span>

    <span class="c1"># If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">num_loops</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">){</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Grab sublists of size 1, then 2, then 4, etc, until fully merged */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Keep track of how much is left to process on this pass of the list */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="cm">    of the previous node (or the head on the first loop)</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Split BUFFER_SIZE sublists of upto steps length from the front */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* Ensure the subslist (if one was made) is terminated */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="cm">      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="cm">      */</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Merge each pair of sublists */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">subhead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">          </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subhead</span><span class="p">;</span>

<span class="w">          </span><span class="cm">/* We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2 */</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="cm">/* One list has been finished, attach what ever is left of the other to the end */</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="cm">/* Record the head of our new longer sublist in the correct location for the next loop around */</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subhead</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* Attach the single sublist into this passes progress */</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split BUFFER_SIZE sublists of upto steps length from the front</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="w">      </span><span class="c1">// That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Merge each pair of sublists</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">subhead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">          </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subhead</span><span class="p">;</span>

<span class="w">          </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">              </span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">sub_next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// Record the head of our new longer sublist in the correct location for the next loop around</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subhead</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Attach the single sublist into this passes progress</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">java</span><span class="w"> </span>
<span class="kd">public</span><span class="w"> </span><span class="n">ListNode</span><span class="w"> </span><span class="nf">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="n">ListNode</span><span class="w"> </span><span class="n">dummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w"> </span><span class="n">subdummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="n">BUFFER_SIZE</span><span class="o">]</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="w">  </span><span class="n">sublists_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="o">[</span><span class="n">BUFFER_SIZE</span><span class="o">]</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating</span>
<span class="w">    </span><span class="c1">// the next of the previous node (or the dummy on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split BUFFER_SIZE sublists of upto steps length from the front</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">        </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span>
<span class="w">          </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remaining</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Ensure the subslist (if one was made) is terminated</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="w">      </span><span class="c1">// That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Merge each pair of sublists</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">ListNode</span><span class="w"> </span><span class="n">subprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subdummy</span><span class="p">;</span>
<span class="w">          </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="w">          </span><span class="c1">// We have two sublists of (upto) length step that are sorted, merge them onto the end into a single list of (upto) step * 2</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">              </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">subprev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// One list has been finished, attach what ever is left of the other to the end</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">subprev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">          </span><span class="c1">// Record the head of our new longer sublist in the correct location for the next loop around</span>
<span class="w">          </span><span class="n">sublists</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subdummy</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Attach the single sublist into this passes progress</span>
<span class="w">      </span><span class="n">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">      </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists_tail</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">dummy</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4><strong>Using a holding buffer for extra speed. O(nlogn) time, O(1) space, with lower constant. Using subfunctions</strong></h4>
<p>Same idea as the holding buffer above, but using subfunctions to <code>split_list</code> to extract the sublists and <code>merge_lists</code> for the merge step. It might help demonstrate the main loop better.</p>
<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="c1">/// Take a list and split it into sublists of the requested size, return the remainder of the input list</span>
<span class="k">static</span>
<span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">lists_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_lists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_lists</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lists_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Ensure the subslist (if one was made) is terminated */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Merge two sorted lists into one, the head and tail of the new list is returned</span>
<span class="k">static</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">merge_lists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l1</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">l2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="p">;</span>
<span class="w">      </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="p">;</span>
<span class="w">      </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">    </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Split BUFFER_SIZE sublists of upto steps length from the front</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span><span class="w"> </span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="n">sublists</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="w">      </span><span class="c1">// That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Merge each pair of sublists</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">subhead</span><span class="p">,</span><span class="w"> </span><span class="n">subtail</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">merge_lists</span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>

<span class="w">          </span><span class="c1">// Record the head of our new longer sublist in the correct location for the next loop around</span>
<span class="w">          </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subhead</span><span class="p">;</span>
<span class="w">          </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtail</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Attach the single sublist into this passes progress</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span>

<span class="cm">/* Take a list and split it into sublists of the requested size, return the remainder of the input list */</span>
<span class="k">static</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">lists_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_lists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_lists</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lists_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* Ensure the subslist (if one was made) is terminated */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Merge two sorted lists into one, the head and tail of the new list is returned */</span>
<span class="k">static</span>
<span class="kt">void</span><span class="w"> </span><span class="n">merge_lists</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l1</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">l2</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">head_out</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">tail_out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">l2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="p">;</span>
<span class="w">      </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="p">;</span>
<span class="w">      </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">    </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">*</span><span class="n">head_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">tail_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged */</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;;</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Keep track of how much is left to process on this pass of the list</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Record the progress of the current pass into a single semi sorted list by updating the next pointer</span>
<span class="w">    </span><span class="c1">// of the previous node (or the head on the first loop)</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_loops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">remaining</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Split BUFFER_SIZE sublists of upto steps length from the front */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="w">      </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">split_list</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span><span class="w"> </span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="n">sublists</span><span class="p">,</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">);</span>

<span class="w">      </span><span class="cm">/*</span>
<span class="cm">      Keep merging all the sublists we have in the working buffer until we have a single sublist.</span>
<span class="cm">      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.</span>
<span class="cm">      */</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">num_sublists</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Merge each pair of sublists */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sublists</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">merge_lists</span><span class="p">(</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sublists</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="cm">/* Attach the single sublist into this passes progress */</span>
<span class="w">      </span><span class="o">*</span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sublists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">      </span><span class="n">next_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* If the entire list was fully processed in a single loop, it means we&#39;ve completely sorted the list and are done */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_loops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h4><strong>Short quicksort for fun. O(nlogn) time, O(logn) stack space.</strong></h4>
<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Use head node as the pivot node</span>
<span class="w">      </span><span class="c1">// Everything in the _smaller_ list will be less than _head_</span>
<span class="w">      </span><span class="c1">// and everything appearing after _head_ in the list is greater or equal</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="w">          </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">smaller_next</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>

<span class="w">          </span><span class="c1">// Remove smaller node from original list</span>
<span class="w">          </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// Correct position, skip over</span>
<span class="w">          </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// Connect the end of smaller list to the head (which is the partition node)</span>
<span class="w">      </span><span class="c1">// We now have. [smaller list...] -&gt; head -&gt; [larger list]</span>
<span class="w">      </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">      </span><span class="c1">// Continue to sort everything after head</span>
<span class="w">      </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Sort everything upto head</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">smaller</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>

<h2>Details</h2>
<h4><strong>Basic description</strong></h4>
<p>The problem calls for O(1) space. Therefore a solution that does not use recursion is required. Quicksort is out, merge sort is in.<br />
The idea is to merge progressively larger sublists together until the resulting list is sorted. A walkthough will help explain.</p>
<p>Imagine the input list [3, 45, 2, 15, 37, 19, 39, 20], first process the list as sublists of length <em>1</em>, [3], [45], [2], [15], [37], [19], [39], [20]. As they are size <em>1</em>, they are obviously sorted sublists. Merge each pair of sublists together to produce 4 sorted sublists of size <em>2</em> [3, 45], [2, 15], [19, 37], [20, 39], these are reassemble into the original list to produce [3, 45, 2, 15, 19, 37, 20, 39]. After this pass first pass, every 2 nodes is sorted. That is 3 is before 45, 2 is before 15, 19 is before 37, etc. Increasing the step size to <em>2</em> and repeat. This produces the following table;<br />
|Progress|Step size|Sublists|Merged|<br />
|---|---|---|---|<br />
|[3, 45, 2, 15, 37, 19, 39, 20]|1|[3], [45], [2], [15], [37], [19], [39], [20]|[3, 45], [2, 15], [19, 37], [20, 39]|<br />
|[3, 45, 2, 15, 19, 37, 20, 39]|2|[3, 45], [2, 15], [19, 37], [20, 39]|[2, 3, 15, 45], [19, 20, 37, 39]|<br />
|[2, 3, 15, 45, 19, 20, 37, 39]|4|[2, 3, 15, 45], [19, 20, 37, 39]|[2, 3, 15, 19, 20, 37, 39, 45]|</p>
<p>Since recursion is out, the process must be done inplace as we go. Basically for each pass;</p>
<ol>
<li>Grab two sorted lists of size <em>step</em></li>
<li>Merge the two lists into a single sorted list of size <em>step * 2</em> and reattach to input list</li>
<li>Repeat from step 1. until entire list has been sorted (which will be when step * 2 &gt;= length)</li>
</ol>
<p>This produces the first relatively compact solution shown above.</p>
<h4><strong>Complexity</strong></h4>
<h5><strong>Space complexity</strong></h5>
<p>There are only a few fixed, stack allocated, variables whose creation is not based on the length of the input list and there is no recursion. Therefore it is O(1) space complexity.</p>
<h5><strong>Time complexity</strong></h5>
<p>The list will be completely sorted once <em>step</em> * 2 becomes greater than <em>n</em>, with <em>step</em> doubling each pass (1, 2, 4, 8, ...). Therefore it will take logn passes to sort the list. Each pass though requires <em>n</em> moves to produce the sublists and the merge of two sorted lists takes <em>step</em> moves for <em>n/step</em> sublists. Therefore it takes <em>n</em> time for each of the logn passes. Therefore the time complexity is O(nlogn).</p>
<h4><strong>Improvements</strong></h4>
<p>In practice, in the real world no one would implement the initial solution as is, instead it would be improved substansually (without impacting space complexity), by using a small holding buffer. Allowing for larger sorted sublists to be created with each full pass of the list. This is the second solution presented above.</p>
<p>Consider the first solution, the output of each pass produces the input of the next pass. For example, the first pass, when <em>step</em> is 1, produces sublists of <em>step * 2</em>, which is exactly what is needed for the next pass. However, there is nowhere to hold this in O(1) space so we must reassemble the list fully ready for the next pass. However, with a small working buffer we can leaverage this and focus on sorting blocks of nodes. By that I mean, we grab <em>buf_sz</em> sublists, and keep merging them together until we have a single, sorted, sublist in our holding buffer. The sublist is then linked back into the input list before progressing onto the next set of <em>buf_sz</em> sublists.</p>
<p>With a working buffer of 4, using the input [6, 38, 25, 46, 45, 90, 97, 52, 75, 18] an initial pass would progress as follows;<br />
|Progress|State 1, grab 4 sublists of <em>step</em> size (1)|State 2, merge into 2 sublists|State 3, merge into 1 sublist|<br />
|---|---|---|---|<br />
|[6, 38, 25, 46, 45, 90, 97, 52, 75, 18]|[6], [38], [25], [46], [45, 90, 97, 52, 75, 18]|[6, 38], [25, 46], [45, 90, 97, 52, 75, 18]|[6, 25, 38, 46], [45, 90, 97, 52, 75, 18]|<br />
|[6, 25, 38, 46, 45, 90, 97, 52, 75, 18]|[6, 25, 38, 46], [45], [90], [97], [52], [75, 18]|[6, 25, 38, 46], [45, 90], [52, 97], [75, 18]|[6, 25, 38, 46], [45, 52, 90, 97], [75, 18]|<br />
|[6, 25, 38, 46, 45, 52, 90, 97, 75, 18]|[6, 25, 38, 46, 45, 52, 90, 97], [75], [18]|[6, 25, 38, 46, 45, 52, 90, 97], [18, 75]|[6, 25, 38, 46, 45, 52, 90, 97], [18, 75]|</p>
<p>The end of the list has been reached, so <em>step</em> is increased, but this time, instead of doubling, it is multiplied by 4, as we now know every 4 nodes forms a sorted sublist. The next pass then becomes;</p>
<table>
<thead>
<tr>
<th>Progress</th>
<th>State 1, grab 4 sublists of <em>step</em> size (4)</th>
<th>State 2, merge into 2 sublists</th>
<th>State 3, merge into 1 sublist</th>
</tr>
</thead>
<tbody>
<tr>
<td>[6, 25, 38, 46, 45, 52, 90, 97, 18, 75]</td>
<td>[6, 25, 38, 46], [45, 52, 90, 97], [18, 75]</td>
<td>[6, 25, 38, 45, 46, 52, 90, 97], [18, 75]</td>
<td>[6, 18, 25, 38, 45, 46, 52, 75, 90, 97]</td>
</tr>
</tbody>
</table>
<p>Finished!<br />
Increasing the buffer to 8 or 16 makes a huge difference as we will be sorting blocks of nodes as follows;<br />
|Buffer size|Pass 1|Pass 2|Pass 3|<br />
|---|---|---|---|<br />
|2|2|4|8|<br />
|4|4|16|64|<br />
|8|8|64|512|<br />
|16|16|256|4096|</p>
<p>So after 3 passes of the list, with a buffer size of 8, we will have divided the input list into sorted sublists of size 512. Where as with buffer size of 2, we will only have sublists of size 8. Making processing a huge lists considerably faster.</p>
<h3><strong>Quicksort</strong></h3>
<p>I added the quicksort solution for fun as it is quite compact, even if it doesn't fullfil the requirements of O(1) space. It does of course suffer from the normal problems of quicksort, that being a worst case of O(n^2) if the input list is already sorted.</p>
<p>Basically, grab the <em>head</em> of the list and use it as a pivot. Then using code adopted from <a href="https://leetcode.com/problems/partition-list/discuss/155293/Short-single-pass-iterative-c++-solution.-No-allocation-or-dummy-required.-O(n)-time-O(1)-space">partition list</a>, divide into two sublists, those nodes less than <em>head-&gt;val</em> and those greater or equal. Recurse around, partitioning those lists around a new pivot. Rince and repeat until each sublist is down to a size of 1 and is hence sorted.</p>
<p>I did it more for fun as the code is really small. Without comments it is;</p>
<div class="codehilite"><pre><span></span><code><span class="nl">Language</span><span class="p">:</span><span class="w"> </span><span class="n">cpp</span><span class="w"> </span>
<span class="w">  </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smaller</span><span class="p">;</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="w">          </span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">smaller_next</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>
<span class="w">          </span><span class="o">*</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">**</span><span class="n">prev</span><span class="p">).</span><span class="n">next</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="o">*</span><span class="n">smaller_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">      </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">);</span>
<span class="w">      </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sortList</span><span class="p">(</span><span class="n">smaller</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>

<p><strong>Please give me a thumbs up if this helped explain this problem for you</strong></p></div><p style="page-break-before: always" ></p>