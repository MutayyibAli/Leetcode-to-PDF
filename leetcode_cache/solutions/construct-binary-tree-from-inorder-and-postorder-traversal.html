<div class='cpp-solution'><h4>üî•Easy Solutions in Java üìù, Python üêç, and C++ üñ•Ô∏èüßêLook at once üíª [Votes: 295]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>To construct a binary tree from inorder and postorder traversal arrays, we first need to understand what each of these traversals represents.
Inorder traversal visits the nodes in ascending order of their values, i.e., left child, parent, and right child. On the other hand, postorder traversal visits the nodes in the order left child, right child, and parent.
Knowing this, we can say that the last element in the postorder array is the root node, and its index in the inorder array divides the tree into left and right subtrees. We can recursively apply this logic to construct the entire binary tree.</p>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<ol>
<li>Start with the last element of the postorder array as the root node.</li>
<li>Find the index of the root node in the inorder array.</li>
<li>Divide the inorder array into left and right subtrees based on the index of the root node.</li>
<li>Divide the postorder array into left and right subtrees based on the number of elements
in the left and right subtrees of the inorder array.</li>
<li>Recursively construct the left and right subtrees.</li>
</ol>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity:
The time complexity of this algorithm is O(n), where n is the number of nodes in the tree. We visit each node only once.</p>
</li>
<li>
<p>Space complexity:
The space complexity of this algorithm is O(n). We create a hashmap to store the indices of the inorder traversal, which takes O(n) space. Additionally, the recursive call stack can go up to O(n) in the worst case if the binary tree is skewed.</p>
</li>
</ul>
<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution. Keep Learning
Please give my solution an upvote! 
It's a simple way to show your appreciation and
keep me motivated. Thank you! 
</code></pre>
<h4>Code</h4>
<pre><code class="language-Java">lass Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        // Call the recursive function with full arrays and return the result
        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {
        // Base case
        if (inStart &gt; inEnd || postStart &gt; postEnd) {
            return null;
        }

        // Find the root node from the last element of postorder traversal
        int rootVal = postorder[postEnd];
        TreeNode root = new TreeNode(rootVal);

        // Find the index of the root node in inorder traversal
        int rootIndex = 0;
        for (int i = inStart; i &lt;= inEnd; i++) {
            if (inorder[i] == rootVal) {
                rootIndex = i;
                break;
            }
        }

        // Recursively build the left and right subtrees
        int leftSize = rootIndex - inStart;
        int rightSize = inEnd - rootIndex;
        root.left = buildTree(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1);
        root.right = buildTree(inorder, rootIndex + 1, inEnd, postorder, postEnd - rightSize, postEnd - 1);

        return root;
    }
}


</code></pre>
<pre><code class="language-Python">class Solution(object):
    def buildTree(self, inorder, postorder):
        &quot;&quot;&quot;
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        &quot;&quot;&quot;
        #### Base case
        if not inorder:
            return None

        #### The last element of postorder list is the root
        root_val = postorder.pop()
        root = TreeNode(root_val)

        #### Find the position of the root in the inorder list
        inorder_index = inorder.index(root_val)

        #### Recursively build the left and right subtrees
        root.right = self.buildTree(inorder[inorder_index+1:], postorder)
        root.left = self.buildTree(inorder[:inorder_index], postorder)

        return root

</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        unordered_map&lt;int, int&gt; index;
        for (int i = 0; i &lt; inorder.size(); i++) {
            index[inorder[i]] = i;
        }
        return buildTreeHelper(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1, index);
    }

    TreeNode* buildTreeHelper(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd, unordered_map&lt;int, int&gt;&amp; index) {
        if (inorderStart &gt; inorderEnd || postorderStart &gt; postorderEnd) {
            return nullptr;
        }
        int rootVal = postorder[postorderEnd];
        TreeNode* root = new TreeNode(rootVal);
        int inorderRootIndex = index[rootVal];
        int leftSubtreeSize = inorderRootIndex - inorderStart;
        root-&gt;left = buildTreeHelper(inorder, postorder, inorderStart, inorderRootIndex - 1, postorderStart, postorderStart + leftSubtreeSize - 1, index);
        root-&gt;right = buildTreeHelper(inorder, postorder, inorderRootIndex + 1, inorderEnd, postorderStart + leftSubtreeSize, postorderEnd - 1, index);
        return root;
    }
};


</code></pre>
<h4>Please Comment</h4>
<pre><code>Thanks for visiting my solution comment below if you like it.
</code></pre></div>