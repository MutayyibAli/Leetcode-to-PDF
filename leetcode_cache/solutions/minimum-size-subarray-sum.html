<div class='cpp-solution'><h4>C++ O(n) and O(nlogn) [Votes: 448]</h4><p>The <code>O(n)</code> solution is to use two pointers: <code>l</code> and <code>r</code>. First we move <code>r</code> until we get a <code>sum  &gt;= s</code>, then we move <code>l</code> to the right until <code>sum &lt; s</code>. In this process, store the minimum length between <code>l</code> and <code>r</code>. Since each element in <code>nums</code> will be visited by <code>l</code> and <code>r</code> for at most once. This algorithm is of <code>O(n)</code> time.</p>
<pre><code class="language-cpp">class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        int l = 0, r = 0, n = nums.size(), sum = 0, len = INT_MAX;
        while (r &lt; n) {
            sum += nums[r++];
            while (sum &gt;= s) {
                len = min(len, r - l);
                sum -= nums[l++];
            }
        }
        return len == INT_MAX ? 0 : len;
    }
};
</code></pre>
<p>Then comes the <code>O(nlogn)</code> solution. This less efficient one turns out to be more difficult to come up with.</p>
<p>First, we maintain an array of accumulated sums of elements in <code>nums</code> according to the following two equations.</p>
<ol>
<li><code>sums[0] = 0</code></li>
<li><code>sums[i] = nums[0] + ... + nums[i - 1]</code> for <code>i &gt; 0</code></li>
</ol>
<p>Then, for each <code>sums[i] &gt;= s</code>, we search for the first <code>sums[j] &gt; sums[i] - s (j &lt; i)</code> using binary search. In this case, we also have <code>sums[j - 1] &lt;= sums[i] - s</code>. If we plug in the definition for <code>sums</code>, we have</p>
<ul>
<li><code>nums[0] + ... + nums[j - 1] &gt; nums[0] + ... + nums[j - 1] + nums[j] + ... + nums[i - 1] - s</code></li>
<li><code>nums[0] + ... + nums[j - 2] &lt;= nums[0] + ... + nums[j - 2] + nums[j - 1] + ... + nums[i - 1] - s</code></li>
</ul>
<p>If we minus the left-hand side from both inequalities, we have</p>
<ul>
<li><code>0 &gt; nums[j] + ... + nums[i - 1] - s</code></li>
<li><code>0 &lt;= nums[j - 1] + ... + nums[i - 1] - s</code></li>
</ul>
<p>So, we have <code>nums[j - 1] + ... + nums[i - 1] &gt;= s</code> but <code>nums[j] + ... + nums[i - 1] &lt; s</code>. So <code>nums[j-1..i-1]</code> is the shortest subarray with sum not less than <code>s</code> <strong>ending at <code>i - 1</code></strong>. After traversing all possible <code>i</code>, we will find out the shortest subarray with sum not less than <code>s</code>.</p>
<p>By the way, a <code>0</code> is added to the head of <code>sums</code> to account for cases like <code>nums = [3], s = 3</code>.</p>
<pre><code class="language-cpp">class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        int n = nums.size(), len = INT_MAX;
        vector&lt;int&gt; sums(n + 1, 0);
        for (int i = 1; i &lt;= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = n; i &gt;= 0 &amp;&amp; sums[i] &gt;= s; i--) {
            int j = upper_bound(sums.begin(), sums.end(), sums[i] - s) - sums.begin();
            len = min(len, i - j + 1);
        }
        return len == INT_MAX ? 0 : len;
    }
};
</code></pre></div><div class='python-solution'><h4>2 Approaches |100% fast | Binary Serarch & Sliding Window  | Easy Line by Line + Video Explanation [Votes: 176]</h4><h4>Approach</h4>
<p>For detailed explanation you can refer to my youtube channel (Hindi Language)
https://youtu.be/0tZ-9dIAY_Q
 or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.
or
search <code>Minimum size subarray sum by Let's Code Together</code> on youtube</p>
<h4>Sliding Window Approach</h4>
<ol>
<li>Initialize two pointers, <code>i</code> and <code>j</code>, to track the start and end of the current subarray, respectively. Set <code>i</code> and <code>j</code> to 0 initially.</li>
<li>Initialize a variable <code>sum</code> to keep track of the current sum of elements in the subarray.</li>
<li>Initialize a variable <code>mn</code> to store the minimum length found so far. Set it to the maximum possible integer value (<code>INT_MAX</code>).</li>
<li>Start a while loop that continues until the <code>j</code> pointer reaches the end of the array <code>nums</code>.</li>
<li>Inside the loop, add the element at index <code>j</code> to the <code>sum</code> variable.</li>
<li>Check if the <code>sum</code> is greater than or equal to the target value.</li>
<li>If the condition is true, enter another while loop. This loop will handle the case where the current subarray sum is equal to or greater than the target.
   a. Decrement the <code>sum</code> by subtracting the element at index <code>i</code>.
   b. Update <code>mn</code> with the minimum length found so far (<code>j - i + 1</code>).
   c. Increment the <code>i</code> pointer to move the window to the right.
   d. Repeat steps a-c until the <code>sum</code> is no longer greater than or equal to the target value.</li>
<li>Increment the <code>j</code> pointer to move the window to the right.</li>
<li>Repeat steps 5-8 until the <code>j</code> pointer reaches the end of the array.</li>
<li>After the loop, check if the value of <code>mn</code> is still <code>INT_MAX</code>, indicating that no subarray was found. In this case, return 0.</li>
<li>Otherwise, return the value of <code>mn</code>, which represents the minimum length of a subarray whose sum is greater than or equal to the target.</li>
</ol>
<p>The sliding window technique allows us to efficiently search for the minimum length subarray that satisfies the given condition. By maintaining two pointers and adjusting the window based on the sum of elements, we can avoid unnecessary computations and achieve a time complexity of O(N), where N is the size of the input array <code>nums</code>.</p>
<h4>Code1 Sliding Window</h4>
<pre><code>class Solution {
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        int i=0;
        int j=0;
        int sum=0;
        int mn=INT_MAX;
        while(j&lt;nums.size()){
            sum+=nums[j];
            while(sum&gt;=target){
                sum-=nums[i];
                mn=min(j-i+1,mn);
                i++;
            }
            j++;
        }
        if(mn==INT_MAX){
            return 0;
        }
        return mn;
    }
};
</code></pre>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $$O(n)$$  </li>
<li>Space complexity: O(1)</li>
</ul>
<h4>Code2 Binary Search</h4>
<h4>Binary Search Approach</h4>
<ol>
<li>The <code>windowfind</code> function checks if there exists a subarray of a given size whose sum is greater than or equal to the target.</li>
<li>It uses the sliding window technique to iterate through the array and maintain a window of the specified size.</li>
<li>If the sum of the elements in the window is greater than or equal to the target, it returns <code>true</code>.</li>
<li>Otherwise, it returns <code>false</code>.</li>
</ol>
<p>The <code>minSubArrayLen</code> function finds the minimum length of a subarray whose sum is greater than or equal to the target using binary search.
1. It initializes a range from 1 to the size of the input array.
2. It repeatedly divides the range in half and checks if a subarray of the mid-point length satisfies the condition using the <code>windowfind</code> function.
3. If a valid subarray is found, it updates the upper bound of the range to mid-1 and stores the mid-point length as the minimum length found so far.
4. If a valid subarray is not found, it updates the lower bound of the range to mid+1.
5. The search continues until the lower bound is no longer less than or equal to the upper bound.
6. Finally, it returns the minimum length of the subarray.</p>
<p>The code efficiently utilizes the sliding window technique and binary search to find the minimum length subarray satisfying the given condition.</p>
<pre><code>class Solution {
public:
      bool windowfind(int size, vector&lt;int&gt;&amp;nums, int target) {
        int sum = 0;
        int i=0;
        int j=0;
        int mx=INT_MIN;
        int n=nums.size();
        while(j&lt;n){
            sum+=nums[j];
            if(j-i+1==size){
              mx=max(sum,mx);
              sum-=nums[i];
              i++;
            }
            j++;
        }
        if(mx&gt;=target)
        return true;
        return false;
    }

    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        int low = 1, high = nums.size(), mn = 0;
        while (low &lt;= high) {
            int mid = (low + high) / 2;
            if (windowfind(mid, nums, target)) {
                high = mid-1;
                mn = mid;
            } else low = mid + 1;
        }
        return mn;
    }
};
</code></pre>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $$O(n logn)$$ </li>
<li>Space complexity: O(1)</li>
</ul>
<p>Please Upvote </p></div>