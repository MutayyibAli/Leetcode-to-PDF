<div class='cpp-solution'><h4>PythonðŸ”¥JavaðŸ”¥C++ðŸ”¥Simple SolutionðŸ”¥Easy to Understand [Votes: 31]</h4><h4>An Upvote will be encouraging</h4>
<h4>Video Solution</h4>
<h4>Search <code>Maximum Level Sum of a Binary Tree By Tech Wired</code></h4>
<h4>or</h4>
<h4>Click the Link in my Profile</h4>
<pre><code class="language-Python">class Solution:
    def maxLevelSum(self, root):
        if not root:
            return 0

        queue = [root]
        max_level = 1
        max_sum = float('-inf')
        level = 1

        while queue:
            level_sum = 0
            next_level = []

            for node in queue:
                level_sum += node.val

                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)

            if level_sum &gt; max_sum:
                max_sum = level_sum
                max_level = level

            queue = next_level
            level += 1

        return max_level

</code></pre>
<pre><code class="language-Java">class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    public int maxLevelSum(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        int maxLevel = 1;
        int maxSum = Integer.MIN_VALUE;
        int level = 1;

        while (!queue.isEmpty()) {
            int levelSum = 0;
            int levelSize = queue.size();

            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode node = queue.poll();
                levelSum += node.val;

                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }

            if (levelSum &gt; maxSum) {
                maxSum = levelSum;
                maxLevel = level;
            }

            level++;
        }

        return maxLevel;
    }
}

</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }

        std::queue&lt;TreeNode*&gt; queue;
        queue.push(root);
        int maxLevel = 1;
        int maxSum = INT_MIN;
        int level = 1;

        while (!queue.empty()) {
            int levelSum = 0;
            int levelSize = queue.size();

            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode* node = queue.front();
                queue.pop();
                levelSum += node-&gt;val;

                if (node-&gt;left != nullptr) {
                    queue.push(node-&gt;left);
                }
                if (node-&gt;right != nullptr) {
                    queue.push(node-&gt;right);
                }
            }

            if (levelSum &gt; maxSum) {
                maxSum = levelSum;
                maxLevel = level;
            }

            level++;
        }

        return maxLevel;
    }
};

</code></pre>
<h4>An Upvote will be encouraging</h4></div><div class='python-solution'><h4>[Java/Python 3] Two codes / language: BFS level traversal and DFS level sum. [Votes: 105]</h4><p><strong>Method 1: BFS</strong></p>
<p>Use BFS to find the sum of each level, then locate the level with largest sum.</p>
<pre><code class="language-java">    public int maxLevelSum(TreeNode root) {
        int max = Integer.MIN_VALUE, maxLevel = 1;
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
        q.offer(root);
        for (int level = 1; !q.isEmpty(); ++level) {
            int sum = 0;
            for (int sz = q.size(); sz &gt; 0; --sz) {
                TreeNode n = q.poll();
                sum += n.val;
                if (n.left != null) { 
                    q.offer(n.left);
                }
                if (n.right != null) {
                    q.offer(n.right);
                }
            }
            if (max &lt; sum) {
                max = sum;
                maxLevel = level;
            }
        }
        return maxLevel;
    }
</code></pre>
<pre><code class="language-python">    def maxLevelSum(self, root: TreeNode) -&gt; int:
        max, level, maxLevel = -float('inf'), 0, 0
        q = collections.deque()
        q.append(root)
        while q:
            level += 1
            sum = 0
            for _ in range(len(q)):
                node = q.popleft()
                sum += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if max &lt; sum:
                max, maxLevel = sum, level        
        return maxLevel
</code></pre>
<p>Python 3 BFS code - credit to <strong>@leihao1313</strong></p>
<pre><code class="language-python">    def maxLevelSum(self, root: TreeNode) -&gt; int:
        ans, q, depth = (-math.inf, 0), [root], -1
        while q:
            ans = max(ans, (sum(node.val for node in q), depth))
            q = [kid for node in q for kid in (node.left, node.right) if kid]
            depth -= 1
        return -ans[1]
</code></pre>
<hr />
<p><strong>Method 2: DFS</strong>
Use DFS to compute and store the sum of each level in an ArrayList, then locate the level with largest sum.
1. Recurse down from root, level of which is 0, increase level by 1 for each recursion down;
2. Use the level as the index of an ArrayList to store the sum of the correspoinding level;
3. Find the index of the max sum, then plus 1.</p>
<p><strong>Java</strong></p>
<pre><code>    public int maxLevelSum(TreeNode root) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        dfs(root, list, 0);
        return 1 + IntStream.range(0, list.size()).reduce(0, (a, b) -&gt; list.get(a) &lt; list.get(b) ? b : a);
    }
    private void dfs(TreeNode n, List&lt;Integer&gt; l, int level) {
        if (n == null) { return; } 
        if (l.size() == level) { l.add(n.val); } // never reach this level before, add first value.
        else { l.set(level, l.get(level) + n.val); } // reached the level before, accumulate current value to old value.
        dfs(n.left, l, level + 1);
        dfs(n.right, l, level + 1);
    }
</code></pre>
<p>In case you are NOT comfortable with the Java 8 stream in the return statement, it can be written as:</p>
<pre><code>        int maxLevel = 0;
        for (int i = 0; i &lt; list.size(); ++i) {
            if (list.get(maxLevel) &lt; list.get(i)) {
                maxLevel = i;
            }
        }
        return maxLevel + 1;
</code></pre>
<p>-
<strong>Python 3</strong></p>
<pre><code>    def maxLevelSum(self, root: TreeNode) -&gt; int:
        def dfs(node: TreeNode, list: List, level: int) -&gt; None:
            if not node:
                return
            if len(list) == level:
                list.append(node.val)
            else:
                list[level] += node.val
            dfs(node.left, list, level + 1)
            dfs(node.right, list, level + 1)
        list = []    
        dfs(root, list, 0)
        return 1 + list.index(max(list))
</code></pre>
<p>-
<strong>Analysis:</strong></p>
<p>Time &amp; space: <code>O(n), n</code> is the number of total nodes.</p></div>