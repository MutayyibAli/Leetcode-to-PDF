<div class='cpp-solution'><h4>Easy Two-Map Solution (C++/Java) [Votes: 457]</h4><p>I think the following code is self-explanatory enough. We use an <code>unordered_map&lt;string, int&gt; counts</code> to record the expected times of each word and another <code>unordered_map&lt;string, int&gt; seen</code> to record the times we have seen. Then we check for every possible position of <code>i</code>. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push <code>i</code> to the result <code>indexes</code>.</p>
<ul>
<li>
<p>cpp</p>
<p>class Solution {
public:
    vector<int> findSubstring(string s, vector<string>&amp; words) {
        unordered_map<string, int> counts;
        for (string word : words)
            counts[word]++;
        int n = s.length(), num = words.size(), len = words[0].length();
        vector<int> indexes;
        for (int i = 0; i &lt; n - num * len + 1; i++) {
            unordered_map<string, int> seen;
            int j = 0;
            for (; j &lt; num; j++) {
                string word = s.substr(i + j * len, len);
                if (counts.find(word) != counts.end()) {
                    seen[word]++;
                    if (seen[word] &gt; counts[word])
                        break;
                } 
                else break;
            }
            if (j == num) indexes.push_back(i);
        }
        return indexes;
    }
};</p>
</li>
<li>
<p>Java</p>
</li>
</ul>
<pre><code>class Solution {
    public List&lt;Integer&gt; findSubstring(String s, String[] words) {
        final Map&lt;String, Integer&gt; counts = new HashMap&lt;&gt;();
        for (final String word : words) {
            counts.put(word, counts.getOrDefault(word, 0) + 1);
        }
        final List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();
        final int n = s.length(), num = words.length, len = words[0].length();
        for (int i = 0; i &lt; n - num * len + 1; i++) {
            final Map&lt;String, Integer&gt; seen = new HashMap&lt;&gt;();
            int j = 0;
            while (j &lt; num) {
                final String word = s.substring(i + j * len, i + (j + 1) * len);
                if (counts.containsKey(word)) {
                    seen.put(word, seen.getOrDefault(word, 0) + 1);
                    if (seen.get(word) &gt; counts.getOrDefault(word, 0)) {
                        break;
                    }
                } else {
                    break;
                }
                j++;
            }
            if (j == num) {
                indexes.add(i);
            }
        }
        return indexes;
    }
}
</code></pre></div><div class='python-solution'><h4>Python || Easily Understood âœ… || Faster than 96% || Less than 78% || O(nm) [Votes: 60]</h4><p>Method: <code>Hash Table</code></p>
<p>First we can create a <code>dict</code> to store the occurrence times for each word in <code>words</code>.</p>
<p>For example,
If <code>s = "barfoofoobarthefoobarman"</code> and <code>words = ["bar","foo","the"]</code>, 
the dict will be <code>word_count = {'bar': 1, 'foo': 1, 'the': 1}</code>,</p>
<p>Since all the strings stored in <code>words</code> have the same length, the size of <strong>sliding window</strong> will be the word length of a single string. In the example above, the <strong>sliding window</strong> will be <code>3</code></p>
<pre><code>bar -&gt; foo -&gt; foo -&gt; bar -&gt; the -&gt; foo -&gt; bar -&gt; man
ignore b -&gt; arf -&gt; oof -&gt; oob -&gt; art -&gt; hef -&gt; oob -&gt; arm -&gt; ignore an
ignore ba -&gt; rfo -&gt; ofo -&gt; oba -&gt; rth -&gt; efo -&gt; oba -&gt; rma -&gt; ignore n
</code></pre>
<p>Then, we can scan <code>s</code> in these 3 ways one by one</p>
<p>Let the word in <strong>sliding window</strong> be <code>word</code>.
Also, we will create a <code>queue</code> to store the scan history.</p>
<pre><code>1) word_count.get(word, 0) &gt;= 0 
    -&gt; word_count[word] -= 1 as it uses one of the string in words
    -&gt; queue.append(word)

2) word_count.get(word, 0) == 0 
    -&gt; while queue.pop()
        -&gt; queue.pop() == word
            -&gt; queue.append(queue.pop()) #### Only the beginning word is dropped, the remaining words are still in use
            -&gt; break
        -&gt; queue.pop() != word
            #### Since the beginning word is dropped, the count of beginning word should be added 1.
            -&gt; word_dict[last_element] += 1
                -&gt; word_dict[last_element] exceeds its original value, reset the whole word_dict
            -&gt; continue
</code></pre>
<p>Code:</p>
<pre><code>from collections import deque, defaultdict

class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        word_len = len(words[0])
        ori_word_dict = defaultdict(int)

        for word in words:
            ori_word_dict[word] += 1

        all_word_len = len(words) * word_len
        result = []
        for i in range(word_len):
            queue = deque()
            word_dict = ori_word_dict.copy()
            for j in range(i, len(s) - word_len + 1, word_len):
                word = s[j:j + word_len]
                if word_dict.get(word, 0) != 0:
                    word_dict[word] -= 1
                    queue.append(word)
                    if sum(word_dict.values()) == 0:
                        result.append(j - all_word_len + word_len)
                        last_element = queue.popleft()
                        word_dict[last_element] = word_dict.get(last_element, 0) + 1
                else:
                    while len(queue):
                        last_element = queue.popleft()
                        if last_element == word:
                            queue.append(word)
                            break
                        else:
                            word_dict[last_element] = word_dict.get(last_element, 0) + 1
                            if word_dict[last_element] &gt; ori_word_dict[last_element]:
                                word_dict = ori_word_dict.copy()

        return result
</code></pre>
<p>Let <code>n</code> be the length of a word in <code>words</code>
and <code>m</code> be the total number of words in <code>words</code></p>
<p><strong>Time complexity</strong>: <code>O(n * m)</code>
<strong>Space complexity</strong>: <code>O(n + m)</code>
<br/></p></div>