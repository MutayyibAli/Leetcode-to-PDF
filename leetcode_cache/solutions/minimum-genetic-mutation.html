<div class='cpp-solution'><h4>ðŸ”¥ [LeetCode The Hard Way] ðŸ”¥ Explained Line By Line [Votes: 53]</h4><p>Check out <a href="https://wingkwong.github.io/leetcode-the-hard-way/">LeetCode The Hard Way</a> for more solution explanations and tutorials. 
 Check out our <a href="https://discord.gg/Nqm4jJcyBf">Discord</a> for live discussion.
 Give a star on <a href="https://github.com/wingkwong/leetcode-the-hard-way">Github Repository</a> and upvote this post if you like it.</p>
<iframe src="https://leetcode.com/playground/aFX68kxW/shared" frameBorder="0" width="100%" height="500"></iframe>

<p>For most BFS problems, you should see the following pattern.</p>
<iframe src="https://leetcode.com/playground/Sb9vuTRo/shared" frameBorder="0" width="100%" height="500"></iframe>

<p>Another nice solution from @martin0327. Instead of actual mutating, we can check the difference between the current gene string and those in <code>bank</code>. Push the target one in <code>bank</code> to the queue if they are different by 1 character and increase the distance by 1.</p>
<pre><code>class Solution {
public:
  int minMutation(string start, string end, vector&lt;string&gt;&amp; b) {
    map&lt;string,int&gt; dist;
    dist[start] = 0;
    queue&lt;string&gt; q;
    q.push(start);
    while (q.size()) {
      auto u = q.front(); q.pop();
      for (auto v : b) {
        if (dist.count(v)) continue;
        int cnt = 0;
        for (int i = 0; i &lt; 8; i++) {
          if (u[i] != v[i]) cnt++;
        }
        if (cnt == 1) {
          dist[v] = dist[u] + 1;
          q.push(v);
        }
      }
    }
    if (dist.count(end)) return dist[end];
    else return -1;
  }
}; 
</code></pre></div><div class='python-solution'><h4>Python 3   ||    11 lines, w/example      ||   T/S : 93%/87% [Votes: 30]</h4><pre><code>class Solution:
    def minMutation(self, start: str, end: str, bank: list[str]) -&gt; int:

        queue, seen = deque([(start, 0)]), {start}      #### Ex: start = &quot;AACCGGTT&quot; ;    end = &quot;AAACGGTA&quot;
                                                        ####     bank  = [&quot;AACCGATT&quot;,&quot;AACCGATA&quot;,&quot;AAACGATA&quot;,&quot;AAACGGTA&quot;]
        while queue:
            s, n = queue.popleft()                      ####   n    queue             seen
                                                        ####  â€“â€“â€“  â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“  â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“ 
            if s == end: return n                       ####   0   [('AACCGGTA', 1)]  {'AACCGGTA', 'AACCGGTT'}
                                                        #
            for i in range(8):                          ####   1   [('AAACGGTA', 2),  {'AACCGGTA', 'AACCGGTT',
                for ch in 'ACGT':                       ####        ('AACCGCTA', 2)]   'AACCGCTA', 'AAACGGTA'}
                                                        ####                           
                    m = s[:i]+ch+s[i+1:]                ####   2                       'AACCGCTA', 'AAACGGTA'}
                                                        ####   |
                    if m in bank and m not in seen:     #### answer    
                        seen.add(m)
                        queue.append((m, n+1))
        return -1

</code></pre>
<p><a href="https://leetcode.com/problems/minimum-genetic-mutation/submissions/1270694058/">https://leetcode.com/problems/minimum-genetic-mutation/submissions/1270694058/</a></p>
<p>I could be wrong, but I think that time complexity is <em>O</em>(<em>N</em> Ã— 8 Ã— 4) ~ <em>O</em>(<em>N</em>) and space complexity is <em>O</em>(<em>N</em>), in which <em>N</em> ~ <code>len(bank)</code>.</p></div>