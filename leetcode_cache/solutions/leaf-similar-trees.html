<div class='cpp-solution'><h4>âœ…99.39%ðŸ”¥Easy SolutionðŸ”¥With ExplanationðŸ”¥ [Votes: 65]</h4><h4>Intuition</h4>
<h6># To solve this problem, we need to compare the leaf values of two binary trees. The idea is to perform a depth-first traversal of each tree and collect the leaf values in order. Once we have the leaf values for both trees, we can compare the sequences to check if they are similar.</h6>
<h4>Approach</h4>
<h6># 1. Define a <code>TreeNode</code> class to represent the nodes of the binary tree.</h6>
<h6># 2. Implement a <code>Solution</code> class with a <code>leafSimilar</code> method to check if the leaf sequences are similar.</h6>
<h6># 3. Define a recursive helper function <code>collect_leaf_values</code> that takes a tree node and a list to collect the leaf values.</h6>
<h6># 4. In the helper function, if the current node is a leaf (has no left or right child), add its value to the list.</h6>
<h6># 5. Recursively call the helper function for the left and right children of the current node.</h6>
<h6># 6. Create empty lists <code>leaf_values1</code> and <code>leaf_values2</code> to store the leaf values of the two trees.</h6>
<h6># 7. Use the helper function to collect leaf values for both trees.</h6>
<h6># 8. Compare the two lists to check if the leaf sequences are similar.</h6>
<h6># 9. Return the result.</h6>
<h4>Complexity</h4>
<ul>
<li>
<h5>Time complexity:</h5>
</li>
</ul>
<h6># $$O(n)$$, where $$n$$ is the total number of nodes in both trees. We visit each node once during the depth-first traversal.</h6>
<ul>
<li>
<h5>Space complexity:</h5>
</li>
</ul>
<h6># $$O(h1+h2)$$, where $$h1$$ and $$h2$$ are the heights of the two trees. The space complexity is determined by the recursion stack during the depth-first traversal.#### Code</h6>
<pre><code class="language-python">class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; bool:
        def collect_leaf_values(root, leaf_values):
            if not root:
                return
            if not root.left and not root.right:
                leaf_values.append(root.val)
            collect_leaf_values(root.left, leaf_values)
            collect_leaf_values(root.right, leaf_values)

        leaf_values1 = []
        leaf_values2 = []

        collect_leaf_values(root1, leaf_values1)
        collect_leaf_values(root2, leaf_values2)

        return leaf_values1 == leaf_values2
</code></pre>
<pre><code class="language-javascript">var leafSimilar = function(root1, root2) {
    const collectLeafValues = (root, leafValues) =&gt; {
        if (!root) {
            return;
        }
        if (!root.left &amp;&amp; !root.right) {
            leafValues.push(root.val);
        }
        collectLeafValues(root.left, leafValues);
        collectLeafValues(root.right, leafValues);
    };

    const leafValues1 = [];
    const leafValues2 = [];
    collectLeafValues(root1, leafValues1);
    collectLeafValues(root2, leafValues2);

    return JSON.stringify(leafValues1) === JSON.stringify(leafValues2);
};
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        function&lt;void(TreeNode*, vector&lt;int&gt;&amp;)&gt; collectLeafValues =
            [&amp;](TreeNode* root, vector&lt;int&gt;&amp; leafValues) {
                if (!root) {
                    return;
                }
                if (!root-&gt;left &amp;&amp; !root-&gt;right) {
                    leafValues.push_back(root-&gt;val);
                }
                collectLeafValues(root-&gt;left, leafValues);
                collectLeafValues(root-&gt;right, leafValues);
            };

        vector&lt;int&gt; leafValues1, leafValues2;
        collectLeafValues(root1, leafValues1);
        collectLeafValues(root2, leafValues2);

        return leafValues1 == leafValues2;
    }
};
</code></pre>
<pre><code class="language-java">public class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List&lt;Integer&gt; leafValues1 = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; leafValues2 = new ArrayList&lt;&gt;();

        collectLeafValues(root1, leafValues1);
        collectLeafValues(root2, leafValues2);

        return leafValues1.equals(leafValues2);
    }

    private void collectLeafValues(TreeNode root, List&lt;Integer&gt; leafValues) {
        if (root == null) {
            return;
        }
        if (root.left == null &amp;&amp; root.right == null) {
            leafValues.add(root.val);
        }
        collectLeafValues(root.left, leafValues);
        collectLeafValues(root.right, leafValues);
    }
}
</code></pre>
<pre><code class="language-C####">public class Solution {
    public bool LeafSimilar(TreeNode root1, TreeNode root2) {
        void CollectLeafValues(TreeNode root, List&lt;int&gt; leafValues) {
            if (root == null) {
                return;
            }
            if (root.left == null &amp;&amp; root.right == null) {
                leafValues.Add(root.val);
            }
            CollectLeafValues(root.left, leafValues);
            CollectLeafValues(root.right, leafValues);
        }

        List&lt;int&gt; leafValues1 = new List&lt;int&gt;();
        List&lt;int&gt; leafValues2 = new List&lt;int&gt;();
        CollectLeafValues(root1, leafValues1);
        CollectLeafValues(root2, leafValues2);

        return Enumerable.SequenceEqual(leafValues1, leafValues2);
    }
}
</code></pre></div><div class='python-solution'><h4>Python 3   ||   5 lines, recursion,  w/ example   ||   T/S: 97% / 90% [Votes: 77]</h4><p>Here's the plan: 
- For each tree, we traverse the tree left-to-right and record the values of the leaves into a list in the order encountered. 
- Return whether the two lists are identical.</p>
<pre><code>class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -&gt; bool:

        def dfs(root):                              ####     Example: 
                                                    ####         root1:         root2:
                                                    ####            ______3__             __3__
                                                    ####           /         \           /     \
                                                    ####          5__         1         5       1__
                                                    ####         /   \       / \       / \     /   \
                                                    ####       *6*    2    *9* *8*   *6* *7* *4*    2
                                                    ####             / \                           / \
                                                    ####           *7* *4*                       *9* *8*
                                                    ####   root1:
            if not root: return []                  ####       node      dfs(root.left)+dfs(root.right)
                                                    ####       â€“â€“â€“â€“      â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
            if not root.left and not root.right:    ####        2              [7] + [4]   = [7,4]
                return [root.val]                   ####        5              [6] + [7,4] = [6,7,4]
                                                    ####        1              [9] + [8]   = [9,8]
            return dfs(root.left) + dfs(root.right) ####        3          [6,7,4] + [9,8] = [6,7,4,9,8] &lt;--
                                                    #
        return dfs(root1) == dfs(root2)             ####   root2:
                                                    ####       node      dfs(root.left)+dfs(root.right)
                                                    ####       â€“â€“â€“â€“      â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
                                                    ####        5            [6] + [7]     = [6,7]
                                                    ####        2            [9] + [8]     = [9,8]
                                                    ####        1            [4] + [9,8]   = [4,9,8]
                                                    ####        3          [6,7] + [4,9,8] = [6,7,4,9,8] &lt;--

                                                    ####       Return True
</code></pre>
<p><a href="https://leetcode.com/problems/leaf-similar-trees/submissions/1272780528/">https://leetcode.com/problems/leaf-similar-trees/submissions/1272780528/</a></p>
<p>I could be wrong, but I think that time is, worst case, <em>O</em>(<em>N</em>) and space is <em>O</em>(<em>N</em>), in which <em>N</em> ~ <em>maxnodes</em>(<code>tree1</code>, <code>tree2</code>)</p></div>