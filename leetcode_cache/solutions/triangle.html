<div class='cpp-solution'><h4>Bottom Up 5 line C++ Solution [Votes: 93]</h4><pre><code>class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) 
    {
        vector&lt;int&gt; mini = triangle[triangle.size()-1];
        for ( int i = triangle.size() - 2; i&gt;= 0 ; --i )
            for ( int j = 0; j &lt; triangle[i].size() ; ++ j )
                mini[j] = triangle[i][j] + min(mini[j],mini[j+1]);
        return mini[0];
    }
};
</code></pre></div><div class='python-solution'><h4>✅ [C++/ Python] Simple Solution w/ Explanation | Recursion -> DP [Votes: 301]</h4><p>Given a triangle array, we need to return the path whose sum from top to bottom is minimum.
There is one constraint: we can only move to lower-left or lower-right elements.
For example, in the triangle depicted below, the only valid path from <code>5</code> are <code>5 -&gt; 1</code> and <code>5 -&gt; 8</code>. The paths <code>5 -&gt; 4</code> or <code>5 -&gt; 3</code> are invalid.</p>
<pre><code class="language-text">   2
  3 4
 6 5 7
4 1 8 3
</code></pre>
<p>Now the question is, can we solve it greedily, i.e., simply check the immediate step and choose the smaller element?
The answer is no. Because the current choice will affect the later decisions. This is illustrated in the following example:</p>
<pre><code class="language-text">   2
  4 5
 6 5 1
4 1 8 2
</code></pre>
<p>The greedy strategy will use the path <code>2 -&gt; 4 -&gt; 5 -&gt; 1</code>. But, the optimal path is <code>2 -&gt; 5 -&gt; 1 -&gt; 2</code>.
We need to use <code>Dynamic Programming</code> to solve this problem. Solving a problem using DP is generally tricky. This post will help you understand how to develop a DP approach. So, I highly recommend reading all three methods.</p>
<hr />
<hr />
<p>❌ <strong>Solution I: Recursion [TLE]</strong></p>
<p>We can try all valid paths and calculate the sum. Out of all those, return the minimum sum. At each step, we have two choices:</p>
<ol>
<li>Move to lower-left element (<code>i + 1</code> and <code>j</code>)</li>
<li>Move to lower-right element (<code>i + 1</code> and <code>j + 1</code>)</li>
</ol>
<iframe src="https://leetcode.com/playground/7GJqkRP3/shared" frameBorder="0" width="1080" height="280"></iframe>

<p>Why have I named the inside function as <code>dfs</code>? Because if we trace our actions, we can observe that it forms a binary tree. <strong>Don't worry</strong> if you are not familiar with this term. The following visualization will help you to understand what I mean.</p>
<pre><code class="language-text">                                                  ┏━━━┓
                            ╭─────────────────────┨ 2 ┠─────────────────────╮
                            │                     ┗━━━┛                     │
                          ┏━┷━┓                                           ┏━┷━┓     
                ╭─────────┨ 3 ┠─────────╮                       ╭─────────┨ 4 ┠─────────╮                 
                │         ┗━━━┛         │                       │         ┗━━━┛         │ 
              ┏━┷━┓                   ┏━┷━┓                   ┏━┷━┓                   ┏━┷━┓  
        ╭─────┨ 6 ┠─────╮       ╭─────┨ 5 ┠─────╮       ╭─────┨ 5 ┠─────╮       ╭─────┨ 7 ┠─────╮ 
        │     ┗━━━┛     │       │     ┗━━━┛     │       │     ┗━━━┛     │       │     ┗━━━┛     │ 
      ┏━┷━┓           ┏━┷━┓   ┏━┷━┓           ┏━┷━┓   ┏━┷━┓           ┏━┷━┓   ┏━┷━┓           ┏━┷━┓ 
      ┃ 4 ┃           ┃ 1 ┃   ┃ 1 ┃           ┃ 8 ┃   ┃ 1 ┃           ┃ 8 ┃   ┃ 8 ┃           ┃ 3 ┃
      ┗━━━┛           ┗━━━┛   ┗━━━┛           ┗━━━┛   ┗━━━┛           ┗━━━┛   ┗━━━┛           ┗━━━┛
</code></pre>
<p>In dfs, we traverse all the paths one by one. So, here our paths will be:</p>
<ol>
<li>2 -&gt; 3 -&gt; 6 -&gt; 4</li>
<li>2 -&gt; 3 -&gt; 6 -&gt; 1</li>
<li>
<p>2 -&gt; 3 -&gt; 5 -&gt; 1
.
.
.</p>
</li>
<li>
<p><strong>Time Complexity:</strong> <code>O(2ⁿ)</code></p>
</li>
<li><strong>Space Complexity:</strong> <code>O(n)</code></li>
</ol>
<hr />
<p>✅ <strong>Solution II: Top-Down DP or Memoization [Accepted]</strong></p>
<p>We are doing a lot of repetitive work in the above recursive solution. How?
Have a look at the above example. The subtree with head 5 is repeated twice. We need to compute the minimum sum path during the first time <code>(2 -&gt; 3 -&gt; 5 -&gt; ...)</code>. During the second time from <code>2 -&gt; 4 -&gt; 5</code>, we can simply use the result from the first time instead of traversing again. This is the essence of memoization.</p>
<pre><code class="language-text">                                                  ┏━━━┓
                            ╭─────────────────────┨ 2 ┠─────────────────────╮
                            │                     ┗━━━┛                     │
                          ┏━┷━┓                                           ┏━┷━┓     
                ╭─────────┨ 3 ┠─────────╮                       ╭─────────┨ 4 ┠─────────╮                 
                │         ┗━━━┛         │                       │         ┗━━━┛         │ 
              ┏━┷━┓          .........┏━┷━┓......... .........┏━┷━┓ ........          ┏━┷━┓  
        ╭─────┨ 6 ┠─────╮    .  ╭─────┨ 5 ┠─────╮  . .  ╭─────┨ 5 ┠─────╮  .    ╭─────┨ 7 ┠─────╮ 
        │     ┗━━━┛     │    .  │     ┗━━━┛     │  . .  │     ┗━━━┛     │  .    │     ┗━━━┛     │ 
      ┏━┷━┓           ┏━┷━┓  .┏━┷━┓           ┏━┷━┓. .┏━┷━┓           ┏━┷━┓.  ┏━┷━┓           ┏━┷━┓ 
      ┃ 4 ┃           ┃ 1 ┃  .┃ 1 ┃           ┃ 8 ┃. .┃ 1 ┃           ┃ 8 ┃.  ┃ 8 ┃           ┃ 3 ┃
      ┗━━━┛           ┗━━━┛  .┗━━━┛           ┗━━━┛. .┗━━━┛           ┗━━━┛.  ┗━━━┛           ┗━━━┛
                             ....................... ....................... 
</code></pre>
<p>In Python, it is as simple as adding the <code>@cache</code> decorator. But, this won't be accepted in the interviews and have many limitations.</p>
<pre><code class="language-python">class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        @cache
        def dfs(i, j):
            if i == len(triangle):
                return 0

            lower_left = triangle[i][j] + dfs(i + 1, j)
            lower_right = triangle[i][j] + dfs(i + 1, j + 1)

            return min(lower_left, lower_right)

        return dfs(0, 0)
</code></pre>
<p>We can manually use a way to store the information and use it later. Here, two variables (<code>i</code> and <code>j</code>) are changing and can be used to store a state. So, we can use a matrix. The following code will make it clear.</p>
<iframe src="https://leetcode.com/playground/mbJEU5da/shared" frameBorder="0" width="1080" height="360"></iframe>

<ul>
<li><strong>Time Complexity:</strong> <code>O(n²)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n²)</code></li>
</ul>
<hr />
<p>✅ <strong>Solution III (a): Bottom Up DP or Tabulation [Accepted]</strong></p>
<p>Recursion is slower than the iterative approach. So, we can further optimize the above solution by using bottom-up DP.
We can do a bottom-up traversal instead of traversing from top to bottom. Coming up with a bottom-up DP is challenging at first and requires practice. Instead of looking at the bigger problem, we look at smaller sub-problems and try to build up the solution. The following example will help you to understand:</p>
<pre><code class="language-text">1. Suppose that only the last level is given. 

4 1 8 3

Then what should be your answer?

If you thought 1, then congratulations  you are correct. This is our first subproblem. 

2. Now, the last two levels are given.

 6 5 7
4 1 8 3

Here, what should be the answer and what information do you need to store?

Clearly, the answer is 6 (5 -&gt; 1). But, this may not be the optimal path. So, we need to store all the optimal paths, i.e.,
[(6 -&gt; 1), (5 -&gt; 1), 7 -&gt; 3)] or [7, 6, 10]. This is our second subproblem.

3. Last 3 levels are given.

  3 4
 6 5 7
4 1 8 3

Again, what should be the answer and what information do you need to store (or use)?

Answer is 9 (3 -&gt; 5 -&gt; 1). Do we need to look again at all the paths? Can we use the information that we previously stored?
No and Yes.
If we replace the triangle as
  3 4
 7 6 10
then also, we'll get the same answer. And we can store this information as [(3 -&gt; 6), (4 -&gt; 6)] or [9, 10].

4. All levels are given

   2
  3 4
 6 5 7
4 1 8 3

Which can be replaced as:
   2
  9 10

And hence, our answer is 11 (2 -&gt; 9)

</code></pre>
<iframe src="https://leetcode.com/playground/deK2NY3Q/shared" frameBorder="0" width="1080" height="330"></iframe>

<ul>
<li><strong>Time Complexity:</strong> <code>O(n²)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n²)</code></li>
</ul>
<hr />
<p>✅ <strong>Solution III (b): Bottom Up DP or Tabulation (Space Optimized) [Accepted]</strong></p>
<p>Notice that we only require the information about the next row. So, instead of creating a <code>2D</code> matrix, a <code>1D</code> array is sufficient.</p>
<iframe src="https://leetcode.com/playground/FJAZiaam/shared" frameBorder="0" width="1080" height="350"></iframe>

<ul>
<li><strong>Time Complexity:</strong> <code>O(n²)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n)</code></li>
</ul>
<hr />
<hr />
<p>If you like the solution, please <strong>upvote</strong>! 
For any questions, or discussions, comment below. ️</p></div>