<div class='cpp-solution'><h2>Bottom Up 5 line C++ Solution -- Votes: 93</h2><div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="n">Solution</span><span class="w"> </span><span class="err">{</span>
<span class="k">public</span><span class="err">:</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">minimumTotal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nc">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">triangle</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="nc">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mini</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triangle</span><span class="o">[</span><span class="n">triangle.size()-1</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triangle</span><span class="p">.</span><span class="k">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="c1">--i )</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">.</span><span class="k">size</span><span class="p">()</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="n">mini</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">mini</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">,</span><span class="n">mini</span><span class="o">[</span><span class="n">j+1</span><span class="o">]</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">mini</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span><span class="p">;</span>
</code></pre></div></div>


<div class='python-solution'><h2>✅ [C++/ Python] Simple Solution w/ Explanation | Recursion -> DP -- Votes: 301</h2><p>Given a triangle array, we need to return the path whose sum from top to bottom is minimum.<br />
There is one constraint: we can only move to lower-left or lower-right elements.<br />
For example, in the triangle depicted below, the only valid path from <code>5</code> are <code>5 -&gt; 1</code> and <code>5 -&gt; 8</code>. The paths <code>5 -&gt; 4</code> or <code>5 -&gt; 3</code> are invalid.</p>
<div class="codehilite"><pre><span></span><code>Language: text
   2
  3 4
 6 5 7
4 1 8 3
</code></pre></div>

<p>Now the question is, can we solve it greedily, i.e., simply check the immediate step and choose the smaller element?<br />
The answer is no. Because the current choice will affect the later decisions. This is illustrated in the following example:</p>
<div class="codehilite"><pre><span></span><code>Language: text
   2
  4 5
 6 5 1
4 1 8 2
</code></pre></div>

<p>The greedy strategy will use the path <code>2 -&gt; 4 -&gt; 5 -&gt; 1</code>. But, the optimal path is <code>2 -&gt; 5 -&gt; 1 -&gt; 2</code>.<br />
We need to use <code>Dynamic Programming</code> to solve this problem. Solving a problem using DP is generally tricky. This post will help you understand how to develop a DP approach. So, I highly recommend reading all three methods.</p>
<hr />
<hr />
<p>❌ <strong>Solution I: Recursion [TLE]</strong></p>
<p>We can try all valid paths and calculate the sum. Out of all those, return the minimum sum. At each step, we have two choices:</p>
<ol>
<li>Move to lower-left element (<code>i + 1</code> and <code>j</code>)</li>
<li>Move to lower-right element (<code>i + 1</code> and <code>j + 1</code>)</li>
</ol>
<iframe src="https://leetcode.com/playground/7GJqkRP3/shared" frameBorder="0" width="1080" height="280"></iframe>

<p>Why have I named the inside function as <code>dfs</code>? Because if we trace our actions, we can observe that it forms a binary tree. <strong>Don't worry</strong> if you are not familiar with this term. The following visualization will help you to understand what I mean.</p>
<div class="codehilite"><pre><span></span><code>Language: text
                                                  ┏━━━┓
                            ╭─────────────────────┨ 2 ┠─────────────────────╮
                            │                     ┗━━━┛                     │
                          ┏━┷━┓                                           ┏━┷━┓     
                ╭─────────┨ 3 ┠─────────╮                       ╭─────────┨ 4 ┠─────────╮                 
                │         ┗━━━┛         │                       │         ┗━━━┛         │ 
              ┏━┷━┓                   ┏━┷━┓                   ┏━┷━┓                   ┏━┷━┓  
        ╭─────┨ 6 ┠─────╮       ╭─────┨ 5 ┠─────╮       ╭─────┨ 5 ┠─────╮       ╭─────┨ 7 ┠─────╮ 
        │     ┗━━━┛     │       │     ┗━━━┛     │       │     ┗━━━┛     │       │     ┗━━━┛     │ 
      ┏━┷━┓           ┏━┷━┓   ┏━┷━┓           ┏━┷━┓   ┏━┷━┓           ┏━┷━┓   ┏━┷━┓           ┏━┷━┓ 
      ┃ 4 ┃           ┃ 1 ┃   ┃ 1 ┃           ┃ 8 ┃   ┃ 1 ┃           ┃ 8 ┃   ┃ 8 ┃           ┃ 3 ┃
      ┗━━━┛           ┗━━━┛   ┗━━━┛           ┗━━━┛   ┗━━━┛           ┗━━━┛   ┗━━━┛           ┗━━━┛
</code></pre></div>

<p>In dfs, we traverse all the paths one by one. So, here our paths will be:</p>
<ol>
<li>2 -&gt; 3 -&gt; 6 -&gt; 4</li>
<li>2 -&gt; 3 -&gt; 6 -&gt; 1</li>
<li>2 -&gt; 3 -&gt; 5 -&gt; 1<br />
   .<br />
   .<br />
   .</li>
</ol>
<ul>
<li><strong>Time Complexity:</strong> <code>O(2ⁿ)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n)</code></li>
</ul>
<hr />
<p>✅ <strong>Solution II: Top-Down DP or Memoization [Accepted]</strong></p>
<p>We are doing a lot of repetitive work in the above recursive solution. How?<br />
Have a look at the above example. The subtree with head 5 is repeated twice. We need to compute the minimum sum path during the first time <code>(2 -&gt; 3 -&gt; 5 -&gt; ...)</code>. During the second time from <code>2 -&gt; 4 -&gt; 5</code>, we can simply use the result from the first time instead of traversing again. This is the essence of memoization.</p>
<div class="codehilite"><pre><span></span><code>Language: text
                                                  ┏━━━┓
                            ╭─────────────────────┨ 2 ┠─────────────────────╮
                            │                     ┗━━━┛                     │
                          ┏━┷━┓                                           ┏━┷━┓     
                ╭─────────┨ 3 ┠─────────╮                       ╭─────────┨ 4 ┠─────────╮                 
                │         ┗━━━┛         │                       │         ┗━━━┛         │ 
              ┏━┷━┓          .........┏━┷━┓......... .........┏━┷━┓ ........          ┏━┷━┓  
        ╭─────┨ 6 ┠─────╮    .  ╭─────┨ 5 ┠─────╮  . .  ╭─────┨ 5 ┠─────╮  .    ╭─────┨ 7 ┠─────╮ 
        │     ┗━━━┛     │    .  │     ┗━━━┛     │  . .  │     ┗━━━┛     │  .    │     ┗━━━┛     │ 
      ┏━┷━┓           ┏━┷━┓  .┏━┷━┓           ┏━┷━┓. .┏━┷━┓           ┏━┷━┓.  ┏━┷━┓           ┏━┷━┓ 
      ┃ 4 ┃           ┃ 1 ┃  .┃ 1 ┃           ┃ 8 ┃. .┃ 1 ┃           ┃ 8 ┃.  ┃ 8 ┃           ┃ 3 ┃
      ┗━━━┛           ┗━━━┛  .┗━━━┛           ┗━━━┛. .┗━━━┛           ┗━━━┛.  ┗━━━┛           ┗━━━┛
                             ....................... ....................... 
</code></pre></div>

<p>In Python, it is as simple as adding the <code>@cache</code> decorator. But, this won't be accepted in the interviews and have many limitations.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Language</span><span class="p">:</span> <span class="n">python</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">minimumTotal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangle</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="nd">@cache</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">triangle</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="n">lower_left</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">lower_right</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">lower_left</span><span class="p">,</span> <span class="n">lower_right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<p>We can manually use a way to store the information and use it later. Here, two variables (<code>i</code> and <code>j</code>) are changing and can be used to store a state. So, we can use a matrix. The following code will make it clear.</p>
<iframe src="https://leetcode.com/playground/mbJEU5da/shared" frameBorder="0" width="1080" height="360"></iframe>

<ul>
<li><strong>Time Complexity:</strong> <code>O(n²)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n²)</code></li>
</ul>
<hr />
<p>✅ <strong>Solution III (a): Bottom Up DP or Tabulation [Accepted]</strong></p>
<p>Recursion is slower than the iterative approach. So, we can further optimize the above solution by using bottom-up DP.<br />
We can do a bottom-up traversal instead of traversing from top to bottom. Coming up with a bottom-up DP is challenging at first and requires practice. Instead of looking at the bigger problem, we look at smaller sub-problems and try to build up the solution. The following example will help you to understand:</p>
<div class="codehilite"><pre><span></span><code>Language: text
1. Suppose that only the last level is given. 

4 1 8 3

Then what should be your answer?

If you thought 1, then congratulations  you are correct. This is our first subproblem. 

2. Now, the last two levels are given.

 6 5 7
4 1 8 3

Here, what should be the answer and what information do you need to store?

Clearly, the answer is 6 (5 -&gt; 1). But, this may not be the optimal path. So, we need to store all the optimal paths, i.e.,
[(6 -&gt; 1), (5 -&gt; 1), 7 -&gt; 3)] or [7, 6, 10]. This is our second subproblem.

3. Last 3 levels are given.

  3 4
 6 5 7
4 1 8 3

Again, what should be the answer and what information do you need to store (or use)?

Answer is 9 (3 -&gt; 5 -&gt; 1). Do we need to look again at all the paths? Can we use the information that we previously stored?
No and Yes.
If we replace the triangle as
  3 4
 7 6 10
then also, we&#39;ll get the same answer. And we can store this information as [(3 -&gt; 6), (4 -&gt; 6)] or [9, 10].

4. All levels are given

   2
  3 4
 6 5 7
4 1 8 3

Which can be replaced as:
   2
  9 10

And hence, our answer is 11 (2 -&gt; 9)
</code></pre></div>

<iframe src="https://leetcode.com/playground/deK2NY3Q/shared" frameBorder="0" width="1080" height="330"></iframe>

<ul>
<li><strong>Time Complexity:</strong> <code>O(n²)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n²)</code></li>
</ul>
<hr />
<p>✅ <strong>Solution III (b): Bottom Up DP or Tabulation (Space Optimized) [Accepted]</strong></p>
<p>Notice that we only require the information about the next row. So, instead of creating a <code>2D</code> matrix, a <code>1D</code> array is sufficient.</p>
<iframe src="https://leetcode.com/playground/FJAZiaam/shared" frameBorder="0" width="1080" height="350"></iframe>

<ul>
<li><strong>Time Complexity:</strong> <code>O(n²)</code></li>
<li><strong>Space Complexity:</strong> <code>O(n)</code></li>
</ul>
<hr />
<hr />
<p>If you like the solution, please <strong>upvote</strong>!<br />
For any questions, or discussions, comment below. ️</p></div><p style="page-break-before: always" ></p>