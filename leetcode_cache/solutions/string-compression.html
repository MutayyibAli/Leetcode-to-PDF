<div class='cpp-solution'><h4>Clean CodesðŸ”¥ðŸ”¥|| Full Explanationâœ…|| Two Pointersâœ…|| C++|| Java|| Python3 [Votes: 343]</h4><h4>Intuition :</h4>
<ul>
<li>Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1.</li>
<li>Example:</li>
</ul>
<pre><code>Input:
[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]
Output:
Return 6, and the first 6 characters of the input array should be: 
[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]
Explanation:
&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is 
replaced by &quot;c3&quot;.
</code></pre>
<!-- Describe your first thoughts on how to solve this problem. -->

<h4>Detail Explanation to Approach :</h4>
<ul>
<li>Here we are using two pointers, one for iterating through the original character array and one for keeping track of the current position in the compressed array. The two pointer variables used are <code>i</code> and <code>ans</code>.</li>
<li>Now also use a variable to keep track of the count of consecutive characters.</li>
<li>First set the current letter to the first character in the array and initializes the count to 0. </li>
<li>Then iterate through the array until you find a different character or reach the end of the array. </li>
<li>For each iteration, increment the count and the index i.</li>
</ul>
<pre><code>// iterate through input array using i pointer
    for (int i = 0; i &lt; chars.length;) {
      final char letter = chars[i]; // current character being compressed
      int count = 0; // count of consecutive occurrences of letter

      // count consecutive occurrences of letter in input array
      while (i &lt; chars.length &amp;&amp; chars[i] == letter) {
        ++count;
        ++i;
      }


</code></pre>
<ul>
<li>When you find a different character or reach the end of the array, write the current letter to the compressed array and, if the count is greater than 1, write the count as a string to the compressed array. </li>
<li>Then reset the count to 0 and set the current letter to the new letter.</li>
</ul>
<pre><code>// write letter to compressed array
      chars[ans++] = letter;

      // if count is greater than 1, write count as string to compressed array
      if (count &gt; 1) {
        // convert count to string and iterate over each character in string
        for (final char c : String.valueOf(count).toCharArray()) {
          chars[ans++] = c;
        }
      }
</code></pre>
<ul>
<li>Finally, return the length of the compressed array, which is equal to the position of the last character in the compressed array plus one.</li>
</ul>
<pre><code>return ans;//return length of compressed array

</code></pre>
<!-- Describe your approach to solving the problem. -->

<h4>Complexity :</h4>
<ul>
<li>Time complexity : O(n)</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity : O(1)</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution.
</code></pre>
<p><em>Let's Code it Up .
There may be minor syntax difference in cpp and Python</em></p>
<h4>Codes [cpp |Java |Python3] : With Comments</h4>
<pre><code class="language-cpp">class Solution {
public:
    int compress(vector&lt;char&gt;&amp; chars) {
        int ans = 0;

        // iterate through input vector using i pointer
        for (int i = 0; i &lt; chars.size();) {
            const char letter = chars[i]; // current character being compressed
            int count = 0; // count of consecutive occurrences of letter

            // count consecutive occurrences of letter in input vector
            while (i &lt; chars.size() &amp;&amp; chars[i] == letter) {
                ++count;
                ++i;
            }

            // write letter to compressed vector
            chars[ans++] = letter;

            // if count is greater than 1, write count as string to compressed vector
            if (count &gt; 1) {
                // convert count to string and iterate over each character in string
                for (const char c : to_string(count)) {
                    chars[ans++] = c;
                }
            }
        }

        // return length of compressed vector
        return ans;
    }
};

</code></pre>
<pre><code class="language-Java">class Solution {
  public int compress(char[] chars) {
    int ans = 0; // keep track of current position in compressed array

    // iterate through input array using i pointer
    for (int i = 0; i &lt; chars.length;) {
      final char letter = chars[i]; // current character being compressed
      int count = 0; // count of consecutive occurrences of letter

      // count consecutive occurrences of letter in input array
      while (i &lt; chars.length &amp;&amp; chars[i] == letter) {
        ++count;
        ++i;
      }

      // write letter to compressed array
      chars[ans++] = letter;

      // if count is greater than 1, write count as string to compressed array
      if (count &gt; 1) {
        // convert count to string and iterate over each character in string
        for (final char c : String.valueOf(count).toCharArray()) {
          chars[ans++] = c;
        }
      }
    }

    // return length of compressed array
    return ans;
  }
}

</code></pre>
<pre><code class="language-Python3">class Solution:
  def compress(self, chars: List[str]) -&gt; int:
    ans = 0
    i = 0

    while i &lt; len(chars):
      letter = chars[i]
      count = 0
      while i &lt; len(chars) and chars[i] == letter:
        count += 1
        i += 1
      chars[ans] = letter
      ans += 1
      if count &gt; 1:
        for c in str(count):
          chars[ans] = c
          ans += 1

    return ans
</code></pre>
<h4>Please Upvote</h4></div>