<div class='cpp-solution'><h4>C++ simple [Votes: 322]</h4><p>First locate the node before the <code>m</code>-th node (<code>pre</code>) and the <code>m</code>-th node (<code>cur</code>). Then move<code>cur -&gt; next</code> to be after <code>pre</code> for <code>n - m</code> times.</p>
<p><code>cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode *dummy = new ListNode(0), *pre = dummy, *cur;
        dummy -&gt; next = head;
        for (int i = 0; i &lt; m - 1; i++) {
            pre = pre -&gt; next;
        }
        cur = pre -&gt; next;
        for (int i = 0; i &lt; n - m; i++) {
            ListNode* temp = pre -&gt; next;
            pre -&gt; next = cur -&gt; next;
            cur -&gt; next = cur -&gt; next -&gt; next;
            pre -&gt; next -&gt; next = temp;
        }
        return dummy -&gt; next;
    }
};</code></p></div><div class='python-solution'><h4>Python one pass iterative solution [Votes: 166]</h4><p>The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1</p>
<pre><code>class Solution:
    #### @param head, a ListNode
    #### @param m, an integer
    #### @param n, an integer
    #### @return a ListNode
    def reverseBetween(self, head, m, n):
        if m == n:
            return head

        dummyNode = ListNode(0)
        dummyNode.next = head
        pre = dummyNode

        for i in range(m - 1):
            pre = pre.next

        #### reverse the [m, n] nodes
        reverse = None
        cur = pre.next
        for i in range(n - m + 1):
            next = cur.next
            cur.next = reverse
            reverse = cur
            cur = next

        pre.next.next = cur
        pre.next = reverse

        return dummyNode.next
</code></pre></div>