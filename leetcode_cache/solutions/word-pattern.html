<div class='cpp-solution'><h4>Short C++, read words on the fly [Votes: 332]</h4><p>I think all previous cpp solutions read all words into a vector at the start. Here I read them on the fly.</p>
<pre><code>bool wordPattern(string pattern, string str) {
    map&lt;char, int&gt; p2i;
    map&lt;string, int&gt; w2i;
    istringstream in(str);
    int i = 0, n = pattern.size();
    for (string word; in &gt;&gt; word; ++i) {
        if (i == n || p2i[pattern[i]] != w2i[word])
            return false;
        p2i[pattern[i]] = w2i[word] = i + 1;
    }
    return i == n;
}
</code></pre></div><div class='python-solution'><h4>Short in Python [Votes: 294]</h4><p>This problem is pretty much equivalent to <a href="https://leetcode.com/problems/isomorphic-strings/">Isomorphic Strings</a>. Let me reuse two old solutions.</p>
<p>From <a href="https://leetcode.com/discuss/36438/1-liner-in-python?show=39070#c39070">here</a>:</p>
<pre><code>def wordPattern(self, pattern, str):
    s = pattern
    t = str.split()
    return map(s.find, s) == map(t.index, t)
</code></pre>
<p>Improved version also from there:</p>
<pre><code>def wordPattern(self, pattern, str):
    f = lambda s: map({}.setdefault, s, range(len(s)))
    return f(pattern) == f(str.split())
</code></pre>
<p>From <a href="https://leetcode.com/discuss/41379/1-line-in-python?show=41382#a41382">here</a>:</p>
<pre><code>def wordPattern(self, pattern, str):
    s = pattern
    t = str.split()
    return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t)
</code></pre>
<p>Thanks to zhang38 for pointing out the need to check len(s) == len(t) here.</p></div>