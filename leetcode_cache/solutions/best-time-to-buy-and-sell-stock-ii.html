<div class='cpp-solution'><h4>Python/JS/Java/Go/C++ O(n) by DP // Greedy [+ Visualization & Thinking process] 有中文全系列解析專欄 [Votes: 822]</h4><p><a href="https://vocus.cc/article/65fd41d2fd897800015721f3">中文專欄:
從DP和FSM有限狀態機的角度，去解開Leetcode最佳股票買賣系列題。</a></p>
<p><a href="https://vocus.cc/article/66616aeffd89780001cab1da">DP演算法框架 與 推薦的學習路徑 (透過相似題去強化對DP結構的認識與理解)
Common DP algorithm framework and recommended learning path</a></p>
<p>Our goal:
Maximize trading profit with at most single long position(每個時刻最多持有一個多頭部位) on every moment.</p>
<p>Method_#1
O(n) sol by DP + state machine</p>
<p>Define "<strong>Hold</strong>" as the state of <strong>holding stock</strong>. (持有股票)
Define "<strong>NotHold</strong>" as the state of <strong>keep cash</strong>. (持有現金)</p>
<p>General rule aka recursive relationship.</p>
<pre><code>DP[Hold] 
= max(keep holding stock, or just buy stock &amp; hold today)
= max( DP[Previous Hold], DP[previous NotHold] - stock price)
</code></pre>
<pre><code>DP[NotHold] 
= max(keep cash, or just sell out stock today)
= max( DP[Previous NotHold], DP[previous Hold] + stock price)
</code></pre>
<p><strong>State machine diagram</strong>:</p>
<p><img src="https://assets.leetcode.com/users/images/62d26ff8-bba1-497c-b429-702e002a05d1_1684081274.8362317.png" width="1000" height="600"></p>
<p>Some reader may argue it is not DP,
but for me it is.
Each state depends on early states, and there are overlapped subproblem.</p>
<p>If you would like to see more traditional DP-style code with multiple dimension, here is the code.</p>
<p>Some reader feels that DP is an over-kill for Best time to buy and sell stock II.
I confess it is, but I just want to show that we can solve all Leetcode's stock trading problem series in DP thinking process with state machine transfer in a general way.</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:

        #### Use constant literal to help reader understand source code below.
        HOLD_STOCK, KEEP_CASH = 0, 1

        ##### Dictionary (Hash table)
        #### key: (day, state) pair
        #### value: coreesponding maximal profit
        dp = {}

        #### No free lunch, it is impoosible to have stock before first trading day
        dp[-1, HOLD_STOCK] = -math.inf

        #### No gain, no loss before first trading day
        dp[-1, KEEP_CASH] = 0

        #### For each day with corresponding stock price in stock market
        for day, stock_price in enumerate(prices):

            #### If today we have stock, either we already had it yesterday, or we just buy stock and hold it today.
            dp[day, HOLD_STOCK] = max( dp[day-1, HOLD_STOCK], dp[day-1, KEEP_CASH] - stock_price)

            #### If today we keep cash, either we already kept cash yesterday, or we just sell out stock today
            dp[day, KEEP_CASH] = max( dp[day-1, KEEP_CASH], dp[day-1, HOLD_STOCK] + stock_price)

        #------------------------------------------------------------        #### To get maximal realized profit, final state must be KEEP_CASH.
        last_day = len(prices)-1
        return dp[last_day, KEEP_CASH]
</code></pre>
<p><strong>Implementation</strong> by botoom-up DP + iteration:</p>
<iframe src="https://leetcode.com/playground/J7fnkkAb/shared" frameBorder="0" width="1000" height="600"></iframe>

<p>Time Complexity: O(n), for single level for loop
Space Complexity: O(1), for fixed size of temporary variables</p>
<p><strong>Implementation</strong> with Top down DP + recursion </p>
<iframe src="https://leetcode.com/playground/2zaLvs2H/shared" frameBorder="0" width="1000" height="600"></iframe>

<p>Time Complexity: O(n), for single level for loop
Space Complexity: O(n), for 1D DP recursion call depth</p>
<p>Method_#2
O(n) sol by Greedy</p>
<p>Share another O(n) solution by price gain collection with <strong>greedy</strong> value taking concept.</p>
<p>Max profit with <a href="https://en.wikipedia.org/wiki/Long_(finance)">long position</a> ,'做多' in chinese, is met by <strong>collecting all price gain</strong> in the stock price sequence.</p>
<p>Take care that holding <strong>multiple position at the same time is NOT allowed</strong> by <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">description</a>.</p>
<p><strong>Visualization</strong>:</p>
<p><strong>Implementation</strong> based on container and summation function:</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:

        price_gain = []

        for idx in range( len(prices)-1 ):

            if prices[idx] &lt; prices[idx+1]:

                price_gain.append( prices[idx+1]- prices[idx])

        return sum( price_gain )
</code></pre>
<pre><code class="language-Java">class Solution {


    public int maxProfit(int[] prices) {

        ArrayList&lt;Integer&gt; priceGain = new ArrayList&lt;Integer&gt;();

        for(int idx = 0 ; idx &lt; prices.length-1; idx++){

            if( prices[idx] &lt; prices[idx+1] ){
                priceGain.add( prices[idx+1]- prices[idx]);
            }

        }
        return priceGain.stream().mapToInt(n-&gt;n).sum();

    }
}
</code></pre>
<pre><code class="language-Javascript">const accumulate = ( (prev, cur) =&gt; (prev + cur) );

var maxProfit = function(prices) {

    let profit = new Array();

    for( let i = 0 ; i &lt; prices.length-1 ; i++ ){

        if( prices[i] &lt; prices[i+1] ){
            profit.push(  prices[i+1] - prices[i] );
        }
    }
    return profit.reduce(accumulate, 0);
}
</code></pre>
<pre><code class="language-Go">func Accumulate(elements ...int) int {  
     sum := 0  
     for _, elem := range elements {  
          sum += elem  
     }  
     return sum  
} 


func maxProfit(prices []int) int {

    profit := make([]int, 0)

    for i := 0 ; i &lt; len(prices)-1 ; i++{

        if( prices[i] &lt; prices[i+1] ){
            profit = append(profit, ( prices[i+1] - prices[i] ))
        }
    }

    return Accumulate(profit...)
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {

        vector&lt;int&gt; profit;

        for( size_t i = 0 ; i &lt; prices.size()-1 ; i++ ){

            if( prices[i] &lt; prices[i+1] ){
                profit.push_back( prices[i+1] - prices[i] );
            }

        }
        return accumulate( profit.begin(), profit.end(), 0);
    }
};
</code></pre>
<p>Time Complexity: O(n), for single level for loop
Space Complexity: O(n), for array storage sapce</p>
<p><strong>Implementation</strong> based on generator expression and sum( ... ):</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:

        return sum( ( prices[idx+1]-prices[idx] ) for idx in range(len(prices)-1) if prices[idx] &lt; prices[idx+1] )
</code></pre>
<p><strong>Implementation</strong> based on O(1) aux space:</p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:

        profit_from_price_gain = 0
        for idx in range( len(prices)-1 ):

            if prices[idx] &lt; prices[idx+1]:
                profit_from_price_gain += ( prices[idx+1] - prices[idx])

        return profit_from_price_gain
</code></pre>
<pre><code class="language-Javascript">var maxProfit = function(prices) {

    let profitFromPriceGain = 0;

    for( let i = 0 ; i &lt; prices.length-1 ; i++ ){

        if( prices[i] &lt; prices[i+1] ){
            profitFromPriceGain += (  prices[i+1] - prices[i] );
        }
    }

    return profitFromPriceGain;
}
</code></pre>
<pre><code class="language-Java">class Solution {
    public int maxProfit(int[] prices) {      
        int profitFromPriceGain = 0;

        for( int i = 0 ; i &lt; prices.length-1 ; i++ ){

            if( prices[i] &lt; prices[i+1] ){
                profitFromPriceGain += ( prices[i+1] - prices[i] );
            }
        }

        return profitFromPriceGain;
    }
}
</code></pre>
<pre><code class="language-Go">func maxProfit(prices []int) int {

    profitFromPriceGain := 0

    for i := 0 ; i &lt; len(prices)-1 ; i++{

        if( prices[i] &lt; prices[i+1] ){
            profitFromPriceGain += ( prices[i+1] - prices[i] )
        }
    }

    return profitFromPriceGain
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {

        int profitFromPriceGain = 0;

        for( size_t i = 0 ; i &lt; prices.size()-1 ; i++ ){

            if( prices[i] &lt; prices[i+1] ){
                profitFromPriceGain += ( prices[i+1] - prices[i] );
            }

        }
        return profitFromPriceGain;
    }
};
</code></pre>
<p>Time Complexity: O(n), for single level for loop
Space Complexity: O(1), for fixed size of temporary variables</p>
<p>Related leetcode challenge:</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock">Leetcode #121 Best Time to Buy and Sell Stock</a></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii">Leetcode #123 Best Time to Buy and Sell Stock III </a></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv">Leetcode #188 Best Time to Buy and Sell Stock IV  </a></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">Leetcode #309 Best Time to Buy and Sell Stock with Cooldown</a></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  </a> </p>
<p>Reference:</p>
<p>[1] <a href="https://www.python.org/dev/peps/pep-0289/">Python official docs about generator expression</a></p>
<p>[2] <a href="https://docs.python.org/3/library/functions.html#sum">Python official docs about sum( ... )</a></p></div>