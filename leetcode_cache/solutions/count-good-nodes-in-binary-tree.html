<div class='cpp-solution'><h4>ü•á C++ | PYTHON  ||  EXPLAINED  ||  ; ] [Votes: 90]</h4><p><strong>UPVOTE IF HELPFuuL</strong></p>
<p><strong>APPROACH</strong></p>
<p>Any sort of traversal would work here.
While traversing the tree, keep a variable that stores the maximum value till now in the path.
Compare it with node value to decide whether it is a ood node or not.</p>
<p><strong>BASE CASE</strong>
* Return <code>0</code>, whenever <code>root == NULL</code></p>
<p><strong>RECURSIVE CALL</strong>
* Call the funtion for both <code>root-&gt;left</code> and <code>root-&gt;right</code> and changing the max value to <code>max(max_till_now,root-&gt;val)</code></p>
<p><strong>SELF-WORK</strong>
* Get answer recursively for next nodes.
* If <code>root-&gt;val &gt; max_value_till_now</code> increment the answer by one.</p>
<p><strong>UPVOTE IF HELPFuuL</strong></p>
<p><strong>cpp</strong></p>
<pre><code>class Solution {
public:

    int solve(TreeNode* root,int hi){
        if (root){
            int k=solve(root-&gt;left, max(hi,root-&gt;val)) + solve(root-&gt;right, max(hi,root-&gt;val));
            if (root-&gt;val&gt;=hi){
                k++;
            }
            return k;
        }
        return 0;
    }
    int goodNodes(TreeNode* root) {
        return solve(root,-10001);
    }
};
</code></pre>
<p><strong>PYTHON</strong></p>
<pre><code>class Solution:
    def goodNodes(self, root: TreeNode) -&gt; int:
        def solve(root,val):
            if root:
                k = solve(root.left, max(val,root.val)) + solve(root.right, max(val,root.val))
                if root.val &gt;= val:
                    k+=1
                return k
            return 0
        return solve(root,root.val)
</code></pre></div><div class='python-solution'><h4>‚úîÔ∏èC++ | Python | Cüî•97% DFS‚úÖDetailed graph explantion | Beginner-friendly | Easy to understand ^_^ [Votes: 163]</h4><p><strong>Idea:</strong>
1. DFS through every path, and keep tracking of biggest value(curMax) in the path.
2. If current node is <code>&gt;=</code> the biggest value in the path, we add the answer by one.</p>
<p>Here's an example to show how the code works:</p>
<p>(In <strong>Python</strong>, we use list as a global valuable)</p>
<iframe src="https://leetcode.com/playground/EunmHB7o/shared" frameBorder="0" width="1000" height="400"></iframe>

<p><strong>Please UPVOTE if you LIKE!!!</strong></p></div>