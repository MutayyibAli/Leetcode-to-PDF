<div class='cpp-solution'><h4>✅ 3 Line Code Very Easy C++ Solution ✅ [Votes: 514]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->

<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->

<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Code</h4>
<pre><code>class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
        int n=cost.size();
        for(int i=2;i&lt;n;i++)
        {
            cost[i]+=min(cost[i-1],cost[i-2]);
        }
        return min(cost[n-1],cost[n-2]);
    }
};
</code></pre></div><div class='python-solution'><h4>A Beginner's Guide on DP validation & How to come up with a Recursive solution [Python 3] [Votes: 493]</h4><h6>Section 1: DP Validation</h6>
<p>Our first question should be: <strong>Is Dynamic Programming (DP) suitable for this question?</strong></p>
<p>In its essence, DP is just <strong>doing brute force recursion smartly</strong>, so we should first check if the question can be done <strong>recursively</strong> (whether we can break it down into <strong>smaller subproblems</strong>) </p>
<p>Then, to check if we can apply DP, we look at 2 distinct properties of DP: 
1. <strong>Overlapping subproblems</strong>: Does finding the solution require us to calculate the same subproblem multiple times? 
2. <strong>Optimal Substructure Property</strong>: Can the optimal solution be constructed from the optimal solutions of its subproblems? (Are the subproblems independent from each other? </p>
<p><strong>Thought Process</strong>
We can use recursion to solve the problem because we can break it into smaller subproblems: 
* If we want to know the <strong>min cost to reach stair #n</strong>, It will be tremendously helpful to know the <strong>min cost to reach step #n-1</strong> and <strong>step #n-2</strong> (because we can reach step #n in one step from them)</p>
<p>Now that we know we can use recursion, should we use DP? Let's check if the question contains the two properties that I mentioned above
1. <strong>Overlapping Subproblems</strong>: 
    * minCost(n) will be the short form of min cost to reach stair #n
    * We know that minCost(n) depends on minCost(n-1) and <strong>minCost(n-2)</strong>, then by the same logic minCost(n-1) depends on <strong>minCost(n-2)</strong> and minCost(n-3). 
    * Notice that we have the same expression twice (bolded), this shows that <strong>we have overlapping subproblems!</strong> </p>
<ol>
<li><strong>Optimal Substructure Property</strong><ul>
<li>let's take cost = [4,2,3] for example, what's minCost(3)?</li>
<li>To reach stair #3, we have to start from either stair #1 or #2, since we want to minimize cost so we choose stair #2 (2 &lt; 4) and climb one step to reach #3</li>
<li>To reach stair #2, since we can choose to start at #2 (step with index 1), it's already the optimal solution.</li>
<li>We see that the optimal solution of one subproblem leads up to the optimal solution of the problem, therefore <strong>this property is present!</strong></li>
</ul>
</li>
</ol>
<p>After we have both properties fulfilled, we know that we can tackle this problem using DP with confidence! </p>
<p>..............................................................</p>
<h6>Section 2: How to come up with a recursive solution?</h6>
<p>The key to solving any DP problem is to <strong>identify a recursive solution</strong>, then we can identify the overlapping subproblems and then apply <strong>memoization (top-down)</strong> or <strong>tabulation (bottom-up)</strong> methods to optimize based of the recursive solution</p>
<p>Below is a strategy we can use to find a recursive solution
1. <strong>Identify what variable is changing between each subproblem</strong>
2. <strong>Create the recursive function based on #1 and clearly defines its meaning</strong>
3. <strong>State transition formula (Find a formula that connects a problem to its subproblems)</strong>
4. <strong>Define the base cases of recursion</strong> </p>
<p><strong>Walkthrough</strong>
1. <strong>Changing Variables:</strong> 
    * From the problem, we can see that there are 2 changing variables
    * index of the current stair (stair #n) 
    * minimum cost to reach the current stair 
2. <strong>Create function:</strong> 
    * We can associate the 2 variables together by creating a function minCost(n), where n is the index of the current stair, and minCost(n) represents the min cost to reach stair #n
    * This is the same function that we came up with in section 1 based on pure intuition 
3. <strong>Get State transition formula:</strong> 
     * Get a formula to connect a problem to its subproblems, we first check what is moving the problem forward. By reading the problem, we see that the key info is that <strong>you can either climb one or two steps.</strong>
     * Based of this info, we know that minCost(n) has strong relationship to minCost(n-1) and minCost(n-2), because you can reach n from both n-1 and n-2 stairs 
     * Keep reading the question, we see that we should <strong>pay the cost at each stair</strong> and <strong>get minimum cost</strong>, so the relationship between them becomes clear as shown below
     * minCost(n) = cost[n] + min(minCost(n-1), minCost(n-2))
4. <strong>Define base cases:</strong>
    * This part is easy, from the problem statement we know we can start from either stair index 0 or index 1
    * So base cases would be the first 2 stairs. minCost(0) = cost[0] and minCost(1) = cost[1] </p>
<p>With all the above info, it's easy to construct a recursive solution as shown below: </p>
<pre><code> def minCostClimbingStairs(self, cost: List[int]) -&gt; int:
        #### identify what is changing from subproblems to subproblems: 
        #### n - step #n    dp(n) - min cost to get to step #n 
        def dp(n):  
            #### write down base cases
            if n &lt; 2: 
                return cost[n] 
            #### write recursive function based on what you can change (climb one or two steps)
            return cost[n] + min(dp(n-1), dp(n-2))

        #### since we want to know the min cost to get to the final step, we use the code below 
        length = len(cost) 
        return min(dp(length-1), dp(length-2))
</code></pre>
<p>..............................................................</p>
<h6>Section 3: Extra</h6>
<ul>
<li>
<p>To see how to use DP techniques (top-down, bottom-up) to make recursion more efficient, check out https://leetcode.com/problems/min-cost-climbing-stairs/discuss/476388/4-ways-or-Step-by-step-from-Recursion-greater-top-down-DP-greater-bottom-up-DP-greater-fine-tuning</p>
</li>
<li>
<p>Please leave a comment to let me know any confusion or feedback :)</p>
</li>
<li>
<p>This problem took me a while to understand, and I  wish to share the thought process for the first few very important parts </p>
</li>
<li>
<p>Thank you for reading, have a nice day!</p>
</li>
</ul></div>