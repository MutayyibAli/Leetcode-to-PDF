<div class='cpp-solution'><h4>✅Beats 100% - Dynamic Programming - C++/Java/Python/JS - Explained with [ Video ] [Votes: 138]</h4><h4>YouTube Video Explanation:</h4>
<!-- **If you want a video for this question please write in the comments** -->

<!-- https://www.youtube.com/watch?v=ujU-jeO1v-k -->

<p>https://youtu.be/16G6jjbMhjo</p>
<p>** Please like, share, and subscribe to support our channel's mission of making complex concepts easy to understand.**</p>
<p>Subscribe Link: https://www.youtube.com/@leetlogics/?sub_confirmation=1</p>
<p><em>Subscribe Goal: 1700 Subscribers</em>
<em>Current Subscribers: 1610</em></p>
<h4>Intuition:</h4>
<p>The problem asks for finding the length of the longest common subsequence between two strings. A common subsequence is a sequence of characters that appear in the same order in both strings. The dynamic programming approach can be used to efficiently find the length of the longest common subsequence.</p>
<h4>Approach:</h4>
<ol>
<li><strong>Dynamic Programming (DP):</strong></li>
<li>We create a 2D array <code>dp</code> to store the lengths of the longest common subsequences for all subproblems.</li>
<li>The array <code>dp</code> has dimensions <code>(length1 + 1) x (length2 + 1)</code> to accommodate empty strings as substrings.</li>
<li>The cell <code>dp[i][j]</code> represents the length of the longest common subsequence of substrings <code>text1[0...i-1]</code> and <code>text2[0...j-1]</code>.</li>
<li>
<p>We fill in the <code>dp</code> array from the bottom up using the following recurrence relation:</p>
<ul>
<li>If characters at indices <code>i-1</code> and <code>j-1</code> match, <code>dp[i][j] = dp[i-1][j-1] + 1</code>.</li>
<li>If characters do not match, <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>.</li>
</ul>
</li>
<li>
<p><strong>Result:</strong></p>
</li>
<li>The bottom-right cell <code>dp[length1][length2]</code> contains the length of the longest common subsequence of the entire strings <code>text1</code> and <code>text2</code>.</li>
</ol>
<h4>Complexity Analysis:</h4>
<ul>
<li><strong>Time Complexity:</strong> O(length1 * length2)</li>
<li>The nested loops iterate through each character in both strings, filling the 2D array.</li>
<li><strong>Space Complexity:</strong> O(length1 * length2)</li>
<li>The space used by the 2D array to store intermediate results.</li>
</ul>
<h4>Code Explanation:</h4>
<ul>
<li>The code initializes a 2D array <code>dp</code> and iterates through both strings, updating the <code>dp</code> array according to the recurrence relation.</li>
<li>The result is obtained from the bottom-right cell of the <code>dp</code> array, which represents the length of the longest common subsequence.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-Java">class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // Lengths of the input strings
        int length1 = text1.length();
        int length2 = text2.length();

        // Create a 2D array to store the lengths of longest common subsequences
        // for all subproblems, initialized with zero
        int[][] dp = new int[length1 + 1][length2 + 1];

        // Build the dp array from the bottom up
        for (int i = 1; i &lt;= length1; ++i) {
            for (int j = 1; j &lt;= length2; ++j) {
                // If characters match, take diagonal value and add 1
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                // If characters do not match, take the maximum value from 
                // the left (dp[i][j-1]) or above (dp[i-1][j])
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        // The bottom-right cell contains the length of the longest
        // common subsequence of text1 and text2
        return dp[length1][length2];
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    // Function to find the length of the longest common subsequence in two strings.
    int longestCommonSubsequence(string text1, string text2) {
        int text1Length = text1.size(), text2Length = text2.size();
        // Create a 2D array to store lengths of common subsequence at each index.
        int dp[text1Length + 1][text2Length + 1];

        // Initialize the 2D array with zero.
        memset(dp, 0, sizeof dp);

        // Loop through both strings and fill the dp array.
        for (int i = 1; i &lt;= text1Length; ++i) {
            for (int j = 1; j &lt;= text2Length; ++j) {
                // If current characters match, add 1 to the length of the sequence
                // until the previous character from both strings.
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // If current characters do not match, take the maximum length
                    // achieved by either skipping the current character of text1 or text2.
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // Return the value in the bottom-right cell which contains the
        // length of the longest common subsequence for the entire strings.
        return dp[text1Length][text2Length];
    }
};
</code></pre>
<pre><code class="language-Python">class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        #### Get the lengths of both input strings
        len_text1, len_text2 = len(text1), len(text2)

        #### Initialize a 2D array (list of lists) with zeros for dynamic programming
        #### The array has (len_text1 + 1) rows and (len_text2 + 1) columns
        dp_matrix = [[0] * (len_text2 + 1) for _ in range(len_text1 + 1)]

        #### Loop through each character index of text1 and text2
        for i in range(1, len_text1 + 1):
            for j in range(1, len_text2 + 1):
                #### If the characters match, take the diagonal value and add 1
                if text1[i - 1] == text2[j - 1]:
                    dp_matrix[i][j] = dp_matrix[i - 1][j - 1] + 1
                else:
                    #### If the characters do not match, take the maximum of the value from the left and above
                    dp_matrix[i][j] = max(dp_matrix[i - 1][j], dp_matrix[i][j - 1])

        #### The bottom-right value in the matrix contains the length of the longest common subsequence
        return dp_matrix[len_text1][len_text2]
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    // Lengths of the input strings
    const length1 = text1.length;
    const length2 = text2.length;

    // Create a 2D array to store the lengths of longest common subsequences
    // for all subproblems, initialized with zero
    const dp = new Array(length1 + 1).fill(0).map(() =&gt; new Array(length2 + 1).fill(0));

    // Build the dp array from the bottom up
    for (let i = 1; i &lt;= length1; ++i) {
        for (let j = 1; j &lt;= length2; ++j) {
            // If characters match, take diagonal value and add 1
            if (text1.charAt(i - 1) === text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            // If characters do not match, take the maximum value from 
            // the left (dp[i][j-1]) or above (dp[i-1][j])
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    // The bottom-right cell contains the length of the longest
    // common subsequence of text1 and text2
    return dp[length1][length2];
};
</code></pre></div><div class='python-solution'><h4>[Java/Python 3] Two DP codes of O(mn) & O(min(m, n)) spaces w/ picture and analysis [Votes: 324]</h4><p><strong>Update:</strong>
<strong>Q &amp; A:</strong></p>
<p>Q1: What is the difference between <code>[[0] * m] * n</code> and <code>[[0] * m for _ in range(n)]</code>? Why does the former update all the rows of that column when I try to update one particular cell ?
A1: <code>[[0] * m] * n</code> creates <code>n</code> references to the exactly same list objet: <code>[0] * m</code>; In contrast: <code>[[0] * m for _ in range(n)]</code> creates <code>n</code> different list objects that have same value of <code>[0] * m</code>.</p>
<p><strong>End of Q &amp; A</strong></p>
<p>-</p>
<p>Please refer to my solution <a href="https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/649858/JavaPython-3-2-Clean-DP-codes-of-O(mn)-and-O(min(m-n))-space-w-breif-explanation-and-analysis.">Java/Python 3 2 Clean DP codes of O(m * n) &amp; O(min(m, n)) space w/ breif explanation and analysis</a> of a similar problem: <a href="https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/">1458. Max Dot Product of Two Subsequences</a></p>
<p>More similar LCS problems:
<a href="https://leetcode.com/problems/shortest-common-supersequence/">1092. Shortest Common Supersequence</a> and <a href="https://leetcode.com/problems/shortest-common-supersequence/discuss/312757/JavaPython-3-O(mn)-clean-DP-code-w-picture-comments-and-analysis.">Solution</a>
<a href="https://leetcode.com/problems/longest-repeating-substring/">1062. Longest Repeating Substring</a> (Premium).
<a href="https://leetcode.com/problems/longest-palindromic-subsequence/">516. Longest Palindromic  Subsequence</a>
<a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/discuss/470709/JavaPython-3-DP-longest-common-subsequence-w-brief-explanation-and-analysis">1312. Minimum Insertion Steps to Make a String Palindrome</a></p>
<p>-
Find LCS;
Let <code>X</code> be <code>“XMJYAUZ”</code> and <code>Y</code> be <code>“MZJAWXU”</code>. The longest common subsequence between <code>X</code> and <code>Y</code> is <code>“MJAU”</code>. The following table shows the lengths of the longest common subsequences between prefixes of <code>X</code> and <code>Y</code>. The <code>ith</code> row and <code>jth</code> column shows the length of the LCS between <code>X_{1..i}</code> and <code>Y_{1..j}</code>.</p>
<p>you can refer to <a href="https://en.m.wikipedia.org/wiki/Longest_common_subsequence_problem">here</a> for more details.</p>
<p><strong>Method 1:</strong></p>
<pre><code class="language-java">    public int longestCommonSubsequence(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        for (int i = 0; i &lt; s1.length(); ++i)
            for (int j = 0; j &lt; s2.length(); ++j)
                if (s1.charAt(i) == s2.charAt(j)) dp[i + 1][j + 1] = 1 + dp[i][j];
                else dp[i + 1][j + 1] =  Math.max(dp[i][j + 1], dp[i + 1][j]);
        return dp[s1.length()][s2.length()];
    }
</code></pre>
<pre><code class="language-python">    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
        for i, c in enumerate(text1):
            for j, d in enumerate(text2):
                dp[i + 1][j + 1] = 1 + dp[i][j] if c == d else max(dp[i][j + 1], dp[i + 1][j])
        return dp[-1][-1]
</code></pre>
<p><strong>Analysis:</strong></p>
<p>Time &amp; space: O(m * n)</p>
<p><strong>Method 2:</strong></p>
<p><strong><em>Space Optimization</em></strong></p>
<p>credit to <strong>@FunBam</strong> for the following picture.</p>
<p>Obviously, the code in method 1 only needs information of previous row to update current row. So we just use a <strong>two-row</strong> 2D array to save and update the matching results for chars in <code>s1</code> and <code>s2</code>.</p>
<p>Note: use <code>k ^ 1</code> and <code>k ^= 1</code> to switch between <code>dp[0] (row 0)</code> and <code>dp[1] (row 1)</code>.</p>
<pre><code class="language-java">    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        if (m &lt; n)  return longestCommonSubsequence(s2, s1);
        int[][] dp = new int[2][n + 1];
        for (int i = 0, k = 1; i &lt; m; ++i, k ^= 1)
            for (int j = 0; j &lt; n; ++j)
                if (s1.charAt(i) == s2.charAt(j)) dp[k][j + 1] = 1 + dp[k ^ 1][j];
                else dp[k][j + 1] = Math.max(dp[k ^ 1][j + 1], dp[k][j]);
        return dp[m % 2][n];
    }
</code></pre>
<p>Note: use <code>1 - i % 2</code> and <code>i % 2</code> to switch between <code>dp[0] (row 0)</code> and <code>dp[1] (row 1)</code>.</p>
<pre><code class="language-python">    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        m, n = len(text1), len(text2)
        if m &lt; n:
            tex1, tex2 = text2, text1
        dp = [[0] * (n + 1) for _ in range(2)]
        for i, c in enumerate(text1):
            for j, d in enumerate(text2):
                dp[1 - i % 2][j + 1] = 1 + dp[i % 2][j] if c == d else max(dp[i % 2][j + 1], dp[1 - i % 2][j])
        return dp[m % 2][-1]
</code></pre>
<p><strong><em>Further Space Optimization to save half space</em></strong> - credit to <strong>@survive and @lenchen1112</strong>.</p>
<p>Obviously, the above code in method 2 only needs information of previous and current columns of previous row to update current row. So we just use a <strong>1-row</strong> 1D array and <code>2</code> variables to save and update the matching results for chars in <code>text1</code> and <code>text2</code>.</p>
<pre><code class="language-java">    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        if (m &lt; n) {
            return longestCommonSubsequence(text2, text1);
        }
        int[] dp = new int[n + 1];
        for (int i = 0; i &lt; text1.length(); ++i) {
            for (int j = 0, prevRow = 0, prevRowPrevCol = 0; j &lt; text2.length(); ++j) {
                prevRowPrevCol = prevRow;
                prevRow = dp[j + 1];
                dp[j + 1] = text1.charAt(i) == text2.charAt(j) ? prevRowPrevCol + 1 : Math.max(dp[j], prevRow);
            }
        }
        return dp[n];
    }
</code></pre>
<pre><code class="language-python">    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        m, n = map(len, (text1, text2))
        if m &lt; n:
            tex1, tex2 = text2, text1
        dp = [0] * (n + 1)
        for c in text1:
            prevRow, prevRowPrevCol = 0, 0
            for j, d in enumerate(text2):
                prevRow, prevRowPrevCol = dp[j + 1], prevRow
                dp[j + 1] = prevRowPrevCol + 1 if c == d else max(dp[j], prevRow)
        return dp[-1]
</code></pre>
<p><strong>Analysis:</strong></p>
<p>Time: O(m * n). space: O(min(m, n)).</p></div>