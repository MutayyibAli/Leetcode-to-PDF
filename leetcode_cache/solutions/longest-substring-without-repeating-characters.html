<div class='cpp-solution'><h4>âœ…3 Method's || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥ [Votes: 1925]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>The intuition behind the 3 solutions is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (<code>left</code> and <code>right</code>) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.</p>
<h4>Approach 1 - Set</h4>
<!-- Describe your approach to solving the problem. -->

<ol>
<li>We use a set (<code>charSet</code>) to keep track of unique characters in the current substring.</li>
<li>We maintain two pointers, <code>left</code> and <code>right</code>, to represent the boundaries of the current substring.</li>
<li>The <code>maxLength</code> variable keeps track of the length of the longest substring encountered so far.</li>
<li>We iterate through the string using the <code>right</code> pointer.</li>
<li>If the current character is not in the set (<code>charSet</code>), it means we have a new unique character.</li>
<li>We insert the character into the set and update the <code>maxLength</code> if necessary.</li>
<li>If the character is already present in the set, it indicates a repeating character within the current substring.</li>
<li>In this case, we move the <code>left</code> pointer forward, removing characters from the set until the repeating character is no longer present.</li>
<li>We insert the current character into the set and continue the iteration.</li>
<li>Finally, we return the <code>maxLength</code> as the length of the longest substring without repeating characters.</li>
</ol>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();
        int maxLength = 0;
        unordered_set&lt;char&gt; charSet;
        int left = 0;

        for (int right = 0; right &lt; n; right++) {
            if (charSet.count(s[right]) == 0) {
                charSet.insert(s[right]);
                maxLength = max(maxLength, right - left + 1);
            } else {
                while (charSet.count(s[right])) {
                    charSet.erase(s[left]);
                    left++;
                }
                charSet.insert(s[right]);
            }
        }

        return maxLength;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;
        Set&lt;Character&gt; charSet = new HashSet&lt;&gt;();
        int left = 0;

        for (int right = 0; right &lt; n; right++) {
            if (!charSet.contains(s.charAt(right))) {
                charSet.add(s.charAt(right));
                maxLength = Math.max(maxLength, right - left + 1);
            } else {
                while (charSet.contains(s.charAt(right))) {
                    charSet.remove(s.charAt(left));
                    left++;
                }
                charSet.add(s.charAt(right));
            }
        }

        return maxLength;
    }
}

</code></pre>
<pre><code class="language-Python3">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        n = len(s)
        maxLength = 0
        charSet = set()
        left = 0

        for right in range(n):
            if s[right] not in charSet:
                charSet.add(s[right])
                maxLength = max(maxLength, right - left + 1)
            else:
                while s[right] in charSet:
                    charSet.remove(s[left])
                    left += 1
                charSet.add(s[right])

        return maxLength

</code></pre>
<h4>Approach 2 - Unordered Map</h4>
<ol>
<li>We improve upon the first solution by using an unordered map (<code>charMap</code>) instead of a set.</li>
<li>The map stores characters as keys and their indices as values.</li>
<li>We still maintain the <code>left</code> and <code>right</code> pointers and the <code>maxLength</code> variable.</li>
<li>We iterate through the string using the <code>right</code> pointer.</li>
<li>If the current character is not in the map or its index is less than <code>left</code>, it means it is a new unique character.
6 We update the <code>charMap</code> with the character's index and update the <code>maxLength</code> if necessary.</li>
<li>If the character is repeating within the current substring, we move the <code>left</code> pointer to the next position after the last occurrence of the character.</li>
<li>We update the index of the current character in the <code>charMap</code> and continue the iteration.</li>
<li>At the end, we return the <code>maxLength</code> as the length of the longest substring without repeating characters.</li>
</ol>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();
        int maxLength = 0;
        unordered_map&lt;char, int&gt; charMap;
        int left = 0;

        for (int right = 0; right &lt; n; right++) {
            if (charMap.count(s[right]) == 0 || charMap[s[right]] &lt; left) {
                charMap[s[right]] = right;
                maxLength = max(maxLength, right - left + 1);
            } else {
                left = charMap[s[right]] + 1;
                charMap[s[right]] = right;
            }
        }

        return maxLength;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;
        Map&lt;Character, Integer&gt; charMap = new HashMap&lt;&gt;();
        int left = 0;

        for (int right = 0; right &lt; n; right++) {
            if (!charMap.containsKey(s.charAt(right)) || charMap.get(s.charAt(right)) &lt; left) {
                charMap.put(s.charAt(right), right);
                maxLength = Math.max(maxLength, right - left + 1);
            } else {
                left = charMap.get(s.charAt(right)) + 1;
                charMap.put(s.charAt(right), right);
            }
        }

        return maxLength;
    }
}

</code></pre>
<pre><code class="language-Python3">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        n = len(s)
        maxLength = 0
        charMap = {}
        left = 0

        for right in range(n):
            if s[right] not in charMap or charMap[s[right]] &lt; left:
                charMap[s[right]] = right
                maxLength = max(maxLength, right - left + 1)
            else:
                left = charMap[s[right]] + 1
                charMap[s[right]] = right

        return maxLength

</code></pre>
<h4>Approach 3 - Integer Array</h4>
<ol>
<li>This solution uses an integer array <code>charIndex</code> to store the indices of characters.</li>
<li>We eliminate the need for an unordered map by utilizing the array.</li>
<li>The <code>maxLength</code>, <code>left</code>, and <code>right</code> pointers are still present.</li>
<li>We iterate through the string using the <code>right</code> pointer.</li>
<li>We check if the current character has occurred within the current substring by comparing its index in <code>charIndex</code> with <code>left</code>.</li>
<li>If the character has occurred, we move the <code>left</code> pointer to the next position after the last occurrence of the character.</li>
<li>We update the index of the current character in <code>charIndex</code>.</li>
<li>At each step, we update the <code>maxLength</code> by calculating the length of the current substring.</li>
<li>We continue the iteration until reaching the end of the string.</li>
<li>Finally, we return the <code>maxLength</code> as the length of the longest substring without repeating characters.</li>
</ol>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();
        int maxLength = 0;
        vector&lt;int&gt; charIndex(128, -1);
        int left = 0;

        for (int right = 0; right &lt; n; right++) {
            if (charIndex[s[right]] &gt;= left) {
                left = charIndex[s[right]] + 1;
            }
            charIndex[s[right]] = right;
            maxLength = max(maxLength, right - left + 1);
        }

        return maxLength;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;
        int[] charIndex = new int[128];
        Arrays.fill(charIndex, -1);
        int left = 0;

        for (int right = 0; right &lt; n; right++) {
            if (charIndex[s.charAt(right)] &gt;= left) {
                left = charIndex[s.charAt(right)] + 1;
            }
            charIndex[s.charAt(right)] = right;
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}

</code></pre>
<pre><code class="language-Python3">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        n = len(s)
        maxLength = 0
        charIndex = [-1] * 128
        left = 0

        for right in range(n):
            if charIndex[ord(s[right])] &gt;= left:
                left = charIndex[ord(s[right])] + 1
            charIndex[ord(s[right])] = right
            maxLength = max(maxLength, right - left + 1)

        return maxLength

</code></pre>
<p><strong>If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.</strong></p></div>