<div class='cpp-solution'><h4>üî•Easy Solutions with Exaplanation in Java üìù, Python üêç, and C++ üñ•Ô∏èüßêLook at once üíª [Votes: 132]</h4><h4>Intuition</h4>
<p>We can use DFS to traverse the tree and change the direction of edges if needed.</p>
<h4>Approach</h4>
<p>First, we create an adjacency list to represent the tree. Each node in the list contains a list of its neighbors.</p>
<p>To change the direction of edges, we assign a direction to each edge. If an edge goes from node i to node j, we represent it as i -&gt; j. If an edge goes from node j to node i, we represent it as j -&gt; -i.</p>
<p>Then, we start DFS from node 0. We mark visited nodes to avoid revisiting them. If we reach a node i that has not been visited before, it means we need to change the direction of the edge that leads to node i. We do this by adding 1 to the result if the edge is directed from node j to node i (i.e., j -&gt; i), and 0 otherwise (i.e., j -&gt; -i).</p>
<p>We repeat this process until all nodes have been visited.</p>
<p>Finally, we return the total number of edges that we have changed.</p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity: O(n), where n is the number of nodes in the tree. We traverse the tree once using DFS.</p>
</li>
<li>
<p>Space complexity: O(n), where n is the number of nodes in the tree. We use a boolean array to keep track of visited nodes. Also, we use an adjacency list to represent the tree, which requires O(n) space.</p>
</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution. Keep Learning
Please give my solution an upvote! 
It's a simple way to show your appreciation and
keep me motivated. Thank you! 
</code></pre>
<h4>Code</h4>
<pre><code class="language-Java">class Solution {
    int dfs(List&lt;List&lt;Integer&gt;&gt; al, boolean[] visited, int from) {
        int change = 0;
        visited[from] = true;
        for (var to : al.get(from))
            if (!visited[Math.abs(to)])
                change += dfs(al, visited, Math.abs(to)) + (to &gt; 0 ? 1 : 0);
        return change;   
    }
    public int minReorder(int n, int[][] connections) {
        List&lt;List&lt;Integer&gt;&gt; al = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; n; ++i) 
            al.add(new ArrayList&lt;&gt;());
        for (var c : connections) {
            al.get(c[0]).add(c[1]);
            al.get(c[1]).add(-c[0]);
        }
        return dfs(al, new boolean[n], 0);
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int dfs(vector&lt;vector&lt;int&gt;&gt; &amp;al, vector&lt;bool&gt; &amp;visited, int from) {
    auto change = 0;
    visited[from] = true;
    for (auto to : al[from])
        if (!visited[abs(to)])
            change += dfs(al, visited, abs(to)) + (to &gt; 0);
    return change;        
    }
    int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {
        vector&lt;vector&lt;int&gt;&gt; al(n);
        for (auto &amp;c : connections) {
            al[c[0]].push_back(c[1]);
            al[c[1]].push_back(-c[0]);
        }
        return dfs(al, vector&lt;bool&gt;(n) = {}, 0);
    }
};
</code></pre>
<pre><code class="language-Python">class Solution:
    def dfs(self, al, visited, from_node):
        change = 0
        visited[from_node] = True
        for to_node in al[from_node]:
            if not visited[abs(to_node)]:
                change += self.dfs(al, visited, abs(to_node)) + (1 if to_node &gt; 0 else 0)
        return change

    def minReorder(self, n, connections):
        al = [[] for _ in range(n)]
        for c in connections:
            al[c[0]].append(c[1])
            al[c[1]].append(-c[0])
        visited = [False] * n
        return self.dfs(al, visited, 0)

</code></pre>
<h4>Please Comment</h4>
<pre><code>Thanks for visiting my solution comment below if you like it.
</code></pre></div>