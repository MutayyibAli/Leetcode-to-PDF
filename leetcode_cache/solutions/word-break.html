<div class='cpp-solution'><h4>C++ Dynamic Programming simple and fast solution (4ms) with optimization [Votes: 560]</h4><p>We use a boolean vector dp[]. dp[<strong><em>i</em></strong>] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position <strong><em>i</em></strong> back and only substring and do dictionary look up in case the preceding position <strong><em>j</em></strong> with <em>dp[</em><em>j</em><em>] == true</em> is found.</p>
<pre><code>bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) {
        if(dict.size()==0) return false;

        vector&lt;bool&gt; dp(s.size()+1,false);
        dp[0]=true;

        for(int i=1;i&lt;=s.size();i++)
        {
            for(int j=i-1;j&gt;=0;j--)
            {
                if(dp[j])
                {
                    string word = s.substr(j,i-j);
                    if(dict.find(word)!= dict.end())
                    {
                        dp[i]=true;
                        break; //next i
                    }
                }
            }
        }

        return dp[s.size()];
    }
</code></pre></div><div class='python-solution'><h4>Solution [Votes: 462]</h4><pre><code class="language-cpp">class Solution {
 public:
  bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
    const int n = s.length();
    const int maxLength = getMaxLength(wordDict);
    const unordered_set&lt;string&gt; wordSet{begin(wordDict), end(wordDict)};
    vector&lt;int&gt; dp(n + 1);
    dp[0] = true;

    for (int i = 1; i &lt;= n; ++i)
      for (int j = i - 1; j &gt;= 0; --j) {
        if (i - j &gt; maxLength)
          break;
        if (dp[j] &amp;&amp; wordSet.count(s.substr(j, i - j))) {
          dp[i] = true;
          break;
        }
      }

    return dp[n];
  }

 private:
  int getMaxLength(const vector&lt;string&gt;&amp; wordDict) {
    return max_element(begin(wordDict), end(wordDict),
                       [](const auto&amp; a, const auto&amp; b) {
                         return a.length() &lt; b.length();
                       })
        -&gt;length();
  }
};
</code></pre>
<pre><code class="language-Python3">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:

        def construct(current,wordDict, memo={}):
            if current in memo:
                return memo[current]

            if not current:
                return True

            for word in wordDict:
                if current.startswith(word):
                    new_current = current[len(word):]
                    if construct(new_current,wordDict,memo):
                        memo[current] = True
                        return True

            memo[current] = False
            return False

        return construct(s,wordDict)
</code></pre>
<pre><code class="language-Java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        return recWay1(s, wordDict);
    }

    boolean recWay2(String s, List&lt;String&gt; wordDict) {
        Boolean[] memo = new Boolean[s.length() + 1];
        return wordBreak2(s, new HashSet&lt;&gt;(wordDict), 0, memo);
    }

    boolean wordBreak2(String s, Set&lt;String&gt; wordDict, int k, Boolean[] memo) {
        int n = s.length();
        if (k == n) return true;

        if (memo[k] != null) return memo[k];

        for (int i=k + 1; i&lt;=n; i++) {
            String word = s.substring(k, i);
            if (wordDict.contains(word) &amp;&amp; wordBreak2(s, wordDict, i, memo)) {
                return memo[k] = true;
            }
        }

        return memo[k] = false;
    }

    boolean recWay1(String s, List&lt;String&gt; wordDict) {
        Boolean[] memo = new Boolean[s.length() + 1];
        return wordBreak(s, wordDict, 0, memo);
    }

    boolean wordBreak(String s, List&lt;String&gt; wordDict, int k, Boolean[] memo) {
        if (k == s.length()) {
            return true;
        }

        if (memo[k] != null) {
            return memo[k];
        }

        for (int i=0; i&lt;wordDict.size(); i++) {
            String word = wordDict.get(i);
            if (s.startsWith(word, k)) {
                if(wordBreak(s, wordDict, k + word.length(), memo)) return memo[k] = true;
            }
        }

        return memo[k] = false;
    }
}
</code></pre></div>