<div class='cpp-solution'><h4>C++ BFS/DFS [Votes: 655]</h4><p>This problem is equivalent to detecting a cycle in the directed graph represented by <code>prerequisites</code>. Both BFS and DFS can be used to solve it using the idea of <strong>topological sort</strong>. Since <code>pair&lt;int, int&gt;</code> is inconvenient for implementing graph algorithms, we first transform it to the adjacency-list representation. If course <code>u</code> is a prerequisite of course <code>v</code>, then the adjacency list of <code>u</code> will contain <code>v</code>.</p>
<p><strong>BFS</strong></p>
<p>BFS uses the indegrees of each node. We will first try to find a node with <code>0</code> indegree. If we fail to do so, there must be a cycle in the graph and we return <code>false</code>. Otherwise we set its indegree to be <code>-1</code> to prevent from visiting it again and reduce the indegrees of its neighbors by <code>1</code>. This process will be repeated for <code>n</code> (number of nodes) times.</p>
<pre><code class="language-cpp">class Solution {
public:
    bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector&lt;int&gt; degrees = computeIndegrees(g);
        for (int i = 0; i &lt; numCourses; i++) {
            int j = 0;
            for (; j &lt; numCourses; j++) {
                if (!degrees[j]) {
                    break;
                }
            }
            if (j == numCourses) {
                return false;
            }
            degrees[j]--;
            for (int v : g[j]) {
                degrees[v]--;
            }
        }
        return true;
    }
private:
    typedef vector&lt;vector&lt;int&gt;&gt; graph;

    graph buildGraph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }

    vector&lt;int&gt; computeIndegrees(graph&amp; g) {
        vector&lt;int&gt; degrees(g.size(), 0);
        for (auto adj : g) {
            for (int v : adj) {
                degrees[v]++;
            }
        }
        return degrees;
    }
};
</code></pre>
<p><strong>DFS</strong></p>
<p>For DFS, in each visit, we start from a node and keep visiting its neighbors, if at a time we return to a visited node, there is a cycle. Otherwise, start again from another unvisited node and repeat this process. We use <code>todo</code> and <code>done</code> for nodes to visit and visited nodes.</p>
<pre><code class="language-cpp">class Solution {
public:
    bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector&lt;bool&gt; todo(numCourses, false), done(numCourses, false);
        for (int i = 0; i &lt; numCourses; i++) {
            if (!done[i] &amp;&amp; !acyclic(g, todo, done, i)) {
                return false;
            }
        }
        return true;
    }
private:
    typedef vector&lt;vector&lt;int&gt;&gt; graph;

    graph buildGraph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }

    bool acyclic(graph&amp; g, vector&lt;bool&gt;&amp; todo, vector&lt;bool&gt;&amp; done, int node) {
        if (todo[node]) {
            return false;
        }
        if (done[node]) {
            return true;
        }
        todo[node] = done[node] = true;
        for (int v : g[node]) {
            if (!acyclic(g, todo, done, v)) {
                return false;
            }
        }
        todo[node] = false;
        return true;
    }
};
</code></pre></div><div class='python-solution'><h4>Python 20 lines DFS solution sharing with explanation [Votes: 472]</h4><pre><code>def canFinish(self, numCourses, prerequisites):
    graph = [[] for _ in xrange(numCourses)]
    visit = [0 for _ in xrange(numCourses)]
    for x, y in prerequisites:
        graph[x].append(y)
    def dfs(i):
        if visit[i] == -1:
            return False
        if visit[i] == 1:
            return True
        visit[i] = -1
        for j in graph[i]:
            if not dfs(j):
                return False
        visit[i] = 1
        return True
    for i in xrange(numCourses):
        if not dfs(i):
            return False
    return True
</code></pre>
<ol>
<li>if node <code>v</code> has not been visited, then mark it as <code>0</code>.</li>
<li>if node <code>v</code> is being visited, then mark it as <code>-1</code>. If we find a vertex marked as <code>-1</code> in DFS, then their is a ring.</li>
<li>if node <code>v</code> has been visited, then mark it as <code>1</code>. If a vertex was marked as <code>1</code>, then no ring contains <code>v</code> or its successors.</li>
</ol>
<p><em>References: <a href="http://daoluan.net/blog/map-ring/">daoluan.net</a></em> </p></div>