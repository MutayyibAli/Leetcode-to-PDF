<div class='cpp-solution'><h4>Backtracking Solution || C++ || Easy To Understand || With explanation [Votes: 153]</h4><p>Suppose if give string is ABC then recursive tree like this</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; result;

    // Backtracking
    void permutation(vector&lt;int&gt; &amp;nums,int i,int n){
        if(i==n){
            result.push_back(nums);
            return ;
        }

        for(int j=i;j&lt;=n;j++){
            swap( nums[i],nums[j]);
            permutation(nums,i+1,n);
            swap( nums[i],nums[j]);
        }
    }

    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {

        permutation(nums,0,nums.size()-1);

        return result;
    }
};
</code></pre></div><div class='python-solution'><h4>Simple Python solution (DFS). [Votes: 655]</h4><pre><code>    
#### DFS
def permute(self, nums):
    res = []
    self.dfs(nums, [], res)
    return res

def dfs(self, nums, path, res):
    if not nums:
        res.append(path)
        #### return #### backtracking
    for i in xrange(len(nums)):
        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)
</code></pre></div>