<div class='cpp-solution'><h4>✅☑️ Best C++ 3 Solution || DP || Space optimization || Brute Force -> Optimize || One Stop Solution. [Votes: 1095]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>We can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).</p>
<ol>
<li>Solved using Array(Two Nested Loops). Brute Force Approach.</li>
<li>Solved using Dynamic Programming Approach(tabulation).</li>
<li>Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.</li>
</ol>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>We can easily understand the All the approaches by seeing the code which is easy to understand with comments.</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>Time complexity is given in code comment.</p>
<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>Space complexity is given in code comment.</p>
<h4>Code</h4>
<pre><code>/*

    Time Complexity : O(N^2), Where N is the size of the Array(nums). Here Two nested loop creates the time 
    complexity.

    Space complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the
    output does not count towards the space complexity.

    Solved using Array(Two Nested Loop). Brute Force Approach.

    Note : This will give TLE.

*/


/***************************************** Approach 1 *****************************************/

class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; output;
        for(int i=0; i&lt;n; i++){
            int product = 1;
            for(int j=0; j&lt;n; j++){
                if(i == j) continue;
                product *= nums[j];
            }
            output.push_back(product);
        }
        return output;
    }
};






/*

    Time Complexity : O(N), As we iterate the Array(nums) thrice. Where N = size of the array.

    Space complexity : O(N), Array(left_Product and right_Product) space. 

    Solved using Dynamic Programming Approach(tabulation).

*/


/***************************************** Approach 2 *****************************************/

class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; ans(n);
        vector&lt;int&gt; left_Product(n);
        vector&lt;int&gt; right_Product(n);
        left_Product[0] = 1;
        for(int i=1; i&lt;n; i++){
            left_Product[i] = left_Product[i-1] * nums[i-1];
        }
        right_Product[n-1] = 1;
        for(int i=n-2; i&gt;=0; i--){
            right_Product[i] = right_Product[i+1] * nums[i+1];
        }
        for(int i=0; i&lt;n; i++){
            ans[i] = left_Product[i] * right_Product[i];
        }
        return ans;
    }
};






/*

    Time Complexity : O(N), As we iterate the Array(nums) twice. Where N = size of the array.

    Space complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the
    output does not count towards the space complexity.

    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.

*/


/***************************************** Approach 3 *****************************************/

class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; output(n);
        output[0] = 1;
        for(int i=1; i&lt;n; i++){
            output[i] = output[i-1] * nums[i-1];
        }
        int right = 1;
        for(int i=n-1; i&gt;=0; i--){
            output[i] *= right;
            right *= nums[i];
        }
        return output;
    }
};

</code></pre>
<p><strong><em>IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.</em></strong></p></div><div class='python-solution'><h4>Simple and easy 1 min explanation in Python and JAVA [Votes: 296]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>Similar to finding Prefix Sum array, here the preblem intends us to find the Prefix Product Array and Suffix Product Array for our original array.</p>
<pre><code>pre[i+1] = pre[i] * a[i]
suff[i-1] = suff[i] * a[i]
</code></pre>
<h4>Complexity</h4>
<ul>
<li>Time complexity: $$O(n)$$
Only 2 loops iterating $$n$$ times each without any nesting.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: $$O(n)$$
We have taken prefix and suffixProduct as variables instead of arrays to further optimize space, even though the overall complexity remains the same.</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Code</h4>
<pre><code class="language-java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int numsLength = nums.length;
        int prefixProduct = 1;
        int suffixProduct = 1;
        int[] result = new int[numsLength];
        for(int i = 0; i &lt; numsLength; i++) {
            result[i] = prefixProduct;
            prefixProduct *= nums[i];
        }
        for(int i = numsLength-1; i &gt;= 0; i--) {
            result[i] *= suffixProduct;
            suffixProduct *= nums[i];
        }
        return result;
    }
}
</code></pre>
<pre><code class="language-python3">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        n = len(nums)
        prefix_product = 1
        postfix_product = 1
        result = [0]*n
        for i in range(n):
            result[i] = prefix_product
            prefix_product *= nums[i]
        for i in range(n-1,-1,-1):
            result[i] *= postfix_product
            postfix_product *= nums[i]
        return result
</code></pre>
<p><em>Please upvote, if this helped you understand the solution in optimal time :)</em></p></div>