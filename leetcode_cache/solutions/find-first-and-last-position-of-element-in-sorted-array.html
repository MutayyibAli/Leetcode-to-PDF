<div class='cpp-solution'><h4>✅☑️ Best C++ 2 Solution || Binary Search || Linear Search || Brute Force->Optimize || One Stop Solu. [Votes: 398]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>We can Solved this question using Two approach. (Here I have explained all the possible solutions of this problem).</p>
<ol>
<li>Solved using Linear Search (Brute Force Approach).</li>
<li>Solved using Binary Search (Optimized Approach).</li>
</ol>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<p>We can easily understand the All the approaches by seeing the code which is easy to understand with comments.</p>
<h4>Complexity</h4>
<ul>
<li>Time complexity:</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<p>Time complexity is given in code comment.</p>
<ul>
<li>Space complexity:</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<p>Space complexity is given in code comment.</p>
<h4>Code</h4>
<pre><code>/*

    Time Complexity : O(N), because in the worst case we traverse the &lt;= N element. Where N is the size of the
    Array(nums).

    Space Complexity : O(1), the space complexity is constant.

    Solved using Linear Search.

*/


/***************************************** Approach 1 First Code *****************************************/

class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int startingPosition = -1, endingPosition = -1;
        int n = nums.size();
        for(int i=0; i&lt;n; i++){
            if(nums[i] == target){
                startingPosition = i;
                break;
            }
        }
        for(int i=n-1; i&gt;=0; i--){
            if(nums[i] == target){
                endingPosition = i;
                break;
            }
        }
        return {startingPosition, endingPosition};
    }
};






/*

    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity
    is logarithmic.

    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is
    constant.

    Solved using Binary Search.

*/


/***************************************** Approach 2 First Code *****************************************/

class Solution {
private:
    int lower_bound(vector&lt;int&gt;&amp; nums, int low, int high, int target){
        while(low &lt;= high){
            int mid = (low + high) &gt;&gt; 1;
            if(nums[mid] &lt; target){
                low = mid + 1;
            }
            else{
                high = mid - 1;
            }
        }
        return low;
    }
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int low = 0, high = nums.size()-1;
        int startingPosition = lower_bound(nums, low, high, target);
        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;
        if(startingPosition &lt; nums.size() &amp;&amp; nums[startingPosition] == target){
            return {startingPosition, endingPosition};
        }
        return {-1, -1};
    }
};






/***************************************** Approach 2 Second Code *****************************************/

class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;
        if(startingPosition &lt; nums.size() &amp;&amp; nums[startingPosition] == target){
            return {startingPosition, endingPosition};
        }
        return {-1, -1};
    }
};

</code></pre>
<p><strong><em>IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.</em></strong></p></div><div class='python-solution'><h4>Python O(logn) [Votes: 279]</h4><pre><code class="language-python">class Solution:
    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:

        def search(x):
            lo, hi = 0, len(nums)           
            while lo &lt; hi:
                mid = (lo + hi) // 2
                if nums[mid] &lt; x:
                    lo = mid+1
                else:
                    hi = mid                    
            return lo

        lo = search(target)
        hi = search(target+1)-1

        if lo &lt;= hi:
            return [lo, hi]

        return [-1, -1]
</code></pre></div>