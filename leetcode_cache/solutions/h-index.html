<div class='cpp-solution'><h4>H-Index || Easy solution || brute force or Binary Search âœ…âœ… [Votes: 75]</h4><h4>Intuition</h4>
<ul>
<li>The problem is to find the h-index of a researcher based on their citation counts. The h-index is the maximum value h such that the researcher has published at least h papers that have each been cited at least h times.</li>
</ul>
<h4>Approach</h4>
<ul>
<li><strong><em>Two common approaches to solve this problem are:</em></strong></li>
</ul>
<h4>1. Brute Force Approach:</h4>
<ul>
<li>Sort the array of citations in descending order and iterate through the sorted array. For each paper, check if its citation count is greater than or equal to its position in the sorted array. Keep track of the maximum h-index encountered. This approach has a time complexity of O(n log n) due to the sorting step.</li>
</ul>
<h4>2. Binary Search Approach:</h4>
<ul>
<li>Sort the array of citations and perform a binary search to find the h-index. Initialize a search range between 0 and the length of the citations array. In each iteration, calculate the mid-point and count the number of papers with citations greater than or equal to the mid-point. Adjust the search range based on this count. This approach has a time complexity of O(n log n) due to the sorting step.</li>
</ul>
<h4>Complexity</h4>
<h4>- Time complexity:</h4>
<ol>
<li><strong>Code 1 (Brute Force)</strong></li>
<li>
<p>Time complexity: O(n log n) - Sorting the array takes O(n log n) time, and the subsequent iteration takes O(n) time.</p>
</li>
<li>
<p><strong>Code 2 (Binary Search)</strong></p>
</li>
<li>Time complexity: O(n log n) - Sorting the array takes O(n log n) time, and the binary search takes O(log n) time.</li>
</ol>
<h4>- Space complexity:</h4>
<ol>
<li><strong>Code 1 (Brute Force)</strong></li>
<li>
<p>Space complexity: O(1) - Constant space is used.</p>
</li>
<li>
<p><strong>Code 2 (Binary Search)</strong></p>
</li>
<li>Space complexity: O(1) - Constant space is used.</li>
</ol>
<h4>Code 1.</h4>
<pre><code>class Solution {
public:

    int hIndexBruteForce(vector&lt;int&gt;&amp; c) {
        sort(c.begin(), c.end());
        int n = c.size();
        int maxi = 0;
        for(int i = 0; i &lt; n; i++) {
            if(c[i] &gt;= n - i) {
                maxi = max(maxi, n - i);
            }
        }
        return maxi;
    }

    int hIndex(vector&lt;int&gt;&amp; citations) {
        return hIndexBruteForce(citations);
    }
};
</code></pre>
<h4>Code 2.</h4>
<pre><code>class Solution
{
public:
    int hIndex(vector&lt;int&gt; &amp;citations)
    {
        sort(citations.begin(), citations.end());
        int n = citations.size();
        int start = 0, end = n - 1;
        int ans = 0;
        while (start &lt;= end)
        {
            int mid = start + (end - start) / 2;
            if (citations[mid] &gt;= n - mid)
            {
                ans = max(ans, n - mid);
                end = mid - 1;
            }
            else
            {
                start = mid + 1;
            }
        }
        return ans;
    }
};
</code></pre></div><div class='python-solution'><h4>âœ… Python || ðŸ”¥2 ApproachesðŸ”¥ || Sorting & Counting || Summary with ComparisonðŸ”¥ðŸ”¥ðŸ”¥ [Votes: 217]</h4><h4>IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE</h4>
<h4>Approach: 1  Sorting and Iteration</h4>
<ul>
<li><strong>Sorting:</strong> Sorts the <code>citations</code> list in ascending order.</li>
<li><strong>Iterative Check:</strong> Iterates through the sorted list.
For each citation <code>v</code> at index <code>i</code>:<ul>
<li>If <code>n - i</code>(number of articles with at least <code>n - i</code> citations) is less than or equal to <code>v</code> itself (the current citation count), it means the h-index is <code>n - i</code>.</li>
<li>Returns <code>n - i</code> as the <code>h-index</code>.</li>
</ul>
</li>
<li><strong>Default Return:</strong> If no valid <code>h-index</code> is found, returns <code>0</code>.</li>
</ul>
<h4>Code : 1</h4>
<pre><code>class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        n = len(citations)
        citations.sort()

        for i,v in enumerate(citations):
            if n - i &lt;= v:
                return n - i
        return 0
</code></pre>
<h4>Approach: 2 Counting Frequency and Backward Iteration</h4>
<ul>
<li><strong>Frequency Array:</strong> Creates a temporary array <code>temp</code> of size <code>n + 1</code> to store citation frequencies.</li>
<li><strong>Counting Citations:</strong> Iterates through the <code>citations</code> list:<ul>
<li>If a citation <code>v</code> is greater than <code>n</code>, adds it to the highest frequency bucket (<code>temp[n]</code>).</li>
<li>Otherwise, increments the count in the corresponding bucket (<code>temp</code>[v]).</li>
</ul>
</li>
<li><strong>Calculating h-index:</strong> Iterates backward through the <code>temp</code> array:<ul>
<li>Accumulates the <code>total</code> number of citations up to each index <code>i</code>.</li>
<li>If the total count (total) is greater than or equal to <code>i</code> itself, it means <code>i</code> is the <code>h-index</code>.</li>
<li>Returns <code>i</code> as the <code>h-index</code>.</li>
</ul>
</li>
</ul>
<h4>Code : 2</h4>
<pre><code>class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        n = len(citations)
        temp = [0 for _ in range(n + 1)]

        for i,v in enumerate(citations):
            if v &gt; n :
                temp[n] += 1
            else:
                temp[v] += 1

        total = 0
        for i in range(n, -1, -1):
            total += temp[i]
            if total &gt;= i:
                return i
</code></pre>
<h4>Comparison Table:</h4>
<p>Feature | Code 1    | Code 2
---------|--------|-Approach    | Sorting and iteration Frequency | counting and backward iteration
Time Complexity | O(n log n) due to sorting | O(n)
Space Complexity    | O(1)  | O(n) for temp array
Advantages  | Simpler to understand | Linear time complexity
Disadvantages   | Slower for large inputs   | Requires extra space for temp array</p>
<h6>If you found my solution and information helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.</h6></div>