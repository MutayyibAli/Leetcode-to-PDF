<div class='cpp-solution'><h4>✅C++ || All testcase passed->2 SOLUTION -> 10 LINES CODE [Votes: 47]</h4><p><strong>✅APPROACH : 1</strong></p>
<h4>VERY EASY SOLUTION -&gt; NO THINKING NEEDED JUST DO WHAT IS SAID IN QUESTION--&gt;</h4>
<ul>
<li><strong><em>sort the string list</em></strong></li>
<li><strong><em>create a temp vector to store the answer in each stage and then push it back</em></strong></li>
</ul>
<pre><code>vector&lt;vector&lt;string&gt;&gt; suggestedProducts(vector&lt;string&gt;&amp; products, string searchWord) {
        int n=products.size();
        sort(products.begin(),products.end());
        vector&lt;vector&lt;string&gt;&gt;ans;
        vector&lt;string&gt;temp;
        string curr=&quot;&quot;;
        for(auto c:searchWord){
            curr+=c;                // adding character, like -&gt; m--&gt;mo--&gt;mou--&gt;mous---&gt;mouse
            temp.clear();         //reusing the same vector
            for(int i=0;i&lt;n;i++){
                string s=products[i];
                if(s.substr(0,curr.length())==curr){              //finding the prefix containing words in the list
                    temp.push_back(s);
                }
                if(temp.size()==3)break;         //question asked for 3 words so we break at 3
            }
            ans.push_back(temp);
        }
        return ans;
    }
</code></pre>
<h4>✔ THIS WAS A VERY EASY SOLUTION BUT IT TAKES A LOT OF TIME ---&gt; SO WE NEED TO OPTIMIZE IT</h4>
<h4>✔ FOR OPTIMIZING WE USE BINARY SEARCH</h4>
<h4>✔ WHY BINARY SEARCH?? WHERE AND HOW??</h4>
<p><strong>LETS SEE----&gt;</strong></p>
<ul>
<li><strong>When the list is sorted the we know they are in increasing order(lexographically)</strong></li>
<li><strong>if we find 'mou' first at the index 3 then we are sure that we can not find any word containing 'mou' before index 3--&gt;Why?? --&gt; as before index 3 the words are smaller and in the sorted list we find it for the first time at index 3</strong></li>
<li><strong>How to find the index 3(as example) then?? --&gt; we will use lower_bound() -&gt; it returns the first occurance of searched element</strong></li>
<li><strong>lower_bound() gives us the index in a binary search manner---&gt; you can use lower_bound() stl or write a function for yourself</strong></li>
</ul>
<pre><code>vector&lt;vector&lt;string&gt;&gt; suggestedProducts(vector&lt;string&gt;&amp; products, string searchWord) {
        auto start=products.begin();
        sort(start,products.end());
        vector&lt;vector&lt;string&gt;&gt;ans;
        vector&lt;string&gt;temp;
        string curr=&quot;&quot;;
        for(auto c:searchWord){
            curr+=c;
            temp.clear();                       //upto this same as previous code
            start=lower_bound(start,products.end(),curr);      // providing first occurance
            for(int i=0;i&lt;3 &amp;&amp; start+i!=products.end();i++){         //question asked 3 times so i&lt;3 and start+i!=products.end() -&gt; checks if we are out of index or not
                string s=*(start+i);        //(start+i) gives the pointer and *(start+i) gives the value at the pointer-&gt;here string
                if(s.find(curr))break;         //if we dont find the curr then we are sure that we are not going to find it in the upcoming words as they are in sorted manner
                temp.push_back(s);
            }
            ans.push_back(temp);
        }
        return ans;
    }
</code></pre>
<h4>✅ Hope this helped a little bit--&gt; if so please upvote it.</h4>
<p>✅ Happy Coding </p></div><div class='python-solution'><h4>JS, Python, Java, C++ | Easy Iterative Solution w/ Explanation [Votes: 49]</h4><p><em>(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,</em> <strong><em>please upvote</em></strong> <em>this post.)</em></p>
<h6># <strong><em>Idea:</em></strong></h6>
<p>Despite the fact that the clues suggest a <strong>binary search</strong> and a <strong>trie</strong>, the optimal solution to this problem needs neither. The substrings formed by adding one letter at a time from the search word (<strong>S</strong>) are naturally already in lexicographical order, as are the results that we're instructed to push into our answer array (<strong>ans</strong>).</p>
<p>So if we sort the products array (<strong>P</strong>), we should only ever need to iterate through <strong>P</strong> once during the entire remaining process of the solution with a <strong>time complexity</strong> of <strong>O(N)</strong>. A single binary search would only require <strong>log(N) time</strong>, but we'd have to perform <strong>M = S.length</strong> binary searches, so in total they would take <strong>O(M * log(N)) time</strong>, compared to the <strong>O(N)</strong> time of a simple iteration.</p>
<p>With constraints of <strong>1000</strong> on both <strong>M</strong> and <strong>N</strong>, the binary search route would max out at a worse time complexity than iteration. Regardless, the sort itself, which is required for both, requires <strong>O(N * log(N))</strong> time already, so neither option can decrease the overall time complexity required.</p>
<p>So in order to only require a single pass through <strong>P</strong>, we should keep track of the current bounds for the range of matches (<strong>left, right</strong>), then we'll iterate through the characters (<strong>c</strong>) of <strong>S</strong>. At each iteration, we'll first want to move <strong>left</strong> forward and <strong>right</strong> back to narrow the range of matches based on the new value of <strong>c</strong>.</p>
<p>Then we can add the next three elements of <strong>P</strong> to our result array (<strong>res</strong>), as long as they fall inside the range <strong>[left, right]</strong>. Once that's done, we can add <strong>res</strong> to <strong>ans</strong> and move to the next iteration.</p>
<p>Once we've finished iterating through <strong>S</strong>, we can <strong>return ans</strong>.</p>
<ul>
<li><em><strong>Time Complexity: O(N * log(N))</strong> where <strong>N</strong> is the length of <strong>P</strong></em></li>
<li><em><strong>Space Complexity: O(1)</strong> excluding output space required for <strong>ans</strong></em></li>
</ul>
<h6># <strong><em>Javascript Code:</em></strong></h6>
<p>The best result for the code below is <strong>108ms / 49.5MB</strong> (beats 100% / 99%).</p>
<pre><code class="language-javascript">var suggestedProducts = function(P, S) {
    P.sort()
    let ans = [], left = 0, right = P.length - 1
    for (let i = 0; i &lt; S.length; i++) {
        let c = S.charAt(i), res = []
        while (P[left]?.charAt(i) &lt; c) left++
        while (P[right]?.charAt(i) &gt; c) right--
        for (let j = 0; j &lt; 3 &amp;&amp; left + j &lt;= right; j++)
            res.push(P[left+j])
        ans.push(res)
    }
    return ans
};
</code></pre>
<h6># <strong><em>Python Code:</em></strong></h6>
<p>The best result for the code below is <strong>60ms / 16.8MB</strong> (beats 99% / 99%).</p>
<pre><code class="language-python">class Solution:
    def suggestedProducts(self, P: List[str], S: str) -&gt; List[List[str]]:
        P.sort()
        ans, left, right = [], 0, len(P) - 1
        for i in range(len(S)):
            c, res = S[i], []
            while left &lt;= right and (len(P[left]) == i or P[left][i] &lt; c): left += 1
            while left &lt;= right and (len(P[right]) == i or P[right][i] &gt; c): right -= 1
            for j in range(3):
                if left + j &gt; right: break
                else: res.append(P[left+j])
            ans.append(res)
        return ans
</code></pre>
<h6># <strong><em>Java Code:</em></strong></h6>
<p>The best result for the code below is <strong>6ms / 44.5MB</strong> (beats 100% / 68%).</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] P, String S) {
        Arrays.sort(P);
        List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();
        int left = 0, right = P.length - 1;
        for (int i = 0; i &lt; S.length(); i++) {
            List&lt;String&gt; res = new ArrayList&lt;&gt;();
            char c = S.charAt(i);
            while (left &lt;= right &amp;&amp; (P[left].length() == i || P[left].charAt(i) &lt; c)) left++;
            while (left &lt;= right &amp;&amp; (P[right].length() == i || P[right].charAt(i) &gt; c)) right--;
            for (int j = 0; j &lt; 3 &amp;&amp; left + j &lt;= right; j++)
                res.add(P[left+j]);
            ans.add(res);
        }
        return ans;
    }
}
</code></pre>
<h6># <strong><em>cpp Code:</em></strong></h6>
<p>The best result for the code below is <strong>32ms / 26.2MB</strong> (beats 96% / 86%).</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; suggestedProducts(vector&lt;string&gt;&amp; P, string S) {
        sort(P.begin(), P.end());
        vector&lt;vector&lt;string&gt;&gt; ans;
        int left = 0, right = P.size() - 1;
        for (int i = 0; i &lt; S.length(); i++) {
            vector&lt;string&gt; res;
            char c = S[i];
            while (left &lt;= right &amp;&amp; (P[left].length() == i || P[left][i] &lt; c)) left++;
            while (left &lt;= right &amp;&amp; (P[right].length() == i || P[right][i] &gt; c)) right--;
            for (int j = 0; j &lt; 3 &amp;&amp; left + j &lt;= right; j++)
                res.push_back(P[left+j]);
            ans.push_back(res);
        }
        return ans;
    }
};
</code></pre></div>