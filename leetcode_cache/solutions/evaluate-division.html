<div class='cpp-solution'><h4>Image ExplanationüèÜ- [Easiest, Concise & Complete Intuition] - C++/Java/Python [Votes: 146]</h4><h4>Video Solution (<code>Aryan Mittal</code>) - Link in LeetCode Profile</h4>
<p><code>Evaluate Division</code> by <code>Aryan Mittal</code></p>
<h4>Approach &amp; Intution</h4>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:

    void dfs(string node, string&amp; dest, unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;&amp; gr, unordered_set&lt;string&gt;&amp; vis, double&amp; ans, double temp) {
        if(vis.find(node) != vis.end()) return;

        vis.insert(node);
        if(node == dest){
            ans = temp;
            return;
        }

        for(auto ne : gr[node]){
            dfs(ne.first, dest, gr, vis, ans, temp * ne.second);
        }
    }

    unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; buildGraph(const vector&lt;vector&lt;string&gt;&gt;&amp; equations, const vector&lt;double&gt;&amp; values) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; gr;

        for (int i = 0; i &lt; equations.size(); i++) {
            string dividend = equations[i][0];
            string divisor = equations[i][1];
            double value = values[i];

            gr[dividend][divisor] = value;
            gr[divisor][dividend] = 1.0 / value;
        }

        return gr;
    }

    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; gr = buildGraph(equations, values);
        vector&lt;double&gt; finalAns;

        for (auto query : queries) {
            string dividend = query[0];
            string divisor = query[1];

            if (gr.find(dividend) == gr.end() || gr.find(divisor) == gr.end()) {
                finalAns.push_back(-1.0);
            } else {
                unordered_set&lt;string&gt; vis;
                double ans = -1, temp=1.0;
                dfs(dividend, divisor, gr, vis, ans, temp);
                finalAns.push_back(ans);
            }
        }

        return finalAns;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public void dfs(String node, String dest, HashMap&lt;String, HashMap&lt;String, Double&gt;&gt; gr, HashSet&lt;String&gt; vis, double[] ans, double temp) {
        if (vis.contains(node))
            return;

        vis.add(node);
        if (node.equals(dest)) {
            ans[0] = temp;
            return;
        }

        for (Map.Entry&lt;String, Double&gt; entry : gr.get(node).entrySet()) {
            String ne = entry.getKey();
            double val = entry.getValue();
            dfs(ne, dest, gr, vis, ans, temp * val);
        }
    }

    public HashMap&lt;String, HashMap&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values) {
        HashMap&lt;String, HashMap&lt;String, Double&gt;&gt; gr = new HashMap&lt;&gt;();

        for (int i = 0; i &lt; equations.size(); i++) {
            String dividend = equations.get(i).get(0);
            String divisor = equations.get(i).get(1);
            double value = values[i];

            gr.putIfAbsent(dividend, new HashMap&lt;&gt;());
            gr.putIfAbsent(divisor, new HashMap&lt;&gt;());

            gr.get(dividend).put(divisor, value);
            gr.get(divisor).put(dividend, 1.0 / value);
        }

        return gr;
    }

    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) {
        HashMap&lt;String, HashMap&lt;String, Double&gt;&gt; gr = buildGraph(equations, values);
        double[] finalAns = new double[queries.size()];

        for (int i = 0; i &lt; queries.size(); i++) {
            String dividend = queries.get(i).get(0);
            String divisor = queries.get(i).get(1);

            if (!gr.containsKey(dividend) || !gr.containsKey(divisor)) {
                finalAns[i] = -1.0;
            } else {
                HashSet&lt;String&gt; vis = new HashSet&lt;&gt;();
                double[] ans = {-1.0};
                double temp = 1.0;
                dfs(dividend, divisor, gr, vis, ans, temp);
                finalAns[i] = ans[0];
            }
        }

        return finalAns;
    }
}
</code></pre>
<pre><code class="language-Python">from typing import List

class Solution:
    def dfs(self, node: str, dest: str, gr: dict, vis: set, ans: List[float], temp: float) -&gt; None:
        if node in vis:
            return

        vis.add(node)
        if node == dest:
            ans[0] = temp
            return

        for ne, val in gr[node].items():
            self.dfs(ne, dest, gr, vis, ans, temp * val)

    def buildGraph(self, equations: List[List[str]], values: List[float]) -&gt; dict:
        gr = {}

        for i in range(len(equations)):
            dividend, divisor = equations[i]
            value = values[i]

            if dividend not in gr:
                gr[dividend] = {}
            if divisor not in gr:
                gr[divisor] = {}

            gr[dividend][divisor] = value
            gr[divisor][dividend] = 1.0 / value

        return gr

    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:
        gr = self.buildGraph(equations, values)
        finalAns = []

        for query in queries:
            dividend, divisor = query

            if dividend not in gr or divisor not in gr:
                finalAns.append(-1.0)
            else:
                vis = set()
                ans = [-1.0]
                temp = 1.0
                self.dfs(dividend, divisor, gr, vis, ans, temp)
                finalAns.append(ans[0])

        return finalAns

</code></pre></div><div class='python-solution'><h4>Python BFS & UF(detailed explanation) [Votes: 151]</h4><p>We can treat each equation as an edge, variables as nodes and value as weight, and build a weighted graph. Then for each queries <code>(x, y)</code>, we try to find a path from <code>x</code> to <code>y</code>. The answer is the product of all edges' weights. If either <code>x</code> or <code>y</code> is not in graph or <code>x</code> and <code>y</code> are not connected in graph, the answer doesn't exist.
We can use a <code>defaultdict(dict) G</code> to build a weighted graph and <code>G[x][y]</code> will be the weight of edge <code>x-&gt;y</code> which is the value of <code>x / y</code></p>
<p>So one solution is BFS (or DFS) for each query.</p>
<pre><code>def calcEquation(equations, values, queries):
    G = collections.defaultdict(dict)
    for (x, y), v in zip(equations, values):
        G[x][y] = v
        G[y][x] = 1/v
    def bfs(src, dst):
        if not (src in G and dst in G): return -1.0
        q, seen = [(src, 1.0)], set()
        for x, v in q:
            if x == dst: 
                return v
            seen.add(x)
            for y in G[x]:
                if y not in seen: 
                    q.append((y, v*G[x][y]))
        return -1.0
    return [bfs(s, d) for s, d in queries]
</code></pre>
<p>Another solution is Union Find. </p>
<p>Our root map is <code>root</code> and each <code>root[x]</code> is in form of <code>(root(x), ratio)</code> where <code>ratio = x/root(x)</code>. If <code>x == root(x)</code>, then <code>ratio = 1.0</code>. So just consider root as a denominator here. Then, we process the equations. For each <code>x/y = v</code>, we union <code>x</code> to <code>y</code> or set <code>root(root(x)) = root(y)</code> as <code>y</code> is the denominator. After union all <code>x, y</code> in the equations, for each <code>a, b</code> in the queries, if <code>a</code> and <code>b</code> are not in the same union set, then <code>a</code> and <code>b</code> are not transmissable to each other so <code>a/b</code> should return <code>-1.0</code>.</p>
<p>Now that we have a <code>ratio</code> element in each <code>root[x]</code>, we need to update it in <code>find()</code> and <code>union()</code> as well.
In <code>find(x)</code>, we have <code>root[x] = (p, x/p)</code> where <code>p</code> is the parent node of x and not neccessarily the root node. But we will do path compression and recursively update all the parent nodes in the path to root. And <code>ratio</code> should be updated as well. Eventually <code>find(p)</code> returns updated <code>root[p] = (root(p), p/root(p))</code>. 
So <code>root[x]</code> should be updated to <code>(root(x), x/root(x)) = (root(p), x/p * p/root(p))) = (root[p][0], root[x][1] * root[p][1])</code></p>
<p>For <code>union(x, y)</code> in equations processing, we make <code>root(root(x)) = root(y)</code> as mentiond previously. And for <code>root[root(x)]</code>'s <code>ratio</code>, as <code>root(y)</code> is <code>root(x)</code>'s new root, we update it to <code>root(x)/root(y) = (x/y) * (y/root(y)) / (x/root(x)) = x/y * root[y][1] / root[x][1]</code>. <code>x/y</code> is the provided equation outcome value.</p>
<p>For <code>union(x, y)</code> in queries, we can just simply return <code>x/y = (x/root(x)) / (y/root(y)) = root[x][1]/root[y][1]</code>.</p>
<pre><code>def calcEquation(equations, values):
    root = {}

    #### xr = x/parent(x), pr = parent(x)/root(x), update xr to xr*pr = x/root(x)
    def find(x):
        p, xr = root.setdefault(x, (x, 1.0))
        if x != p:
            r, pr = find(p)
            root[x] = (r, xr*pr)
        return root[x]

    #### if root(x) = root(y), equations &quot;x / y&quot; doable as (x/root(x)) / (y/root(y)) = xr / yr
    def union(x, y, ratio):
        px, xr, py, yr = *find(x), *find(y)
        if not ratio:
            return xr / yr if px == py else -1.0
        if px != py:
            root[px] = (py, yr/xr*ratio)

    for (x, y), v in zip(equations, values):
        union(x, y, v)
    return [union(x, y, 0) if x in root and y in root else -1.0 for x, y in queries]
</code></pre></div>