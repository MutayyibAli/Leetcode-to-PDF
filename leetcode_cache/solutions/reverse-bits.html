<div class='cpp-solution'><h4>Beats 100% | Easy to Understand | âœ… [Votes: 66]</h4><h4>Intuition</h4>
<p>The task is like flipping the order of 0s and 1s in a binary number. To do this, we'll examine each bit (0 or 1) in the input number and construct the reversed number step by step.</p>
<h4>Approach</h4>
<p>We start with an answer variable set to 0. Write a for loop that will run 32 times (once for each bit). In the loop we will:
- Move the answer's bits to the left.
<code>ans &lt;&lt;= 1;</code>
- Check if the current bit is 1 and add it to the answer if it is.
<code>ans |= (n &amp; 1);</code>
- Move to the next bit in the given number.
<code>n &gt;&gt;= 1;</code></p>
<p>After this process, the answer will have the reversed bits.</p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity: $$O(1)$$</p>
</li>
<li>
<p>Space complexity: $$O(1)$$</p>
</li>
</ul>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans = 0;
        for (int i = 0; i &lt; 32; i++) {
            ans &lt;&lt;= 1;
            ans |= (n &amp; 1);
            n &gt;&gt;= 1;
        }
        return ans;
    }
};
</code></pre>
<pre><code class="language-java">public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ans = 0;
        for (int i = 0; i &lt; 32; i++) {
            ans &lt;&lt;= 1;
            ans |= (n &amp; 1);
            n &gt;&gt;= 1;
        }
        return ans;
    }
}
</code></pre></div><div class='python-solution'><h4>Python AC with 63ms, 3lines [Votes: 53]</h4><pre><code>class Solution:
    #### @param n, an integer
    #### @return an integer
    def reverseBits(self, n):
        oribin='{0:032b}'.format(n)
        reversebin=oribin[::-1]
        return int(reversebin,2)
</code></pre></div>