<div class='cpp-solution'><h4>C++ || BFS || Easiest Beginner Friendly Sol || O(n^2) time and O(n^2) space [Votes: 399]</h4><h4>Intuition of this Problem:</h4>
<p>Same type of bfs approach will work as shown in below picture.</p>
<!-- Describe your first thoughts on how to solve this problem. -->
<p><strong>NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.</strong></p>
<h4>Approach for this Problem:</h4>
<ol>
<li>Create a visited grid to store the state of the cell (fresh, rotten, or empty).</li>
<li>Initialize a queue to store the rotten oranges and count the number of fresh oranges.</li>
<li>Check if there are no fresh oranges, return 0, or if there are no rotten oranges, return -1.</li>
<li>Loop while the queue is not empty.<ul>
<li>a. Store the size of the queue.</li>
<li>b. Loop through the size of the queue.<ul>
<li>i. Get the front cell of the queue.</li>
<li>ii. Check all four directions of the cell to see if there are any fresh oranges.</li>
<li>iii. If there is a fresh orange, change its state to rotten and decrement the count of fresh oranges, and push the cell into the queue.</li>
</ul>
</li>
<li>c. Increment the minutes.</li>
</ul>
</li>
<li>If there are no fresh oranges, return the minutes.</li>
<li>If there are still fresh oranges, return -1.</li>
</ol>
<!-- Describe your approach to solving the problem. -->

<h4>Humble Request:</h4>
<ul>
<li>If my solution is helpful to you then please <strong>UPVOTE</strong> my solution, your <strong>UPVOTE</strong> motivates me to post such kind of solution.</li>
<li>Please let me know in comments if there is need to do any improvement in my approach, code....anything.</li>
<li><strong>Let's connect on</strong> https://www.linkedin.com/in/abhinash-singh-1b851b188</li>
</ul>
<h4>Code:</h4>
<pre><code class="language-cpp">class Solution {
public:
    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; visited = grid;
        //making queue in which we will fill rotten oranges
        queue&lt;pair&lt;int, int&gt;&gt; q;
        int countFreshOrange = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (visited[i][j] == 2) {
                    q.push({i, j});
                }
                if (visited[i][j] == 1) {
                    countFreshOrange++;
                }
            }
        }
        //q.empty() means there is no rotten orange in the grid and countFreshOrange = 0 means we will rotten the freshoranges in 0 mins
        if (countFreshOrange == 0)
            return 0;
        if (q.empty())
            return -1;

        int minutes = -1;
        // we will cover four directions i.e. up, down, left, right
        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [x, y] = q.front();
                q.pop();
                for (auto [dx, dy] : dirs) {
                    int i = x + dx;
                    int j = y + dy;
                    if (i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; visited[i][j] == 1) {
                        visited[i][j] = 2;
                        countFreshOrange--;
                        q.push({i, j});
                    }
                }
            }
            minutes++;
        }

        if (countFreshOrange == 0)
            return minutes;
        return -1;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public int orangesRotting(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] visited = grid;
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        int countFreshOrange = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (visited[i][j] == 2) {
                    q.offer(new int[] {i, j});
                }
                if (visited[i][j] == 1) {
                    countFreshOrange++;
                }
            }
        }
        if (countFreshOrange == 0)
            return 0;
        if (q.isEmpty())
            return -1;

        int minutes = -1;
        int[][] dirs = {{1, 0},{-1, 0},{0, -1},{0, 1}};
        while (!q.isEmpty()) {
            int size = q.size();
            while (size-- &gt; 0) {
                int[] cell = q.poll();
                int x = cell[0];
                int y = cell[1];
                for (int[] dir : dirs) {
                    int i = x + dir[0];
                    int j = y + dir[1];
                    if (i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; visited[i][j] == 1) {
                        visited[i][j] = 2;
                        countFreshOrange--;
                        q.offer(new int[] {i, j});
                    }
                }
            }
            minutes++;
        }

        if (countFreshOrange == 0)
            return minutes;
        return -1;
    }
}

</code></pre>
<pre><code class="language-Python">class Solution:
    def orangesRotting(self, grid: List[List[int]]) -&gt; int:
        m, n = len(grid), len(grid[0])
        visited = grid
        q = collections.deque()
        countFreshOrange = 0
        for i in range(m):
            for j in range(n):
                if visited[i][j] == 2:
                    q.append((i, j))
                if visited[i][j] == 1:
                    countFreshOrange += 1
        if countFreshOrange == 0:
            return 0
        if not q:
            return -1

        minutes = -1
        dirs = [(1, 0), (-1, 0), (0, -1), (0, 1)]
        while q:
            size = len(q)
            while size &gt; 0:
                x, y = q.popleft()
                size -= 1
                for dx, dy in dirs:
                    i, j = x + dx, y + dy
                    if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and visited[i][j] == 1:
                        visited[i][j] = 2
                        countFreshOrange -= 1
                        q.append((i, j))
            minutes += 1

        if countFreshOrange == 0:
            return minutes
        return -1

</code></pre>
<h4>Time Complexity and Space Complexity:</h4>
<ul>
<li>Time complexity: <strong>O(m*n)</strong></li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity: <strong>O(m*n)</strong></li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Similar Pattern Problems:</h4>
<ol>
<li>As Far from Land as Possible - https://leetcode.com/problems/as-far-from-land-as-possible/description/</li>
<li>Shortest Distance from All Buildings - https://leetcode.com/problems/shortest-distance-from-all-buildings/description/</li>
</ol></div><div class='python-solution'><h4>Python Clean & Well Explained (faster than > 90%) [Votes: 907]</h4><pre><code>from collections import deque

#### Time complexity: O(rows * cols) -&gt; each cell is visited at least once
#### Space complexity: O(rows * cols) -&gt; in the worst case if all the oranges are rotten they will be added to the queue

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -&gt; int:

        #### number of rows
        rows = len(grid)
        if rows == 0:  #### check if grid is empty
            return -1

        #### number of columns
        cols = len(grid[0])

        #### keep track of fresh oranges
        fresh_cnt = 0

        #### queue with rotten oranges (for BFS)
        rotten = deque()

        #### visit each cell in the grid
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 2:
                    #### add the rotten orange coordinates to the queue
                    rotten.append((r, c))
                elif grid[r][c] == 1:
                    #### update fresh oranges count
                    fresh_cnt += 1

        #### keep track of minutes passed.
        minutes_passed = 0

        #### If there are rotten oranges in the queue and there are still fresh oranges in the grid keep looping
        while rotten and fresh_cnt &gt; 0:

            #### update the number of minutes passed
            #### it is safe to update the minutes by 1, since we visit oranges level by level in BFS traversal.
            minutes_passed += 1

            #### process rotten oranges on the current level
            for _ in range(len(rotten)):
                x, y = rotten.popleft()

                #### visit all the adjacent cells
                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                    #### calculate the coordinates of the adjacent cell
                    xx, yy = x + dx, y + dy
                    #### ignore the cell if it is out of the grid boundary
                    if xx &lt; 0 or xx == rows or yy &lt; 0 or yy == cols:
                        continue
                    #### ignore the cell if it is empty '0' or visited before '2'
                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:
                        continue

                    #### update the fresh oranges count
                    fresh_cnt -= 1

                    #### mark the current fresh orange as rotten
                    grid[xx][yy] = 2

                    #### add the current rotten to the queue
                    rotten.append((xx, yy))


        #### return the number of minutes taken to make all the fresh oranges to be rotten
        #### return -1 if there are fresh oranges left in the grid (there were no adjacent rotten oranges to make them rotten)
        return minutes_passed if fresh_cnt == 0 else -1
</code></pre></div>