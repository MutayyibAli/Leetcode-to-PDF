<div class='cpp-solution'><h4>Simple Diagram Explanation [Votes: 909]</h4><h4>Idea</h4>
<ul>
<li><strong>We will use a two queue approach.</strong></li>
<li>Recall, each senator has a position to exercise their right. </li>
<li>The ones to the left have an earlier turn than the ones to the right. </li>
<li><code>rad</code> is queue that holds all positions of <strong>active</strong> senators in "Radiant"</li>
<li><code>dir</code> is queue that holds all positions of <strong>active</strong> senators in "Dire".</li>
<li><strong>Active</strong> being that they still have the right to vote. </li>
<li>Our queue will be ordered so that the senators with earlier voting power come first (to the left of the queue). </li>
<li>To goal is to have the earliest senator of each queue <em>fight</em> each other to see who gets to eliminate the other depending on their position. </li>
<li>Obviously, the one with the earlier position will win. </li>
<li>The loser is removed from the queue since they are no longer <strong>active.</strong></li>
<li>The winner will go to the end of the queue for the next round. </li>
<li>We keep doing this until one queue is empty which means there are no more senators on the team. </li>
</ul>
<h4>Everything is easier with an example:</h4>
<ul>
<li><code>senate = "RDDDRDRRDR"</code></li>
</ul>
<h4>Code</h4>
<pre><code>class Solution {
public:
    string predictPartyVictory(string senate) {
        queue&lt;int&gt; rad, dir;
        int n = senate.length();
        // Add all senators to respect queue with index
        for (int i = 0; i &lt; n; i++){
            if (senate[i] == 'R'){
                rad.push(i);
            }
            else {
                dir.push(i);
            }
        }
        // Use increasing n to keep track of position
        while (!rad.empty() &amp;&amp; !dir.empty()){
            // Only &quot;winner&quot; stays in their queue
            if (rad.front() &lt; dir.front()){
                rad.push(n++);
            }
            else {
                dir.push(n++);
            }
            rad.pop(), dir.pop();
        }
        return (rad.empty()) ? (&quot;Dire&quot;) : (&quot;Radiant&quot;);
    }
};
</code></pre>
<h6>Why does the winner go to the end of the queue?</h6>
<ul>
<li>Since the voting is done such that both sides perform the most optimal strategy, the senators who have already voted will not be a problem to the other team for that round. </li>
<li>So, instead of eliminating a senator who has already moved, the best move for each team is to eliminate the next senator who has the power to vote. </li>
<li>This works perfectly with the queue approach since we can just place the senators who have voted at the end. </li>
</ul>
<h5>If this helped, please leave an upvote! Much appreciated!</h5>
<h6>## edit: Thanks all for the kind comments; it definitely motivates me to make more of these diagram solutions!</h6></div>