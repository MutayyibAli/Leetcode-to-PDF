<div class='cpp-solution'><h4>My simple C++ solution [Votes: 672]</h4><pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int j = 0;
        // move all the nonzero elements advance
        for (int i = 0; i &lt; nums.size(); i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        for (;j &lt; nums.size(); j++) {
            nums[j] = 0;
        }
    }
};
</code></pre></div><div class='python-solution'><h4>Two pointers technique (Python, O(n) time / O(1) space) [Votes: 875]</h4><p>Hi there! Here is my solution to this problem that uses two pointers technique.</p>
<p><strong>Code:</strong></p>
<pre><code>class Solution:
    def moveZeroes(self, nums: list) -&gt; None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0 and nums[slow] == 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]

            #### wait while we find a non-zero element to
            #### swap with you
            if nums[slow] != 0:
                slow += 1
</code></pre>
<p><strong>Algorithm complexity:</strong>
<em>Time complexity: O(n)</em>. Our fast pointer does not visit the same spot twice.
<em>Space complexity: O(1)</em>. All operations are made in-place</p>
<p>If you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.</p>
<p><strong>Special thanks for the next comments:</strong>
<a href="https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985"><strong>stanley98745</strong></a></p></div>