<div class='cpp-solution'><h4>C++ BFS and DFS [Votes: 151]</h4><p>Similar to <a href="https://leetcode.com/problems/course-schedule/">Course Schedule</a>, during the process of visiting the nodes, store them in order to a <code>vector</code>. In DFS, you may need an additional <code>reverse</code>.</p>
<p><strong>BFS</strong></p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector&lt;int&gt; degrees = computeIndegrees(g);
        vector&lt;int&gt; order;
        for (int i = 0; i &lt; numCourses; i++) {
            int j = 0;
            for (; j &lt; numCourses; j++) {
                if (!degrees[j]) {
                    order.push_back(j);
                    break;
                }
            }
            if (j == numCourses) {
                return {};
            }
            degrees[j]--;
            for (int v : g[j]) {
                degrees[v]--;
            }
        }        
        return order;
    }
private:
    typedef vector&lt;vector&lt;int&gt;&gt; graph;

    graph buildGraph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }

    vector&lt;int&gt; computeIndegrees(graph&amp; g) {
        vector&lt;int&gt; degrees(g.size(), 0);
        for (auto adj : g) {
            for (int v : adj) {
                degrees[v]++;
            }
        }
        return degrees;
    }
};
</code></pre>
<p><strong>DFS</strong></p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector&lt;int&gt; order;
        vector&lt;bool&gt; todo(numCourses, false), done(numCourses, false);
        for (int i = 0; i &lt; numCourses; i++) {
            if (!done[i] &amp;&amp; !acyclic(g, todo, done, i, order)) {
                return {};
            }
        }
        reverse(order.begin(), order.end());
        return order;
    }
private:
    typedef vector&lt;vector&lt;int&gt;&gt; graph;

    graph buildGraph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }

    bool acyclic(graph&amp; g, vector&lt;bool&gt;&amp; todo, vector&lt;bool&gt;&amp; done, int node, vector&lt;int&gt;&amp; order) {
        if (todo[node]) {
            return false;
        }
        if (done[node]) {
            return true;
        }
        todo[node] = done[node] = true;
        for (int neigh : g[node]) {
            if (!acyclic(g, todo, done, neigh, order)) {
                return false;
            }
        }
        order.push_back(node);
        todo[node] = false;
        return true;
    }
};
</code></pre></div><div class='python-solution'><h4>Fast python DFS solution with inline explanation [Votes: 144]</h4><p>Runs takes 80ms</p>
<pre><code>class Solution:
    #### @param {integer} numCourses
    #### @param {integer[][]} prerequisites
    #### @return {integer[]}
    def findOrder(self, numCourses, prerequisites):
        #### use DFS to parse the course structure
        self.graph = collections.defaultdict(list) #### a graph for all courses
        self.res = [] #### start from empty
        for pair in prerequisites:
            self.graph[pair[0]].append(pair[1]) 
        self.visited = [0 for x in xrange(numCourses)] #### DAG detection 
        for x in xrange(numCourses):
            if not self.DFS(x):
                return []
             #### continue to search the whole graph
        return self.res

    def DFS(self, node):
        if self.visited[node] == -1: #### cycle detected
            return False
        if self.visited[node] == 1:
            return True #### has been finished, and been added to self.res
        self.visited[node] = -1 #### mark as visited
        for x in self.graph[node]:
            if not self.DFS(x):
                return False
        self.visited[node] = 1 #### mark as finished
        self.res.append(node) #### add to solution as the course depenedent on previous ones
        return True
</code></pre></div>