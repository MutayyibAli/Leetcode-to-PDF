<div class='cpp-solution'><h4>16 ms C++ solution [Votes: 111]</h4><pre><code>class Solution {
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums, int start, int end){
        if(end&lt;=start) return NULL; 
        int midIdx=(end+start)/2;
        TreeNode* root=new TreeNode(nums[midIdx]);
        root-&gt;left=sortedArrayToBST(nums, start, midIdx);
        root-&gt;right=sortedArrayToBST(nums, midIdx+1,end);
        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        return sortedArrayToBST(nums, 0,nums.size());
    }
};
</code></pre></div><div class='python-solution'><h4>An easy Python solution [Votes: 298]</h4><p>The idea is to find the root first, then recursively build each left and right subtree</p>
<pre><code>#### Definition for a  binary tree node
#### class TreeNode:
####     def __init__(self, x):
####         self.val = x
####         self.left = None
####         self.right = None

class Solution:
    #### @param num, a list of integers
    #### @return a tree node
    #### 12:37
    def sortedArrayToBST(self, num):
        if not num:
            return None

        mid = len(num) // 2

        root = TreeNode(num[mid])
        root.left = self.sortedArrayToBST(num[:mid])
        root.right = self.sortedArrayToBST(num[mid+1:])

        return root
</code></pre></div>