<div class='cpp-solution'><h4>C++ Trie [Votes: 259]</h4><p>This is a vanilla application of Trie. The main difficulty lies in how to deal with the <code>.</code> character. I use a naive solution in this place: each time when I reach a <code>.</code>, I simply traverse all the children of the current node and recursively search the remaining substring starting from each of those children.</p>
<p>```cpp
class TrieNode {
public:
    bool word;
    TrieNode* children[26];
    TrieNode() {
        word = false;
        memset(children, NULL, sizeof(children));
    }
};</p>
<p>class WordDictionary {
public:
    /*<em> Initialize your data structure here. </em>/
    WordDictionary() {</p>
<pre><code>}

/** Adds a word into the data structure. */
void addWord(string word) {
    TrieNode* node = root;
    for (char c : word) {
        if (!node -&gt; children[c - 'a']) {
            node -&gt; children[c - 'a'] = new TrieNode();
        }
        node = node -&gt; children[c - 'a'];
    }
    node -&gt; word = true;
}

/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
bool search(string word) {
    return search(word.c_str(), root);
}
</code></pre>
<p>private:
    TrieNode* root = new TrieNode();</p>
<pre><code>bool search(const char* word, TrieNode* node) {
    for (int i = 0; word[i] &amp;&amp; node; i++) {
        if (word[i] != '.') {
            node = node -&gt; children[word[i] - 'a'];
        } else {
            TrieNode* tmp = node;
            for (int j = 0; j &lt; 26; j++) {
                node = tmp -&gt; children[j];
                if (search(word + i + 1, node)) {
                    return true;
                }
            }
        }
    }
    return node &amp;&amp; node -&gt; word;
}
</code></pre>
<p>};
 ```</p></div><div class='python-solution'><h4>[Java/C++/Python] A very well detailed EXPLANATION! [Votes: 437]</h4><pre><code>What the question is saying, 
We have to design a data structure that supports adding new words and finding if a string matches any previously added string.
</code></pre>
<p><strong>So, to design a DS we only need to support 3 function's for this data structure.</strong></p>
<ul>
<li>One is the <strong>constructor</strong> that's gonna intialize the object.</li>
<li>One is <strong>Adding</strong> the <strong>word's</strong>, but all of them are lower case from <strong>a to z</strong></li>
<li>One is <strong>Searching</strong> a <strong>word</strong>, and the word can contains any character from <strong>a - z</strong>. But there is <strong>1 additional character</strong> it contains, <strong>"."</strong> character <code>[And what they told "." character is a wild card, can match any character easily in the string]</code></li>
</ul>
<p><strong>The brute force way to solve this problem</strong> is pretty simple, "<em>having a list of words &amp; then just for every search we would just see, if this search match any of the word in input list</em>." <strong>[But it's not an efficient way]</strong></p>
<p>Let's talk about, <strong>efficient way to solve this problem</strong>. And for that we require <strong>Trie data structure</strong> a.k.a <strong>Prefix tree</strong></p>
<p>Let's understand <strong>Trie first</strong>,
<strong>Trie</strong> is basically a <strong>tree</strong> that has some kind of <strong>root node</strong> &amp; each node can have up to <strong>26 children in this problem</strong>. Because we have <strong>lower case character from a to z</strong>. So, basically each <strong>node represent's a single character</strong>. And each node could have up to 26 additional children:</p>
<p>And basically word in this example means, let's take <strong>"a"</strong> having child <strong>"b" -&gt; with "c"</strong>, so that's will be a <strong>single word</strong>. And if we insert the word <strong>"abc"</strong> in our <strong>trie</strong>, so basically how's it looks like:</p>
<p>One additional thing we have to say is, for a particular node such as <strong>"c"</strong> this is the <strong>end of the word</strong>. Because if we <strong>added another word</strong> example:- <strong>"ab"</strong>. So, we don't add them back again as if you notice they are already available to us, we just <strong>gonna re-use</strong> these characters. So, we have 2 word's along this <strong>path "abc" &amp; "ab"</strong>
Basically, all words start with <strong>"a"</strong> are gonna be here, that's what it make it <strong>efficient</strong>. That's why it's called <strong>prefix tree</strong>.</p>
<p><code>Now, you have understood how Trie aka Prefix Tree work.</code></p>
<p>Now let's take an example &amp; build our tree,
<strong>Input</strong></p>
<pre><code>[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]
[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[null,null,null,null,false,true,true,true]
</code></pre>
<ul>
<li>
<p>The first word we add is <strong>"bad". "b" -&gt; "a" -&gt; "d"</strong></p>
</li>
<li>
<p>Next we adding another word <strong>"dad"</strong>. So, we have to start with <strong>different path</strong>. As, these two word's have a <strong>different prefix</strong>. One start with <strong>"b"</strong> and one start with <strong>"d"</strong>. So, let's add it: <strong>"d" -&gt; "a" -&gt; "d"</strong></p>
</li>
<li>
<p>We have one last word before we start searching, this one gonna be <strong>"mad"</strong>. So, we don't have <strong>"m"</strong>, then let's add it: <strong>"m" -&gt; "a" -&gt; "d"</strong></p>
</li>
</ul>
<p>So far we have <strong>3 word's</strong> and all of them end with different <strong>"d"</strong>. But they all <strong>3 of them have different prefix</strong> that's why they are along different path's.</p>
<p><code>Now let's go for searching path:-</code></p>
<ul>
<li>
<p>So, first word we gonna search for <strong>"pad"</strong>. We gonna <strong>start</strong> at <strong>beginning</strong>. First we gonna try are there any <strong>"p"</strong> in this. That means immediately we <strong>return false</strong> as <strong>"pad"</strong> doesn't exist in our input.</p>
</li>
<li>
<p>Now, we search another word <strong>"bad"</strong>. So, we <strong>start at the root</strong> and see there are any <strong>"b"</strong>. Yes, we have <strong>"b"</strong>. now we check does this <strong>"b"</strong> have a child <strong>"a"</strong>, yes it does. Now last character <strong>"d"</strong> does <strong>"a"</strong> has a child <strong>"d"</strong>, yes it does have. Lastly we have to say the last character <strong>"d"</strong> is in our <strong>trie</strong>, which designated as the end of the word. Sice it's <strong>marked red</strong>. Therefore, we <strong>return true</strong> for this input <strong>"bad"</strong></p>
</li>
<li>
<p>Now, in this search we have <strong>".ad"</strong>, the dot <strong>"."</strong> character matches any character. So, we start at the root and go to any of the path and to do that we have to use <strong>DFS or backtracking approach</strong>. So, let's say first path we decided <strong>"b"</strong>. now we check does this <strong>"b"</strong> have a child <strong>"a"</strong>, yes it does. Now last character <strong>"d"</strong> does <strong>"a"</strong> has a child <strong>"d"</strong>, yes it does have. Lastly we have to say the last character <strong>"d"</strong> in our trie, is designated as the end of the word. Therefore, we <strong>return true</strong> for this input <strong>".ad"</strong></p>
</li>
<li>
<p>One last search, In this we have <strong>"b.."</strong>. So, we start at the root and see there are any <strong>"b"</strong>. Yes, we have <strong>"b"</strong>. Now we check do we have any character to go below for our current dot <strong>"."</strong>, yes we have <strong>"a"</strong>. Now we are looking for any character for our last <strong>dot "."</strong> Yes we have <strong>"d"</strong> &amp; it is end of the word. Therefore, we <strong>return true</strong> for this input <strong>"b.."</strong></p>
</li>
</ul>
<p>Now understand this <strong><em>VISUALLY, it's not super hard.</em></strong></p>
<p><strong>Now, let's code it up:</strong></p>
<p><strong>Java</strong></p>
<pre><code>class WordDictionary {
    private WordDictionary[] children;
    boolean isEndOfWord;
    // Initialize your data structure here. 
    public WordDictionary() {
        children = new WordDictionary[26];
        isEndOfWord = false;
    }

    // Adds a word into the data structure. 
    public void addWord(String word) {
        WordDictionary curr = this;
        for(char c: word.toCharArray()){
            if(curr.children[c - 'a'] == null)
                curr.children[c - 'a'] = new WordDictionary();
            curr = curr.children[c - 'a'];
        }
        curr.isEndOfWord = true;
    }

    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
    public boolean search(String word) {
        WordDictionary curr = this;
        for(int i = 0; i &lt; word.length(); ++i){
            char c = word.charAt(i);
            if(c == '.'){
                for(WordDictionary ch: curr.children)
                    if(ch != null &amp;&amp; ch.search(word.substring(i+1))) return true;
                return false;
            }
            if(curr.children[c - 'a'] == null) return false;
            curr = curr.children[c - 'a'];
        }
        return curr != null &amp;&amp; curr.isEndOfWord;
    }
}
</code></pre>
<p><strong>cpp</strong></p>
<pre><code>class WordDictionary {
    vector&lt;WordDictionary*&gt; children;
    bool isEndOfWord;
public:
    // Initialize your data structure here. 
    WordDictionary(): isEndOfWord(false){
        children = vector&lt;WordDictionary*&gt;(26, nullptr);
    }

    // Adds a word into the data structure. 
    void addWord(string word) {
        WordDictionary *curr = this;
        for(char c: word){
            if(curr-&gt;children[c - 'a'] == nullptr)
                curr-&gt;children[c - 'a'] = new WordDictionary();
            curr = curr-&gt;children[c - 'a'];
        }
        curr-&gt;isEndOfWord = true;
    }

    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
    bool search(string word) {
        WordDictionary *curr = this;
        for(int i = 0; i &lt; word.length(); ++i){
            char c = word[i];
            if(c == '.'){
                for(auto ch: curr-&gt;children)
                    if(ch &amp;&amp; ch-&gt;search(word.substr(i+1))) return true;
                return false;
            }
            if(curr-&gt;children[c - 'a'] == nullptr) return false;
            curr = curr-&gt;children[c - 'a'];
        }
        return curr &amp;&amp; curr-&gt;isEndOfWord;
    }
};
</code></pre>
<p><strong>Python</strong></p>
<pre><code>class WordDictionary:

    def __init__(self):

        #### Initialize your data structure here.
        self.children = [None]*26
        self.isEndOfWord = False


    def addWord(self, word: str) -&gt; None:

        #### Adds a word into the data structure.
        curr = self
        for c in word:
            if curr.children[ord(c) - ord('a')] == None:
                curr.children[ord(c) - ord('a')] = WordDictionary()
            curr = curr.children[ord(c) - ord('a')]

        curr.isEndOfWord = True;


    def search(self, word: str) -&gt; bool:

        #### Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        curr = self
        for i in range(len(word)):
            c = word[i]
            if c == '.':
                for ch in curr.children:
                    if ch != None and ch.search(word[i+1:]): return True
                return False

            if curr.children[ord(c) - ord('a')] == None: return False
            curr = curr.children[ord(c) - ord('a')]

        return curr != None and curr.isEndOfWord
</code></pre>
<p>ANALYSIS :-
* <strong>Time Complexity :-</strong> BigO(M) for well defined words, But in worse case BigO(M.26^N)</p>
<ul>
<li><strong>Space Complexity :-</strong> BigO(1) for well defined words, But for worst case BigO(M)</li>
</ul></div>