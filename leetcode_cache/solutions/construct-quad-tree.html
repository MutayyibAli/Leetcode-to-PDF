<div class='cpp-solution'><h4>Clean CodesðŸ”¥ðŸ”¥|| Full Explanationâœ…|| Helper Methodâœ…|| C++|| Java|| Python3 [Votes: 109]</h4><h4>Intuition :</h4>
<ul>
<li>Here we have to construct a Quadtree from a 2D binary grid, where each node of the Quadtree represents a square of the grid. </li>
</ul>
<h4>What is Quad Tree ?</h4>
<ul>
<li>A Quadtree is represented by a tree of Node objects, where each Node has four children (topLeft, topRight, bottomLeft, and bottomRight) that represent the four quadrants of its square.</li>
<li>A Quadtree is a way of dividing the picture into smaller and smaller sections, with each node in the tree representing a section of the picture. The tree is built recursively, which means it keeps calling itself until it reaches the smallest possible section.</li>
</ul>
<!-- Describe your first thoughts on how to solve this problem. -->

<h4>Detail Explanation to Approach :</h4>
<p><strong>Class Solution :</strong>
- Here we have to create a tree-like structure called a Quadtree from a picture that is made up of only black and white squares. </p>
<pre><code>class Solution {
  public Node construct(int[][] grid) {
    return helper(grid, 0, 0, grid.length);
  }

</code></pre>
<ul>
<li>This is the class definition for the solution, which contains one public method called construct. </li>
<li>This method takes a 2D integer array called grid as input, and it returns a Node object that represents the root of the Quadtree for that grid. </li>
<li>The helper method (defined later) is used to construct the Quadtree recursively, starting from the entire grid.</li>
</ul>
<p><strong>Helper Function :</strong>
- See , first start with the entire picture and check if all the squares in that section are the same color. 
- If they are, create a single node in the Quadtree to represent that section of the picture. 
- If they aren't, split that section into four smaller squares and repeats the process for each one. 
- Keep doing this until you reach a point where all the squares in a section are the same color, and create a node to represent that section.</p>
<pre><code>  private Node helper(int[][] grid, int i, int j, int w) {
    if (allSame(grid, i, j, w))
      return new Node(grid[i][j] == 1 ? true : false, true);

    Node node = new Node(true, false);
    node.topLeft = helper(grid, i, j, w / 2);
    node.topRight = helper(grid, i, j + w / 2, w / 2);
    node.bottomLeft = helper(grid, i + w / 2, j, w / 2);
    node.bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);
    return node;
  }

</code></pre>
<ul>
<li>
<p>This is the helper method, which is a private recursive function used to construct the Quadtree. It takes four parameters:</p>
</li>
<li>
<p>grid: the 2D integer array representing the current sub-grid.</p>
</li>
<li>i: the row index of the top-left corner of the current sub-grid.</li>
<li>j: the column index of the top-left corner of the current sub-grid.</li>
<li>w: the width of the current sub-grid.</li>
</ul>
<p><strong>allSame Method :</strong>
- The <code>allSame</code> method is a way of checking if all the squares in a section of the picture are the same color. 
- It checks each square in the section and compares it to the top-left square to see if they are the same color. 
- If any square is a different color, it returns false, which means that the section is not all the same color. 
- If it gets to the end of the loop and all squares are the same color, it returns true, which means that the section is all the same color.</p>
<pre><code>  private boolean allSame(int[][] grid, int i, int j, int w) {
    for (int x = i; x &lt; i + w; ++x)
      for (int y = j; y &lt; j + w; ++y)
        if (grid[x][y] != grid[i][j])
          return false;
    return true;
  }

</code></pre>
<ul>
<li>
<p>This is the allSame helper method, which checks if all the squares in a given sub-grid are the same color. It takes four parameters:</p>
</li>
<li>
<p>grid: the 2D integer array representing the full grid.</p>
</li>
<li>i: the row index of the top-left corner of the sub-grid.</li>
<li>j: the column index of the top-left corner of the sub-grid.</li>
<li>w: the width of the sub-grid.</li>
</ul>
<!-- Describe your approach to solving the problem. -->

<h4>Complexity</h4>
<ul>
<li>Time complexity : O(n^2 * log n)</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->

<ul>
<li>Space complexity : O(n^2)</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->

<h4>Please Upvote</h4>
<pre><code>Thanks for visiting my solution.
</code></pre>
<p><em>Let's Code it Up .
There may be minor syntax difference in cpp and Python</em></p>
<h4>Codes [cpp |Java |Python3] :</h4>
<pre><code class="language-cpp">class Solution {
 public:
  Node* construct(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    return helper(grid, 0, 0, grid.size());
  }

 private:
  Node* helper(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int w) {
    if (allSame(grid, i, j, w))
      return new Node(grid[i][j], true);

    Node* node = new Node(true, false);
    node-&gt;topLeft = helper(grid, i, j, w / 2);
    node-&gt;topRight = helper(grid, i, j + w / 2, w / 2);
    node-&gt;bottomLeft = helper(grid, i + w / 2, j, w / 2);
    node-&gt;bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);
    return node;
  }

  bool allSame(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int w) {
    return all_of(begin(grid) + i, begin(grid) + i + w,
                  [&amp;](const vector&lt;int&gt;&amp; row) {
      return all_of(begin(row) + j, begin(row) + j + w,
                    [&amp;](int num) { return num == grid[i][j]; });
    });
  }
};
</code></pre>
<pre><code class="language-Java">class Solution {
  public Node construct(int[][] grid) {
    return helper(grid, 0, 0, grid.length);
  }

  private Node helper(int[][] grid, int i, int j, int w) {
    if (allSame(grid, i, j, w))
      return new Node(grid[i][j] == 1 ? true : false, true);

    Node node = new Node(true, false);
    node.topLeft = helper(grid, i, j, w / 2);
    node.topRight = helper(grid, i, j + w / 2, w / 2);
    node.bottomLeft = helper(grid, i + w / 2, j, w / 2);
    node.bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);
    return node;
  }

  private boolean allSame(int[][] grid, int i, int j, int w) {
    for (int x = i; x &lt; i + w; ++x)
      for (int y = j; y &lt; j + w; ++y)
        if (grid[x][y] != grid[i][j])
          return false;
    return true;
  }
}
</code></pre>
<pre><code class="language-Python">class Node:
    def __init__(self, val, isLeaf, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight

class Solution:
    def construct(self, grid: List[List[int]]) -&gt; Node:
        return self.helper(grid, 0, 0, len(grid))

    def helper(self, grid, i, j, w):
        if self.allSame(grid, i, j, w):
            return Node(grid[i][j] == 1, True)

        node = Node(True, False)
        node.topLeft = self.helper(grid, i, j, w // 2)
        node.topRight = self.helper(grid, i, j + w // 2, w // 2)
        node.bottomLeft = self.helper(grid, i + w // 2, j, w // 2)
        node.bottomRight = self.helper(grid, i + w // 2, j + w // 2, w // 2)
        return node

    def allSame(self, grid, i, j, w):
        for x in range(i, i + w):
            for y in range(j, j + w):
                if grid[x][y] != grid[i][j]:
                    return False
        return True
</code></pre>
<h4>Please Upvote</h4></div>