<div class='cpp-solution'><h4>【Video】Keep number we found and find duplicate [Votes: 306]</h4><h4>Intuition</h4>
<p>Keep number we found and find duplicate.</p>
<h4>Solution Video</h4>
<p>https://youtu.be/RdakO1_niYE</p>
<h6>⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️</h6>
<p><strong>■ Subscribe URL</strong>
http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<p>Subscribers: 5,510</p>
<h4>Approach</h4>
<p>We can't have duplicate numbers at each row, column and box(3 * 3), so it's good idea to have data of each row, column and box whether we check current number is duplicate.</p>
<p>For example,</p>
<pre><code>rows[0] - 5,7,8,9
    [1] - 1,2
    [2] - 4,8
    .
    .
    .

cols[0] - 1,2
    [1] - 3,4
    .
    .
    .
</code></pre>
<p>That means</p>
<pre><code>- We have `5,7,8,9` at row `0`.
- We have `1`,`2` at row `1`.
- We have `4`,`8` at row `2`.
- We have `1`,`2` at column `0`.
- We have `3`,`4` at column `1`. 
</code></pre>
<p>Let's say we have row 0 like this.</p>
<pre><code>      0 1 2 3 4 5 6 7 8 (column number)
row0: 5,6,8,9,x,x,x,x,9
row1: x,x,x,x,x,x,x,x,x,
</code></pre>
<p>At board[0][0], we have <code>5</code>
At board[0][1], we have <code>6</code>
At board[0][2], we have <code>8</code>
At board[0][3], we have <code>9</code></p>
<p>Now we have</p>
<pre><code>rows[0] - 5,7,8,9
</code></pre>
<p>Look at the <code>board[0][8]</code>. We have <code>9</code> at row <code>0</code>. That <code>9</code> is duplicate because we already have <code>9</code> at row <code>0</code>, so we should return <code>False</code>.</p>
<p>We apply the same idea to column direction and box. But let me explain box position.</p>
<p>We should have the same data for box whether we check current number is duplicate or not. But problem is size of one box is <code>3 * 3</code>, so we can't keep data like rows and columns. We are not allowed to have the same number in box which is size of <code>3 * 3</code>.</p>
<p>How do you deal with the problem?</p>
<p>My strategy is to use tuple as a key. For example, left top box should be from index <code>0</code> to index <code>2</code> of rows and columns.</p>
<p>We know that size of one box is <code>3 * 3</code>, so if we divide index number by <code>3</code>, we can point to the target box.</p>
<p>For example, if we are now at board[2][1] and find <code>7</code>, box should be</p>
<pre><code>2 // 3 = 0
1 // 3 = 0
</code></pre>
<p>so, the target box should be</p>
<pre><code>boxes[(0, 0)] - 7
</code></pre>
<p>if we are now at board[8][6] and find <code>5</code>,</p>
<pre><code>8 // 3 = 2
6 // 3 = 2
</code></pre>
<p>so, the target box should be</p>
<pre><code>boxes[(2, 2)] - 5
</code></pre>
<p>We have nine 3 * 3 boxes.</p>
<pre><code>     012  345  678 → column number
012 (0,0)(0,1)(0,2)
345 (1,0)(1,1)(1,2)
678 (2,0)(2,1)(2,2)
↓
row number

each box is 3 * 3
We are not allowed to have duplicate number in each box.
</code></pre>
<p>Easy!
Let's see real algorithm!</p>
<p>https://youtu.be/bU_dXCOWHls
<code>code</code></p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity: $$O(81)$$ → $$O(1)$$
$$rows(9) * columns(9) = 81$$</p>
</li>
<li>
<p>Space complexity: $$O(243)$$ → $$O(1)$$
$$rows(81) + columns(81) + boxes(81) = 243$$</p>
</li>
</ul>
<pre><code class="language-python">class Solution:
    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
        rows = defaultdict(set)
        cols = defaultdict(set)
        boxes = defaultdict(set)

        for r in range(9):
            for c in range(9):
                if board[r][c] == &quot;.&quot;:
                    continue

                if board[r][c] in rows[r] or board[r][c] in cols[c] or board[r][c] in boxes[(r // 3, c // 3)]:
                    return False

                rows[r].add(board[r][c])
                cols[c].add(board[r][c])
                boxes[(r // 3, c // 3)].add(board[r][c])

        return True
</code></pre>
<pre><code class="language-javascript">var isValidSudoku = function(board) {
    let rows = Array.from({ length: 9 }, () =&gt; new Set());
    let cols = Array.from({ length: 9 }, () =&gt; new Set());
    let boxes = Array.from({ length: 9 }, () =&gt; new Set());

    for (let r = 0; r &lt; 9; r++) {
        for (let c = 0; c &lt; 9; c++) {
            if (board[r][c] === '.') {
                continue;
            }

            let value = board[r][c];
            let boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3);

            if (rows[r].has(value) || cols[c].has(value) || boxes[boxIndex].has(value)) {
                return false;
            }

            rows[r].add(value);
            cols[c].add(value);
            boxes[boxIndex].add(value);
        }
    }

    return true;    
};
</code></pre>
<pre><code class="language-java">class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashSet&lt;Character&gt;[] rows = new HashSet[9];
        HashSet&lt;Character&gt;[] cols = new HashSet[9];
        HashSet&lt;Character&gt;[] boxes = new HashSet[9];

        for (int i = 0; i &lt; 9; i++) {
            rows[i] = new HashSet&lt;&gt;();
            cols[i] = new HashSet&lt;&gt;();
            boxes[i] = new HashSet&lt;&gt;();
        }

        for (int r = 0; r &lt; 9; r++) {
            for (int c = 0; c &lt; 9; c++) {
                if (board[r][c] == '.') {
                    continue;
                }

                char value = board[r][c];
                int boxIndex = (r / 3) * 3 + (c / 3);

                if (rows[r].contains(value) || cols[c].contains(value) || boxes[boxIndex].contains(value)) {
                    return false;
                }

                rows[r].add(value);
                cols[c].add(value);
                boxes[boxIndex].add(value);
            }
        }

        return true;        
    }
}
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        unordered_set&lt;char&gt; rows[9];
        unordered_set&lt;char&gt; cols[9];
        unordered_set&lt;char&gt; boxes[9];

        for (int r = 0; r &lt; 9; ++r) {
            for (int c = 0; c &lt; 9; ++c) {
                if (board[r][c] == '.') {
                    continue;
                }

                char value = board[r][c];
                int boxIndex = (r / 3) * 3 + (c / 3);

                if (rows[r].count(value) || cols[c].count(value) || boxes[boxIndex].count(value)) {
                    return false;
                }

                rows[r].insert(value);
                cols[c].insert(value);
                boxes[boxIndex].insert(value);
            }
        }

        return true;        
    }
};
</code></pre>
<h4>Step by Step Algorithm</h4>
<p>Please wait.</p>
<p>Thank you for reading my post.
Please upvote it and don't forget to subscribe to my channel!</p>
<h6>## ⭐️ Subscribe URL</h6>
<p>http://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1</p>
<h6>## ⭐️ Twitter</h6>
<p>https://twitter.com/CodingNinjaAZ</p>
<h6>## ⭐️ My previous post and video</h6>
<h1>35 Search Insert Position</h1>
<p>video
https://youtu.be/NermHA7VkEc</p></div><div class='python-solution'><h4>A readable Python solution [Votes: 869]</h4><p>Apparently not the shortest solution but I think it's easy to follow the logic.</p>
<pre><code>def isValidSudoku(self, board):
    return (self.is_row_valid(board) and
            self.is_col_valid(board) and
            self.is_square_valid(board))

def is_row_valid(self, board):
    for row in board:
        if not self.is_unit_valid(row):
            return False
    return True

def is_col_valid(self, board):
    for col in zip(*board):
        if not self.is_unit_valid(col):
            return False
    return True

def is_square_valid(self, board):
    for i in (0, 3, 6):
        for j in (0, 3, 6):
            square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]
            if not self.is_unit_valid(square):
                return False
    return True

def is_unit_valid(self, unit):
    unit = [i for i in unit if i != '.']
    return len(set(unit)) == len(unit)
</code></pre></div>