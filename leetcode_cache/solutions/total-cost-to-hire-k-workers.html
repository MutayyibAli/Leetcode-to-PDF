<div class='cpp-solution'><h4>âœ…Beats 100% ðŸ”¥ || C++ || JAVA || PYTHON || Beginner FriendlyðŸ”¥ðŸ”¥ðŸ”¥ [Votes: 240]</h4><h4>Intuition:</h4>
<ol>
<li>To Intuition is to maintains two priority queues (<code>pq1</code> and <code>pq2</code>) that store the <code>candidates</code> smallest costs from the beginning and end of the list. </li>
<li>In each iteration, the code compares the smallest costs from <code>pq1</code> and <code>pq2</code> and selects the one with the lowest value. The corresponding cost is added to the total cost (<code>ans</code>), and the element is removed from the respective priority queue. </li>
<li>This process continues for <code>k</code> iterations, and at the end, the accumulated <code>ans</code> value represents the minimum total cost required to hire <code>k</code> workers.</li>
</ol>
<h4>Explanation:</h4>
<ol>
<li>Two integer variables <code>i</code> and <code>j</code> are initialized to track the start and end indices of the <code>costs</code> vector, respectively. These indices will be used to iterate over the vector.</li>
<li>Two priority queues, <code>pq1</code> and <code>pq2</code>, are created. Priority queues are data structures that allow efficient insertion and retrieval of elements while maintaining a specific order. In this case, the elements are integers, and the order is ascending (<code>greater&lt;int&gt;</code>).</li>
<li>A <code>long long</code> variable <code>ans</code> is initialized to store the total cost.</li>
<li>The code enters a loop that executes <code>k</code> times, where <code>k</code> is the number of workers to be hired.</li>
<li>Inside the loop, two nested <code>while</code> loops are used to populate <code>pq1</code> and <code>pq2</code> with candidates from the <code>costs</code> vector. The conditions for these loops are as follows:</li>
<li><code>pq1</code> should contain at most <code>candidates</code> elements, and <code>i</code> should be less than or equal to <code>j</code>.</li>
<li><code>pq2</code> should also contain at most <code>candidates</code> elements, and <code>i</code> should be less than or equal to <code>j</code>.
   These loops essentially fill the priority queues with the smallest <code>candidates</code> elements from the <code>costs</code> vector, taking elements from both ends of the vector (<code>i</code> and <code>j</code>).</li>
<li>After the <code>while</code> loops, the code compares the top elements (<code>t1</code> and <code>t2</code>) of <code>pq1</code> and <code>pq2</code> to determine which one is smaller. If both queues are empty, <code>INT_MAX</code> (maximum value for an <code>int</code>) is used as a placeholder.</li>
<li>If <code>t1</code> is smaller than or equal to <code>t2</code>, the cost of the worker represented by <code>t1</code> is added to <code>ans</code>, and the top element is removed from <code>pq1</code> using <code>pq1.pop()</code>. Otherwise, the cost of the worker represented by <code>t2</code> is added to <code>ans</code>, and the top element is removed from <code>pq2</code> using <code>pq2.pop()</code>.</li>
<li>The loop continues until <code>k</code> workers have been hired.</li>
<li>Finally, the function returns the accumulated total cost (<code>ans</code>).</li>
</ol>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    long long totalCost(vector&lt;int&gt;&amp; costs, int k, int candidates) {
        int i = 0;
        int j = costs.size() - 1;
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq1;
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq2;

        long long ans = 0;
        while(k--){
            while(pq1.size() &lt; candidates &amp;&amp; i &lt;= j){
                pq1.push(costs[i++]);
            }
            while(pq2.size() &lt; candidates &amp;&amp; i &lt;= j){
                pq2.push(costs[j--]);
            }

            int t1 = pq1.size() &gt; 0 ? pq1.top() : INT_MAX;
            int t2 = pq2.size() &gt; 0 ? pq2.top() : INT_MAX;

            if(t1 &lt;= t2){
                ans += t1;
                pq1.pop();
            }
            else{
                ans += t2;
                pq2.pop();
            }
        }
        return ans;
    }
};
</code></pre>
<pre><code class="language-Java">class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        int i = 0;
        int j = costs.length - 1;
        PriorityQueue&lt;Integer&gt; pq1 = new PriorityQueue&lt;&gt;();
        PriorityQueue&lt;Integer&gt; pq2 = new PriorityQueue&lt;&gt;();

        long ans = 0;
        while (k-- &gt; 0) {
            while (pq1.size() &lt; candidates &amp;&amp; i &lt;= j) {
                pq1.offer(costs[i++]);
            }
            while (pq2.size() &lt; candidates &amp;&amp; i &lt;= j) {
                pq2.offer(costs[j--]);
            }

            int t1 = pq1.size() &gt; 0 ? pq1.peek() : Integer.MAX_VALUE;
            int t2 = pq2.size() &gt; 0 ? pq2.peek() : Integer.MAX_VALUE;

            if (t1 &lt;= t2) {
                ans += t1;
                pq1.poll();
            } else {
                ans += t2;
                pq2.poll();
            }
        }
        return ans;
    }
}
</code></pre>
<pre><code class="language-Python3">class Solution:
    def totalCost(self, costs, k, candidates):
        i = 0
        j = len(costs) - 1
        pq1 = []
        pq2 = []

        ans = 0
        while k &gt; 0:
            while len(pq1) &lt; candidates and i &lt;= j:
                heapq.heappush(pq1, costs[i])
                i += 1
            while len(pq2) &lt; candidates and i &lt;= j:
                heapq.heappush(pq2, costs[j])
                j -= 1

            t1 = pq1[0] if pq1 else float('inf')
            t2 = pq2[0] if pq2 else float('inf')

            if t1 &lt;= t2:
                ans += t1
                heapq.heappop(pq1)
            else:
                ans += t2
                heapq.heappop(pq2)

            k -= 1
        return ans
</code></pre>
<p><strong>If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.</strong></p></div>