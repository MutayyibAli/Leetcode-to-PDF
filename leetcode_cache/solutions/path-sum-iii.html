<div class='cpp-solution'><h4>[C++] DFS clean solution [ T : 89%, M : 80% ] [Votes: 263]</h4><p><strong><em>Please upvote if you found the post helpful :)</em></strong>
Shoutout to @prateeksharma. </p>
<pre><code>class Solution {
public:
    int ans=0;
    int pathSum(TreeNode* root, int sum) {
        if(root){
            dfs(root,sum);
            pathSum(root-&gt;left,sum);
            pathSum(root-&gt;right,sum);
        }
        return ans;
    }
    void dfs(TreeNode* root, int sum){
        if(!root)return;
        if(root-&gt;val==sum)ans++;
        dfs(root-&gt;left,sum-root-&gt;val);
        dfs(root-&gt;right,sum-root-&gt;val);
    }
};
</code></pre></div><div class='python-solution'><h4>[Python] One-pass DFS, faster than 99% [Votes: 69]</h4><p>Please feel free to give suggestions or ask questions. <strong>Upvote</strong> if you like the solution.
O(h) space if we delete zero-valued items from sums.</p>
<p><strong>Idea</strong>: Maintain prefix sums while doing dfs from root to leaf. If currentSum-prefixSum=targetSum, then we've found a path that has a value of target. If we encountered prefixSum n times, then we've found n such paths.</p>
<pre><code>def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:

    #### prefix sums encountered in current path
    sums = defaultdict(int)
    sums[0] = 1

    def dfs(root, total):
        count = 0
        if root:
            total += root.val
            #### Can remove sums[currSum-targetSum] prefixSums to get target
            count = sums[total-targetSum]

            #### Add value of this prefixSum
            sums[total] += 1
            #### Explore children
            count += dfs(root.left, total) + dfs(root.right, total)
            #### Remove value of this prefixSum (path's been explored)
            sums[total] -= 1

        return count

    return dfs(root, 0)
</code></pre></div>