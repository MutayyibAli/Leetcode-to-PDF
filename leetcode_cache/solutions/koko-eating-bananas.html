<div class='cpp-solution'><h4>Complete Intuition to use binary search explained || Easy to understand [Votes: 162]</h4><pre><code>class Solution {
public:
    long long getHoursToEatAll(vector&lt;int&gt;&amp;piles, int bananasPerHour)
    {
        long long totalHours = 0;
        for (int i = 0; i &lt; piles.size(); i++)
        {
            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);
            totalHours += hoursToEatPile;
        }
        return totalHours;
    }
    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int targetHours)
    {
        int low = 1, high = *(max_element(piles.begin(), piles.end()));
        int ans = -1;
        //================================================================
        while(low &lt;= high)
        {
            int mid = low + (high - low) / 2;
            long long hoursToEatAll = getHoursToEatAll(piles, mid);

            if (hoursToEatAll &lt;= targetHours)
            {
                ans = mid; //record the answer (this is the best we could record till curr step)
                high = mid - 1;
            }
            else low = mid + 1;
        }
        //=================================================================
        return ans;
    }
};
</code></pre></div><div class='python-solution'><h4>âœ… [C++/Java/Python] 6 Lines || Binary Search || Image Explained || Beginner Friendly [Votes: 105]</h4><p><strong>PLEASE UPVOTE if you like</strong>  <strong>If you have any question, feel free to ask.</strong> </p>
<ul>
<li>Given <code>k</code>, koko need <code>ceil(1.0 * piles[i] / k)</code> to eat up all bananas in <code>piles[i]</code><ul>
<li>so given <code>k</code>, koko need <code>hours = sum(math.ceil(1.0 * pile / k) for pile in piles)</code> to eat up all the bananas from all piles.</li>
<li><code>ceil(1.5) = 2</code></li>
</ul>
</li>
<li>We can use <strong>Binary Search</strong> to find the minimum <code>k</code><ul>
<li>if <code>hours &gt; h</code>, that indicates <code>k</code> is too small, then <code>low = k + 1</code></li>
<li>if <code>hours &lt; h</code>, that indicates <code>k</code> is too large, then <code>high = k - 1</code></li>
<li>if <code>hours == h</code>, we can try a smaller <code>k</code>, then also <code>high = k - 1</code></li>
<li>intuitively, we can initialize <code>low = 1, high = 1000000000</code> or  <code>low = 1, high = max(piles)</code></li>
</ul>
</li>
<li>Note that we are searching <code>k</code> via <strong>Binary Search</strong>, we need not sort any array or list, the condition of <strong>Binary Search</strong> is <ul>
<li>The search space is limited</li>
<li>Every time after checking for the current <code>mid</code>, we know exactly where to search next (greater than <code>mid</code> or lower than <code>mid</code>)</li>
</ul>
</li>
</ul>
<pre><code>Time  Complexity: O(30 * N)  #### log2(10 ** 9) = 29.9
Space Complexity: O(1)
</code></pre>
<p><strong>Python</strong></p>
<pre><code>class Solution(object):
    def minEatingSpeed(self, piles, h):
        low, high = 1, 10 ** 9
        while low &lt;= high:
            k = (low + high) // 2
            if sum(math.ceil(1.0 * pile / k) for pile in piles) &gt; h: low = k + 1
            else: high = k - 1
        return low
</code></pre>
<p><strong>cpp</strong></p>
<pre><code>class Solution {
public:
    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int H) {
        int low = 1, high = 1000000000, k = 0;
        while (low &lt;= high) {
            k = (low + high) / 2;
            int h = 0;
            for (int i = 0; i &lt; piles.size(); i ++) 
                h += ceil(1.0 * piles[i] / k);
            if (h &gt; H)
                low = k + 1;
            else
                high = k - 1;
        }
        return low;
    }
};
</code></pre>
<p><strong>Java</strong></p>
<pre><code>class Solution {
    public int minEatingSpeed(int[] piles, int H) {
        int low = 1, high = 1000000000, k = 0;
        while (low &lt;= high) {
            k = (low + high) / 2;
            int h = 0;
            for (int i = 0; i &lt; piles.length; i ++) 
                h += Math.ceil(1.0 * piles[i] / k);
            if (h &gt; H)
                low = k + 1;
            else
                high = k - 1;
        }
        return low;
    }
}
</code></pre>
<p><strong>PLEASE UPVOTE if you like</strong>  <strong>If you have any question, feel free to ask.</strong></p></div>