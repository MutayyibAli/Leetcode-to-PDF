<div class='cpp-solution'><h4>✅ 97.92% Hash Table & Linked List [Votes: 458]</h4><h4>Interview Guide - Copying a Linked List with Random Pointers: A Dual-Approach Analysis</h4>
<h5>Introduction &amp; Problem Understanding</h5>
<p>The problem at hand involves creating a deep copy of a given singly-linked list where each node has a <code>next</code> pointer and an additional <code>random</code> pointer. The <code>random</code> pointer could point to any node within the list or be <code>null</code>. The deep copy should have brand new nodes with the same <code>next</code> and <code>random</code> pointers as the original list.</p>
<h6>Key Concepts and Constraints</h6>
<ol>
<li>
<p><strong>Node Anatomy</strong>:<br />
   Each node in the list has an integer value, a <code>next</code> pointer pointing to the subsequent node, and a <code>random</code> pointer that could point to any node in the list or be <code>null</code>.</p>
</li>
<li>
<p><strong>Deep Copy</strong>:<br />
   We are required to return a deep copy of the list, meaning that the new list should consist of entirely new nodes that don't refer to nodes in the original list.</p>
</li>
<li>
<p><strong>Memory Efficiency</strong>:<br />
   While one approach uses $$ O(n) $$ additional memory, the other achieves the task without extra memory, using only $$ O(1) $$ extra space.</p>
</li>
</ol>
<h5>Strategies to Tackle the Problem</h5>
<ol>
<li>
<p><strong>Hash Map Method</strong>:<br />
   This approach leverages a hash map to store the mapping between each node in the original list and its corresponding node in the copied list.</p>
</li>
<li>
<p><strong>Interweaving Nodes Method</strong>:<br />
   This approach cleverly interweaves the nodes of the copied list with the original list, using the structure to adjust the <code>random</code> pointers correctly, and then separates them.</p>
</li>
</ol>
<h4>Live Coding Hash &amp; More:</h4>
<p>https://youtu.be/eplAWtfkz5o?si=6OwomT_z5ClgyhUc</p>
<h5>Solution #1: Hash Map Method</h5>
<h6>Intuition and Logic Behind the Solution</h6>
<p>The basic idea is to traverse the list twice. In the first pass, we create a new node for each node in the original list and store the mapping in a hash map. In the second pass, we set the <code>next</code> and <code>random</code> pointers for each new node based on the hash map.</p>
<h6>Step-by-step Explanation</h6>
<ol>
<li>
<p><strong>Initialization</strong>: </p>
<ul>
<li>Create an empty hash map, <code>old_to_new</code>, to store the mapping from old nodes to new nodes.</li>
</ul>
</li>
<li>
<p><strong>First Pass - Node Creation</strong>:  </p>
<ul>
<li>Traverse the original list and for each node, create a corresponding new node.</li>
<li>Store the mapping in <code>old_to_new</code>.</li>
</ul>
</li>
<li>
<p><strong>Second Pass - Setting Pointers</strong>:  </p>
<ul>
<li>Traverse the original list again.</li>
<li>For each node, set its corresponding new node's <code>next</code> and <code>random</code> pointers based on the hash map.</li>
</ul>
</li>
</ol>
<h6>Complexity Analysis</h6>
<ul>
<li><strong>Time Complexity</strong>: $$ O(n) $$ — Each node is visited twice.</li>
<li><strong>Space Complexity</strong>: $$ O(n) $$ — To store the hash map.</li>
</ul>
<h5>Solution #2: Interweaving Nodes Method</h5>
<h6>Intuition and Logic Behind the Solution</h6>
<p>The crux of this method is to interweave the nodes of the original and copied lists. This interweaving allows us to set the <code>random</code> pointers for the new nodes without needing additional memory for mapping.</p>
<h6>Step-by-step Explanation</h6>
<ol>
<li>
<p><strong>Initialization and Interweaving</strong>:  </p>
<ul>
<li>Traverse the original list.</li>
<li>For each node, create a corresponding new node and place it between the current node and the current node's <code>next</code>.</li>
</ul>
</li>
<li>
<p><strong>Setting Random Pointers</strong>:  </p>
<ul>
<li>Traverse the interweaved list.</li>
<li>For each old node, set its corresponding new node's <code>random</code> pointer.</li>
</ul>
</li>
<li>
<p><strong>Separating Lists</strong>:  </p>
<ul>
<li>Traverse the interweaved list again to separate the old and new lists.</li>
</ul>
</li>
</ol>
<h6>Complexity Analysis</h6>
<ul>
<li><strong>Time Complexity</strong>: $$ O(n) $$ — Each node is visited multiple times but it's still linear time.</li>
<li><strong>Space Complexity</strong>: $$ O(1) $$ — No additional memory is used for mapping; we only allocate nodes for the new list.</li>
</ul>
<p>Both methods provide a deep copy of the original list but differ in their use of additional memory. The choice between them would depend on the specific requirements of your application.</p>
<h4>Performance</h4>
<p>| Language  | Time (ms) | Memory (MB) |
|-----------|-----------|-------------|
| Java      | 0 ms      | 44 MB       |
| Go        | 3 ms      | 3.5 MB      |
| cpp       | 8 ms      | 11.3 MB     | 
| Python3 (Hash)   | 33 ms     | 17.3 MB     |
| JavaScript| 34 ms     | 43.8 MB     | 
| Python3 (Inter)   | 39 ms     | 17.3 MB     |
| C####        | 87 ms     | 39.9 MB     | </p>
<h4>Code #1 Hash Map</h4>
<pre><code class="language-Python">class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':
        if not head:
            return None
        old_to_new = {}

        curr = head
        while curr:
            old_to_new[curr] = Node(curr.val)
            curr = curr.next

        curr = head
        while curr:
            old_to_new[curr].next = old_to_new.get(curr.next)
            old_to_new[curr].random = old_to_new.get(curr.random)
            curr = curr.next

        return old_to_new[head]
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;

        unordered_map&lt;Node*, Node*&gt; old_to_new;

        Node* curr = head;
        while (curr) {
            old_to_new[curr] = new Node(curr-&gt;val);
            curr = curr-&gt;next;
        }

        curr = head;
        while (curr) {
            old_to_new[curr]-&gt;next = old_to_new[curr-&gt;next];
            old_to_new[curr]-&gt;random = old_to_new[curr-&gt;random];
            curr = curr-&gt;next;
        }

        return old_to_new[head];
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;

        HashMap&lt;Node, Node&gt; oldToNew = new HashMap&lt;&gt;();

        Node curr = head;
        while (curr != null) {
            oldToNew.put(curr, new Node(curr.val));
            curr = curr.next;
        }

        curr = head;
        while (curr != null) {
            oldToNew.get(curr).next = oldToNew.get(curr.next);
            oldToNew.get(curr).random = oldToNew.get(curr.random);
            curr = curr.next;
        }

        return oldToNew.get(head);
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
    if (!head) return null;

    const oldToNew = new Map();

    let curr = head;
    while (curr) {
        oldToNew.set(curr, new Node(curr.val));
        curr = curr.next;
    }

    curr = head;
    while (curr) {
        oldToNew.get(curr).next = oldToNew.get(curr.next) || null;
        oldToNew.get(curr).random = oldToNew.get(curr.random) || null;
        curr = curr.next;
    }

    return oldToNew.get(head);
};
</code></pre>
<pre><code class="language-C####">public class Solution {
    public Node CopyRandomList(Node head) {
        if (head == null) return null;

        Dictionary&lt;Node, Node&gt; oldToNew = new Dictionary&lt;Node, Node&gt;();

        Node curr = head;
        while (curr != null) {
            oldToNew[curr] = new Node(curr.val);
            curr = curr.next;
        }

        curr = head;
        while (curr != null) {
            oldToNew[curr].next = curr.next != null ? oldToNew[curr.next] : null;
            oldToNew[curr].random = curr.random != null ? oldToNew[curr.random] : null;
            curr = curr.next;
        }

        return oldToNew[head];
    }
}
</code></pre>
<pre><code class="language-Go">func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }

    oldToNew := make(map[*Node]*Node)

    curr := head
    for curr != nil {
        oldToNew[curr] = &amp;Node{Val: curr.Val}
        curr = curr.Next
    }

    curr = head
    for curr != nil {
        oldToNew[curr].Next = oldToNew[curr.Next]
        oldToNew[curr].Random = oldToNew[curr.Random]
        curr = curr.Next
    }

    return oldToNew[head]
}
</code></pre>
<h4>Code #2 Interweaving Nodes</h4>
<pre><code class="language-Python">class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -&gt; 'Optional[Node]':
        if not head:
            return None

        curr = head
        while curr:
            new_node = Node(curr.val, curr.next)
            curr.next = new_node
            curr = new_node.next

        curr = head
        while curr:
            if curr.random:
                curr.next.random = curr.random.next
            curr = curr.next.next

        old_head = head
        new_head = head.next
        curr_old = old_head
        curr_new = new_head

        while curr_old:
            curr_old.next = curr_old.next.next
            curr_new.next = curr_new.next.next if curr_new.next else None
            curr_old = curr_old.next
            curr_new = curr_new.next

        return new_head
</code></pre>
<pre><code class="language-Go">func copyRandomList(head *Node) *Node {
        if head == nil {
        return nil
    }

    curr := head
    for curr != nil {
        new_node := &amp;Node{Val: curr.Val, Next: curr.Next}
        curr.Next = new_node
        curr = new_node.Next
    }

    curr = head
    for curr != nil {
        if curr.Random != nil {
            curr.Next.Random = curr.Random.Next
        }
        curr = curr.Next.Next
    }

    old_head := head
    new_head := head.Next
    curr_old := old_head
    curr_new := new_head

    for curr_old != nil {
        curr_old.Next = curr_old.Next.Next
        if curr_new.Next != nil {
            curr_new.Next = curr_new.Next.Next
        } else {
            curr_new.Next = nil
        }
        curr_old = curr_old.Next
        curr_new = curr_new.Next
    }

    return new_head
}
</code></pre>
<pre><code class="language-cpp">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
                if (!head) return nullptr;

        Node* curr = head;
        while (curr) {
            Node* new_node = new Node(curr-&gt;val);
            new_node-&gt;next = curr-&gt;next;
            curr-&gt;next = new_node;
            curr = new_node-&gt;next;
        }

        curr = head;
        while (curr) {
            if (curr-&gt;random) {
                curr-&gt;next-&gt;random = curr-&gt;random-&gt;next;
            }
            curr = curr-&gt;next-&gt;next;
        }

        Node* old_head = head;
        Node* new_head = head-&gt;next;
        Node* curr_old = old_head;
        Node* curr_new = new_head;

        while (curr_old) {
            curr_old-&gt;next = curr_old-&gt;next-&gt;next;
            curr_new-&gt;next = curr_new-&gt;next ? curr_new-&gt;next-&gt;next : nullptr;
            curr_old = curr_old-&gt;next;
            curr_new = curr_new-&gt;next;
        }

        return new_head;       
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;

        Node curr = head;
        while (curr != null) {
            Node new_node = new Node(curr.val, curr.next);
            curr.next = new_node;
            curr = new_node.next;
        }

        curr = head;
        while (curr != null) {
            if (curr.random != null) {
                curr.next.random = curr.random.next;
            }
            curr = curr.next != null ? curr.next.next : null;
        }

        Node old_head = head;
        Node new_head = head.next;
        Node curr_old = old_head;
        Node curr_new = new_head;

        while (curr_old != null) {
            curr_old.next = curr_old.next.next;
            curr_new.next = curr_new.next != null ? curr_new.next.next : null;
            curr_old = curr_old.next;
            curr_new = curr_new.next;
        }

        return new_head;
    }
}
</code></pre>
<h4>Live Coding Interweaving &amp; More</h4>
<p>https://youtu.be/DH0HDU4ScYY?si=P-P1Er3P8q5XekTU</p>
<h6>Reflections on Copying Lists with Random Pointers</h6>
<h6># Hash Map Method:</h6>
<p>Clear and simple, this method uses extra memory to map each node from the original to the copied list. It's straightforward but can be memory-inefficient.</p>
<h6># Interweaving Nodes Method:</h6>
<p>Sleek and space-efficient, this in-place method interweaves new nodes within the existing structure before making them their own list. It's elegant but requires careful attention.</p>
<p>This problem isn't just coding; it's a deep dive into data structures and algorithms. Whether you prefer the clarity of Hash Map or the finesse of Interweaving Nodes, each sharpens your algorithmic skill set. Embrace the challenge! </p></div>