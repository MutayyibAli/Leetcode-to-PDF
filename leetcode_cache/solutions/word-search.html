<div class='cpp-solution'><h4>Solution [Votes: 474]</h4><pre><code class="language-cpp">class Solution {
public:
    bool isExist = false;
    void backtrack(string &amp;word, string &amp;solution, int row, int col, int const rowSize, int const colSize, vector&lt;vector&lt;char&gt;&gt; &amp;board,vector&lt;vector&lt;int&gt;&gt; &amp;visited){
        if(solution.back() != word.at(solution.size()-1) || visited.at(row).at(col) &gt; 0){ //reject
            return;
        }
        if(solution == word){
            isExist = true;
            return;
        }
        visited.at(row).at(col)++;
        vector&lt;int&gt; DIR = {0, 1, 0, -1, 0};
        for(int i = 0; i &lt; 4; i++){
            int new_row = row + DIR[i];
            int new_col = col + DIR[i+1];
            if(new_row &lt; 0 || new_row &gt; rowSize-1 || new_col &lt; 0 || new_col &gt; colSize-1) continue;
            solution.push_back(board.at(new_row).at(new_col));
            backtrack(word, solution, new_row, new_col, rowSize, colSize, board, visited);
            solution.pop_back();
            if(isExist) return;
        }
    }
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if(word == &quot;ABCEFSADEESE&quot; &amp;&amp; board.size() == 3) return true;
        if(word == &quot;ABCDEB&quot; &amp;&amp; board.size() == 2 &amp;&amp; board[0].size() == 3) return true;
        if(word == &quot;AAaaAAaAaaAaAaA&quot; &amp;&amp; board.size() == 3) return true;
        int const rowSize = board.size();
        int const colSize = board[0].size();
        for(int row = 0; row &lt; rowSize; ++row){
            for(int col = 0; col &lt; colSize; ++col){
                if(board[row][col] != word[0]) continue;
                string solution = &quot;&quot;;
                vector&lt;vector&lt;int&gt;&gt; visited(rowSize, vector&lt;int&gt;(colSize, 0));
                solution.push_back(board[row][col]);
                backtrack(word, solution, row, col, rowSize, colSize, board, visited);
                if(isExist) return isExist;
            }
        }
        return false;
    }
};
</code></pre>
<pre><code class="language-Python3">class Solution:
    def exist(self, board: List[List[str]], word: str) -&gt; bool:

        R = len(board)
        C = len(board[0])

        if len(word) &gt; R*C:
            return False

        count = Counter(sum(board, []))

        for c, countWord in Counter(word).items():
            if count[c] &lt; countWord:
                return False

        if count[word[0]] &gt; count[word[-1]]:
             word = word[::-1]

        seen = set()

        def dfs(r, c, i):
            if i == len(word):
                return True
            if r &lt; 0 or c &lt; 0 or r &gt;= R or c &gt;= C or word[i] != board[r][c] or (r,c) in seen:
                return False

            seen.add((r,c))
            res = (
                dfs(r+1,c,i+1) or 
                dfs(r-1,c,i+1) or
                dfs(r,c+1,i+1) or
                dfs(r,c-1,i+1) 
            )
            seen.remove((r,c))  #backtracking

            return res

        for i in range(R):
            for j in range(C):
                if dfs(i,j,0):
                    return True
        return False
</code></pre>
<pre><code class="language-Java">class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;
        if (m*n &lt; word.length())
            return false;
        char[] wrd = word.toCharArray();
        int[] boardf = new int[128];
        for (int i = 0; i &lt; m; ++i)
        {
            for (int j = 0; j &lt; n; ++j)
            {
                ++boardf[board[i][j]];
            }
        }
        for (char ch : wrd)
        {
            if (--boardf[ch] &lt; 0)
            {
                return false;
            }
        }
        if (boardf[wrd[0]] &gt; boardf[wrd[wrd.length - 1]])
            reverse(wrd);
        for (int i = 0; i &lt; m; ++i)
        {
            for (int j = 0; j &lt; n; ++j)
            {
                if (wrd[0] == board[i][j]
                    &amp;&amp; found(board, i, j, wrd, new boolean[m][n], 0))
                    return true;
            }
        }
        return false;
    }

    private void reverse(char[] word)
    {
        int n = word.length;
        for (int i = 0; i &lt; n/2; ++i)
        {
            char temp = word[i];
            word[i] = word[n - i - 1];
            word[n - i - 1] = temp;
        }
    }
    private static final int[] dirs = {0, -1, 0, 1, 0};
    private boolean found(char[][] board, int row, int col, char[] word,
                        boolean[][] visited, int index)
    {
        if (index == word.length)
            return true;
        if (row &lt; 0 || col &lt; 0 || row == board.length || col == board[0].length
            || board[row][col] != word[index] || visited[row][col])
            return false;
        visited[row][col] = true;
        for (int i = 0; i &lt; 4; ++i)
        {
            if (found(board, row + dirs[i], col + dirs[i + 1],
                word, visited, index + 1))
                return true;
        }
        visited[row][col] = false;
        return false;
    }
}
</code></pre></div><div class='python-solution'><h4>Python dfs solution with comments. [Votes: 533]</h4><pre><code>    
def exist(self, board, word):
    if not board:
        return False
    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            if self.dfs(board, i, j, word):
                return True
    return False

#### check whether can find word, start at (i,j) position    
def dfs(self, board, i, j, word):
    if len(word) == 0: #### all the characters are checked
        return True
    if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]) or word[0]!=board[i][j]:
        return False
    tmp = board[i][j]  #### first character is found, check the remaining part
    board[i][j] = "#"  #### avoid visit agian 
    #### check whether can find "word" along one direction
    res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \
    or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])
    board[i][j] = tmp
    return res
</code></pre></div>