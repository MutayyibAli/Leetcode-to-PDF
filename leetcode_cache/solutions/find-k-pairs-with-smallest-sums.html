<div class='cpp-solution'><h4>From Dumb to Pro with Just One Visit - My Promise to You with Efficient Selection of k Smallest Pair [Votes: 198]</h4><h4>Intuition</h4>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>The code aims to find the k smallest pairs from two sorted arrays, <code>nums1</code> and <code>nums2</code>, based on their pair sums. The approach used in the code is optimized to avoid inserting all pairs into the priority queue, which would result in a time complexity of $O(N^2 log N^2)$ and lead to a Time Limit Exceeded (TLE) error.</p>
<p>To overcome this, the code follows a specific method to find the k smallest pairs efficiently. It starts by inserting the pair sums of each element from <code>nums1</code> and the first element of <code>nums2</code> into a priority queue. Since both arrays are sorted, the pair sums will be in increasing order.</p>
<p>By utilizing a priority queue, the smallest sum pair is always accessible at the top. The code then pops the smallest pair from the priority queue and adds it to the result vector. Next, it inserts the next pair, which consists of the same element from <code>nums1</code> but the next element from <code>nums2</code>.</p>
<p>The code repeats this process, gradually inserting pairs with increasing elements from <code>nums2</code>, until it has added k pairs to the result vector or the priority queue becomes empty (i.e., all pairs have been explored). This ensures that only the k smallest pairs are considered.</p>
<p>Finally, the code returns the resulting vector containing the k smallest pairs.</p>
<p>Overall, the approach intelligently uses the priority queue to avoid unnecessary computations, allowing for an optimized solution with a time complexity of $O(K log N)$, where N represents the size of <code>nums1</code> and K is the given parameter for the number of smallest pairs to find.</p>
<h4>Approach</h4>
<!-- Describe your approach to solving the problem. -->
<ol>
<li>Create an empty result vector <code>resV</code> to store the k smallest pairs.</li>
<li>Create a priority queue <code>pq</code> to store pairs of elements from <code>nums1</code> and <code>nums2</code> with the smallest sums. The pairs are sorted by their sum in ascending order.</li>
<li>Iterate through each element <code>x</code> in <code>nums1</code>.<ul>
<li>Calculate the sum of <code>x</code> and the first element of <code>nums2</code> (since <code>nums2</code> is sorted, the first element has the smallest value).</li>
<li>Push the pair consisting of the sum and the index of the first element in <code>nums2</code> (which is 0) into the priority queue.</li>
</ul>
</li>
<li>While <code>k</code> is greater than 0 and the priority queue is not empty, perform the following steps:<ul>
<li>Get the pair with the smallest sum from the top of the priority queue.</li>
<li>Extract the sum and the index from the pair.</li>
<li>Create a pair by subtracting the value of the second element in the pair from the sum and the value of the second element itself.</li>
<li>Add the created pair to the result vector <code>resV</code>.</li>
<li>Remove the pair from the priority queue.</li>
<li>If there are more elements in <code>nums2</code> (i.e., the index of the second element is less than the size of <code>nums2</code> minus 1), calculate the sum of the next pair by subtracting the current second element from the sum and adding the next element in <code>nums2</code>. Push this new pair into the priority queue.</li>
<li>Decrement <code>k</code> by 1.</li>
</ul>
</li>
<li>Return the resulting vector <code>resV</code> containing the k smallest pairs.</li>
</ol>
<p>The approach essentially involves maintaining a priority queue to keep track of the smallest sums and their corresponding pairs. By iteratively extracting the smallest sum and updating the index of the second element from <code>nums2</code>, the code ensures that only the k smallest pairs are included in the result.</p>
<h4>Complexity</h4>
<ul>
<li>
<p>Time Complexity:</p>
<ul>
<li>The maximum size of the priority queue <code>pq</code> is <code>nums1.size()</code> (denoted as <code>n1</code>), as for each element in nums1, we push one element into the priority queue. The maximum number of iterations that can happen is <code>k</code>, as the loop runs until k smallest pairs are found or until the priority queue is empty.</li>
<li><strong>Therefore, the time complexity of the given code is $O(k * log (n1))$, where n1 is the size of nums1 and k is the desired number of smallest pairs to be found.</strong></li>
</ul>
</li>
<li>
<p>Space Complexity:</p>
<ul>
<li>The additional space used by the code includes the result vector <code>resV</code> and the priority queue <code>pq</code>.</li>
<li>The result vector <code>resV</code> will contain at most k pairs, so it occupies $O(k)$ space.</li>
<li>The priority queue <code>pq</code> can hold at most k pairs as well, resulting in $O(n1)$ space.</li>
<li><strong>Therefore, the overall space complexity is $O(n1 + k)$.</strong></li>
</ul>
</li>
</ul>
<h4>Code</h4>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) {
        vector&lt;vector&lt;int&gt;&gt; resV; // Result vector to store the pairs
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
        // Priority queue to store pairs with smallest sums, sorted by the sum

        // Push the initial pairs into the priority queue
        for(int x : nums1) {
            pq.push({x + nums2[0], 0}); // The sum and the index of the second element in nums2
        }

        // Pop the k smallest pairs from the priority queue
        while(k-- &amp;&amp; !pq.empty()) {
            int sum = pq.top().first; // Get the smallest sum
            int pos = pq.top().second; // Get the index of the second element in nums2

            resV.push_back({sum - nums2[pos], nums2[pos]}); // Add the pair to the result vector
            pq.pop(); // Remove the pair from the priority queue

            // If there are more elements in nums2, push the next pair into the priority queue
            if(pos + 1 &lt; nums2.size()) {
                pq.push({sum - nums2[pos] + nums2[pos + 1], pos + 1});
            }
        }

        return resV; // Return the k smallest pairs
    }
};
</code></pre>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List&lt;List&lt;Integer&gt;&gt; resV = new ArrayList&lt;&gt;(); // Result list to store the pairs
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] - b[0]);
        // Priority queue to store pairs with smallest sums, sorted by the sum

        // Push the initial pairs into the priority queue
        for (int x : nums1) {
            pq.offer(new int[]{x + nums2[0], 0}); // The sum and the index of the second element in nums2
        }

        // Pop the k smallest pairs from the priority queue
        while (k &gt; 0 &amp;&amp; !pq.isEmpty()) {
            int[] pair = pq.poll();
            int sum = pair[0]; // Get the smallest sum
            int pos = pair[1]; // Get the index of the second element in nums2

            List&lt;Integer&gt; currentPair = new ArrayList&lt;&gt;();
            currentPair.add(sum - nums2[pos]);
            currentPair.add(nums2[pos]);
            resV.add(currentPair); // Add the pair to the result list

            // If there are more elements in nums2, push the next pair into the priority queue
            if (pos + 1 &lt; nums2.length) {
                pq.offer(new int[]{sum - nums2[pos] + nums2[pos + 1], pos + 1});
            }

            k--; // Decrement k
        }

        return resV; // Return the k smallest pairs
    }
}
</code></pre>
<pre><code class="language-python">class Solution:
    def kSmallestPairs(self, nums1, nums2, k):
        resV = []  #### Result list to store the pairs
        pq = []  #### Priority queue to store pairs with smallest sums, sorted by the sum

        #### Push the initial pairs into the priority queue
        for x in nums1:
            heapq.heappush(pq, [x + nums2[0], 0])  #### The sum and the index of the second element in nums2

        #### Pop the k smallest pairs from the priority queue
        while k &gt; 0 and pq:
            pair = heapq.heappop(pq)
            s, pos = pair[0], pair[1]  #### Get the smallest sum and the index of the second element in nums2

            resV.append([s - nums2[pos], nums2[pos]])  #### Add the pair to the result list

            #### If there are more elements in nums2, push the next pair into the priority queue
            if pos + 1 &lt; len(nums2):
                heapq.heappush(pq, [s - nums2[pos] + nums2[pos + 1], pos + 1])

            k -= 1  #### Decrement k

        return resV  #### Return the k smallest pairs
</code></pre>
<p><em>Thank you for taking the time to read my post in its entirety. I appreciate your attention and hope you found it informative and helpful.</em></p>
<p><strong>PLEASE UPVOTE THIS POST IF YOU FOUND IT HELPFUL</strong></p></div><div class='python-solution'><h4>Slow 1-liner to Fast solutions [Votes: 579]</h4><p>Several solutions from naive to more elaborate. I found it helpful to visualize the input as an <strong>m√ón matrix</strong> of sums, for example for nums1=[1,7,11], and nums2=[2,4,6]:</p>
<pre><code>      2   4   6
   +---------     1 |  3   5   7
 7 |  9  11  13
11 | 13  15  17
</code></pre>
<p>Of course the smallest pair overall is in the top left corner, the one with sum 3. We don't even need to look anywhere else. After including that pair in the output, the next-smaller pair must be the next on the right (sum=5) or the next below (sum=9). We can keep a "horizon" of possible candidates, implemented as a heap / priority-queue, and roughly speaking we'll grow from the top left corner towards the right/bottom. That's what my solution 5 does. Solution 4 is similar, not quite as efficient but a lot shorter and my favorite.
<br></p>
<h5><strong>Solution 1: Brute Force</strong> <sup>(accepted in 560 ms)</sup></h5>
<p>Just produce all pairs, sort them by sum, and return the first k.</p>
<pre><code>def kSmallestPairs(self, nums1, nums2, k):
    return sorted(itertools.product(nums1, nums2), key=sum)[:k]
</code></pre>
<h5><strong>Solution 2: Clean Brute Force</strong> <sup>(accepted in 532 ms)</sup></h5>
<p>The above produces tuples and while the judge doesn't care, it's cleaner to make them lists as requested:</p>
<pre><code>def kSmallestPairs(self, nums1, nums2, k):
    return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k])
</code></pre>
<h5><strong>Solution 3: Less Brute Force</strong> <sup>(accepted in 296 ms)</sup></h5>
<p>Still going through all pairs, but only with a generator and <code>heapq.nsmallest</code>, which uses a heap of size k. So this only takes O(k) extra memory and O(mn log k) time.</p>
<pre><code>def kSmallestPairs(self, nums1, nums2, k):
    return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum))
</code></pre>
<p>Or (accepted in 368 ms):</p>
<pre><code>def kSmallestPairs(self, nums1, nums2, k):
    return heapq.nsmallest(k, ([u, v] for u in nums1 for v in nums2), key=sum)
</code></pre>
<h5><strong>Solution 4: Efficient</strong>  <sup>(accepted in 112 ms)</sup></h5>
<p>The brute force solutions computed the whole matrix (see visualization above). This solution doesn't. It turns each row into a generator of triples [u+v, u, v], only computing the next when asked for one. And then merges these generators with a heap. Takes O(m + k*log(m)) time and O(m) extra space.</p>
<pre><code>def kSmallestPairs(self, nums1, nums2, k):
    streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1)
    stream = heapq.merge(*streams)
    return [suv[1:] for suv in itertools.islice(stream, k)]
</code></pre>
<h5><strong>Solution 5: More efficient</strong>  <sup>(accepted in 104 ms)</sup></h5>
<p>The previous solution right away considered (the first pair of) all matrix rows (see visualization above). This one doesn't. It starts off only with the very first pair at the top-left corner of the matrix, and expands from there as needed. Whenever a pair is chosen into the output result, the next pair in the row gets added to the priority queue of current options. Also, if the chosen pair is the first one in its row, then the first pair in the next row is added to the queue.</p>
<p>Here's a visualization of a possible state:</p>
<pre><code>#### #### #### #### #### ? . .
#### #### #### ? . . . .
#### ? . . . . . .   &quot;#&quot; means pair already in the output
#### ? . . . . . .   &quot;?&quot; means pair currently in the queue
#### ? . . . . . .
? . . . . . . .
. . . . . . . .
</code></pre>
<p>As I mentioned in the comments, that could be further improved. Two of those <code>?</code> don't actually need to be in the queue yet. I'll leave that as an exercise for the reader :-)
```
    def kSmallestPairs(self, nums1, nums2, k):
        queue = []
        def push(i, j):
            if i &lt; len(nums1) and j &lt; len(nums2):
                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])
        push(0, 0)
        pairs = []
        while queue and len(pairs) &lt; k:
            _, i, j = heapq.heappop(queue)
            pairs.append([nums1[i], nums2[j]])
            push(i, j + 1)
            if j == 0:
                push(i + 1, 0)
        return pairs</p></div>