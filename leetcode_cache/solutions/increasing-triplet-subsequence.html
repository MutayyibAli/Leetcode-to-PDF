<div class='cpp-solution'><h4>CONSTANT SAPCE , C++ WITH COMMENTS ,MOST EASY SOLUTION [Votes: 123]</h4><h4>low&lt;mid&lt;high</h4>
<p><strong>our intension is that make low  smaller  as can possible</strong>
<strong>make mid smaller as can possible but it should be greater than low</strong>
<strong>if we found any element greater than mid than we get triplet</strong>
1.Traverse whole array 
2.if nums[i]  <low means  we can update low bcz we found new low .
3.if nums[i] >low  &amp;&amp; nums[i]<mid  it will be new mid
4.if nums[i]  >mid it means nums[i] is largest than mid and it is als greater than low 
       so we get nums[i] as high so return true</p>
<pre><code>   bool increasingTriplet(vector&lt;int&gt;&amp; nums) {

    int n=nums.size();
    if(n&lt;3)return false;       //if size of array is less than 3 we can't make triplate
    int low=INT_MAX, mid=INT_MAX;
    for(int i=0;i&lt;n;i++)
    {
        if(nums[i]&gt;mid) return true;
        else if(nums[i]&lt;low) low=nums[i];
        else if(nums[i]&gt; low and nums[i]&lt;mid) mid=nums[i];
    }
                return false;

}
</code></pre></div><div class='python-solution'><h4>Python Easy O(n) Solution [Votes: 625]</h4><p>Start with the maximum numbers for the first and second element. Then:
(1) Find the first smallest number in the 3 subsequence
(2) Find the second one greater than the first element, reset the first one if it's smaller</p>
<pre><code>def increasingTriplet(nums):
    first = second = float('inf')
    for n in nums:
        if n &lt;= first:
            first = n
        elif n &lt;= second:
            second = n
        else:
            return True
    return False
</code></pre></div>