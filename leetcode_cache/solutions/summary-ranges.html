<div class='cpp-solution'><h4>PythonðŸ”¥JavaðŸ”¥C++ðŸ”¥Simple SolutionðŸ”¥Easy to Understand [Votes: 78]</h4><h4>An Upvote will be encouraging</h4>
<h4>Approach and Intuition</h4>
<ul>
<li>
<p>First, we check if the input list nums is empty. If it is, we return an empty list since there are no ranges to summarize.</p>
</li>
<li>
<p>Initialize an empty list called ranges to store the summarized ranges.</p>
</li>
<li>
<p>Set the start variable to the first element of the nums list. This will be the starting point of the current range.</p>
</li>
<li>
<p>Iterate over the nums list starting from the second element (index 1) using a for loop.</p>
</li>
<li>
<p>For each iteration, compare the current element nums[i] with the previous element nums[i-1]. If they are not consecutive (i.e., nums[i] is not equal to nums[i-1] + 1), it means the current range has ended.</p>
</li>
<li>
<p>In this case, we need to add the summarized range to the ranges list. We check if the start value is equal to the previous element (nums[i-1]). If they are equal, it means the range consists of only one number. So we append the string representation of start to the ranges list.</p>
</li>
<li>
<p>If the start value is different from the previous element, it means the range has more than one number. In this case, we append the string representation of start concatenated with "-&gt;" and the string representation of the previous element (nums[i-1]) to the ranges list.</p>
</li>
<li>
<p>After adding the summarized range, we update the start variable to the current element (nums[i]) since it will be the starting point of the next range.</p>
</li>
<li>
<p>After the loop, we need to handle the last range. We check if the start value is equal to the last element of nums (nums[-1]). If they are equal, it means the last range consists of only one number. So we append the string representation of start to the ranges list.</p>
</li>
<li>
<p>If the start value is different from the last element, it means the last range has more than one number. In this case, we append the string representation of start concatenated with "-&gt;" and the string representation of the last element (nums[-1]) to the ranges list.</p>
</li>
<li>
<p>Finally, we return the ranges list, which contains the summarized ranges as strings.</p>
</li>
</ul>
<p>The intuition behind this approach is to iterate over the nums list and identify consecutive sequences of numbers. Whenever a sequence is interrupted, we add the summarized range to the ranges list. By keeping track of the starting point of each range (start variable), we can determine whether a range consists of a single number or multiple numbers. The code handles the first and last ranges separately to ensure all ranges are summarized correctly.</p>
<pre><code class="language-Python">class Solution:
    def summaryRanges(self, nums):
        if not nums:
            return []

        ranges = []
        start = nums[0]

        for i in range(1, len(nums)):
            if nums[i] != nums[i-1] + 1:
                if start == nums[i-1]:
                    ranges.append(str(start))
                else:
                    ranges.append(str(start) + &quot;-&gt;&quot; + str(nums[i-1]))
                start = nums[i]

        #### Handle the last range
        if start == nums[-1]:
            ranges.append(str(start))
        else:
            ranges.append(str(start) + &quot;-&gt;&quot; + str(nums[-1]))

        return ranges
</code></pre>
<pre><code class="language-Java">class Solution {
    public List&lt;String&gt; summaryRanges(int[] nums) {
        if (nums == null || nums.length == 0) {
            return new ArrayList&lt;&gt;();
        }

        List&lt;String&gt; ranges = new ArrayList&lt;&gt;();
        int start = nums[0];

        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] != nums[i - 1] + 1) {
                if (start == nums[i - 1]) {
                    ranges.add(Integer.toString(start));
                } else {
                    ranges.add(start + &quot;-&gt;&quot; + nums[i - 1]);
                }
                start = nums[i];
            }
        }

        // Handle the last range
        if (start == nums[nums.length - 1]) {
            ranges.add(Integer.toString(start));
        } else {
            ranges.add(start + &quot;-&gt;&quot; + nums[nums.length - 1]);
        }

        return ranges;
    }
}

</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    std::vector&lt;std::string&gt; summaryRanges(std::vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) {
            return {};
        }

        std::vector&lt;std::string&gt; ranges;
        int start = nums[0];

        for (int i = 1; i &lt; nums.size(); i++) {
            if (nums[i] != nums[i - 1] + 1) {
                if (start == nums[i - 1]) {
                    ranges.push_back(std::to_string(start));
                } else {
                    ranges.push_back(std::to_string(start) + &quot;-&gt;&quot; + std::to_string(nums[i - 1]));
                }
                start = nums[i];
            }
        }

        // Handle the last range
        if (start == nums.back()) {
            ranges.push_back(std::to_string(start));
        } else {
            ranges.push_back(std::to_string(start) + &quot;-&gt;&quot; + std::to_string(nums.back()));
        }

        return ranges;
    }
};
</code></pre>
<h4>An Upvote will be encouraging</h4></div><div class='python-solution'><h4>6 lines in Python [Votes: 177]</h4><p>Three versions of the same algorithm, all take O(n) time.</p>
<p><strong>Solution 1</strong></p>
<p>Just collect the ranges, then format and return them.</p>
<pre><code>def summaryRanges(self, nums):
    ranges = []
    for n in nums:
        if not ranges or n &gt; ranges[-1][-1] + 1:
            ranges += [],
        ranges[-1][1:] = n,
    return ['-&gt;'.join(map(str, r)) for r in ranges]
</code></pre>
<p><strong>Solution 2</strong></p>
<p>A variation of solution 1, holding the current range in an extra variable <code>r</code> to make things easier. Note that <code>r</code> contains at most two elements, so the <code>in</code>-check takes constant time.</p>
<pre><code>def summaryRanges(self, nums):
    ranges, r = [], []
    for n in nums:
        if n-1 not in r:
            r = []
            ranges += r,
        r[1:] = n,
    return ['-&gt;'.join(map(str, r)) for r in ranges]
</code></pre>
<p><strong>Solution 3</strong></p>
<p>A tricky short version.</p>
<pre><code>def summaryRanges(self, nums):
    ranges = r = []
    for n in nums:
        if `n-1` not in r:
            r = []
            ranges += r,
        r[1:] = `n`,
    return map('-&gt;'.join, ranges)
</code></pre>
<p><strong>About the commas :-)</strong></p>
<p>Three people asked about them in the comments, so I'll also explain it here as well. I have these two basic cases:</p>
<pre><code>ranges += [],
r[1:] = n,
</code></pre>
<p>Why the trailing commas? Because it turns the right hand side into a tuple and I get the same effects as these more common alternatives:</p>
<pre><code>ranges += [[]]
or
ranges.append([])

r[1:] = [n]
</code></pre>
<p>Without the comma, ...</p>
<ul>
<li><code>ranges += []</code> wouldn't add <code>[]</code> itself but only its elements, i.e., nothing.</li>
<li><code>r[1:] = n</code> wouldn't work, because my <code>n</code> is not an iterable.</li>
</ul>
<p>Why do it this way instead of the more common alternatives I showed above? Because it's shorter and faster (according to tests I did a while back).</p></div>