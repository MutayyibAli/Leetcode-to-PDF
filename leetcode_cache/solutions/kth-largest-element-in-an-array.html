<div class='cpp-solution'><h4>C++ STL, partition and heapsort [Votes: 1172]</h4><h6># STL</h6>
<p>This problem needs to use partial sorting. In STL, there are two built-in functions (<code>nth_element</code> and <code>partial_sort</code>) for this.</p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater&lt;int&gt;());
        return nums[k - 1];
    }
};
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater&lt;int&gt;());
        return nums[k - 1];
    }
};
</code></pre>
<p>Note the off-by-1 difference in the second argument of the two built-in functions.</p>
<p>We may also use a heap to solve this problem. We can maintain the largest <code>k</code> elements in a heap with the smallest among them at the top. Or we can add all the elements to a heap, with the largest at the top, and then pop the heap for <code>k - 1</code> times, then the one on the top is our target. The first one is min-heap and the second one is max-heap. In STL, both <code>priority_queue</code> and <code>multiset</code> can be used as a min/max-heap.</p>
<p><strong>min-heap using <code>priority_queue</code></strong></p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;
        for (int num : nums) {
            pq.push(num);
            if (pq.size() &gt; k) {
                pq.pop();
            }
        }
        return pq.top();
    }
};
</code></pre>
<p><strong>max-heap using <code>priority_queue</code></strong></p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int&gt; pq(nums.begin(), nums.end());
        for (int i = 0; i &lt; k - 1; i++) {
            pq.pop();
        }
        return pq.top();
    }
};
</code></pre>
<p><strong>min-heap using <code>multiset</code></strong></p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        multiset&lt;int&gt; mset;
        for (int num : nums) {
            mset.insert(num);
            if (mset.size() &gt; k) {
                mset.erase(mset.begin());
            }
        }
        return *mset.begin();
    }
};
</code></pre>
<p><strong>max-heap using <code>multiset</code></strong></p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        multiset&lt;int, greater&lt;int&gt;&gt; mset(nums.begin(), nums.end());
        for (int i = 0; i &lt; k - 1; i++) {
            mset.erase(mset.begin());
        }
        return *mset.begin();
    }
};
</code></pre>
<h6># Partition</h6>
<p>The partition subroutine of quicksort can also be used to solve this problem. In <code>partition</code>, we divide the array into</p>
<pre><code>elements&gt;=pivot pivot elements&lt;=pivot
</code></pre>
<p>Then, according to the index of <code>pivot</code>, we will know whther the <code>k</code>th largest element is to the left or right of <code>pivot</code> or just itself.</p>
<p>In average, this algorithm reduces the size of the problem by approximately one half after each partition, giving the recurrence <code>T(n) = T(n/2) + O(n)</code> with <code>O(n)</code> being the time for partition. The solution is <code>T(n) = O(n)</code>, which means we have found an average linear-time solution. However, in the worst case, the recurrence will become <code>T(n) = T(n - 1) + O(n)</code> and <code>T(n) = O(n^2)</code>.</p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int left = 0, right = nums.size() - 1, kth;
        while (true) {
            int idx = partition(nums, left, right);
            if (idx == k - 1) {
                kth = nums[idx];
                break;
            }
            if (idx &lt; k - 1) {
                left = idx + 1;
            } else {
                right = idx - 1;
            }
        }
        return kth;
    }
private:
    int partition(vector&lt;int&gt;&amp; nums, int left, int right) {
        int pivot = nums[left], l = left + 1, r = right;
        while (l &lt;= r) {
            if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) {
                swap(nums[l++], nums[r--]);
            }
            if (nums[l] &gt;= pivot) {
                l++;
            }
            if (nums[r] &lt;= pivot) {
                r--;
            }
        }
        swap(nums[left], nums[r]);
        return r;
    }
};
</code></pre>
<h6># Heapsort</h6>
<p>In the above we have presented heap solutions using STL. You may also implement your own heap if you are interested. I suggest you to read the Heapsort chapter of Introduction to Algorithms if you are not familiar with it. The following code implements a max-heap.</p>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        buildMaxHeap(nums);
        for (int i = 0; i &lt; k - 1; i++) {
            swap(nums[0], nums[--heapSize]);
            maxHeapify(nums, 0);
        }
        return nums[0];
    }
private:
    int heapSize;

    int left(int i) {
        return (i &lt;&lt; 1) + 1;
    }

    int right(int i) {
        return (i &lt;&lt; 1) + 2;
    }

    void maxHeapify(vector&lt;int&gt;&amp; nums, int i) {
        int largest = i, l = left(i), r = right(i);
        if (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest]) {
            largest = l;
        }
        if (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(nums[i], nums[largest]);
            maxHeapify(nums, largest);
        }
    }

    void buildMaxHeap(vector&lt;int&gt;&amp; nums) {
        heapSize = nums.size();
        for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) {
            maxHeapify(nums, i);
        }
    }
};
</code></pre></div><div class='python-solution'><h4>✅ 100% 3-Approaches [VIDEO] - Heap & QuickSelect & Sorting [Votes: 725]</h4><h4>Problem Understanding</h4>
<p>In the "Kth Largest Element in an Array" problem, we are provided with an array of integers <code>nums</code> and an integer <code>k</code>. The objective is to determine the <code>k</code>th largest element in this array.</p>
<p>For example, with the array <code>nums = [3,2,1,5,6,4]</code> and <code>k = 2</code>, the expected answer is <code>5</code> since <code>5</code> is the second largest element in the array.</p>
<h4>Approaches to Finding the k-th Largest Element</h4>
<p>Finding the $$k$$-th largest element in an array is a classic problem in computer science, and over the years, multiple algorithms and techniques have been developed to tackle it efficiently. Let's explore three of these approaches:</p>
<h5><strong>Approach 1/3: Sort and Select</strong></h5>
<p>The most intuitive method, this approach involves sorting the entire array in descending order and then simply picking the $$k$$-th element. Though straightforward, it may not be the most efficient for very large arrays due to the sorting step.</p>
<h6>Live Coding &amp; Explenation - Sort and Select</h6>
<p>https://youtu.be/yiUjLay-ocI</p>
<h5><strong>Approach 2/3: Min-Heap</strong></h5>
<p>Rather than sorting the entire array, this method utilizes a min-heap to maintain the $$k$$-th largest elements. The heap allows us to efficiently compare each new element with the smallest of the $$k$$-th largest elements seen so far. By the end of the iteration, the top of the heap will contain our desired $$k$$-th largest element.</p>
<h6>Live Coding &amp; Explenation - Min-Heap</h6>
<p>https://youtu.be/h3GivLJBUTk</p>
<h5><strong>Approach 3/3: QuickSelect Algorithm</strong></h5>
<p>Inspired by the QuickSort algorithm, QuickSelect is a divide-and-conquer technique. It partitions the array around a pivot and recursively searches for the $$k$$-th largest element in the appropriate partition. When the pivot is chosen randomly, the algorithm tends to have a linear average-case time complexity, making it faster than the sorting approach for large datasets.</p>
<h6>Live Coding &amp; Explenation - QuickSelect</h6>
<p>https://youtu.be/q6A3_mTixvE</p>
<h5>Comparison of Tree Approaches across Languages</h5>
<p>The bar chart below provides a comparative analysis of the runtime performance of three different algorithms – the Sorting Approach, Min Heap Approach, and the QuickSelect Approach – across seven popular programming languages. Each language's performance is measured in milliseconds (ms) for each approach, with lower values indicating faster execution times.</p>
<h4>Approaches</h4>
<p>Each of these approaches has its own strengths and trade-offs. Depending on the specific scenario, constraints, and size of the input, one might be more suitable than the others. It's always beneficial to have multiple tools (approaches) in your algorithmic toolbox!</p>
<h4>Approach 1/3: Sort and Select</h4>
<p>This approach is quite straightforward: sort the numbers in descending order and pick the $$k$$-th element.</p>
<h5>Key Data Structures:</h5>
<ul>
<li><strong>List/Array</strong>: We use Python's built-in list for this approach. The list is sorted in descending order to get the $$k$$-th largest element.</li>
</ul>
<h5>Step-by-step Breakdown:</h5>
<ol>
<li><strong>Initialization</strong>:</li>
<li>
<p>Use built-in <code>sorted</code> function to sort the list <code>nums</code> in reverse order (i.e., in descending order).</p>
</li>
<li>
<p><strong>Selection</strong>:</p>
</li>
<li>
<p>Select the $$k$$-th element from the sorted list (keeping in mind the zero-based indexing of lists).</p>
</li>
<li>
<p><strong>Result</strong>:</p>
</li>
<li>The $$k$$-th element in the sorted list is the $$k$$-th largest element in the original list.</li>
</ol>
<h4>Complexity:</h4>
<p><strong>Time Complexity:</strong> $$O(N \log N)$$
- Sorting a list of $$N$$ elements requires $$O(N \log N)$$ time.</p>
<p><strong>Space Complexity:</strong> $$O(1)$$
- The space used is constant since we are only sorting the original list and selecting an element from it without utilizing any additional data structures.</p>
<h4>Performance:</h4>
<p>This solution is simple and works effectively for smaller lists. However, for very large lists, other approaches that avoid sorting the entire list might be more efficient.</p>
<p>| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |
|------------|--------------|------------------|-------------|-----------------|
| <strong>Java</strong>       | 22           | 88.35%           | 54.2        | 79.52%          |
| <strong>Rust</strong>       | 25           | 21.43%           | 3.4         | 5.61%           |
| <strong>cpp</strong>        | 74           | 96.10%           | 45.6        | 74.16%          |
| <strong>Go</strong>         | 101          | 51.2%            | 7.9         | 85.3%           |
| <strong>JavaScript</strong> | 143          | 60.17%           | 51.5        | 56.57%          |
| <strong>C#</strong>         | 164          | 85.88%           | 51.1        | 41.99%          |
| <strong>Python3</strong>    | 410          | 98.33%           | 29.5        | 72.41%          |</p>
<h4>Code 1/3</h4>
<pre><code class="language-Python">class Solution:
    def findKthLargest(self, nums, k):
        return sorted(nums, reverse=True)[k-1]
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(std::vector&lt;int&gt;&amp; nums, int k) {
        std::sort(nums.begin(), nums.end(), std::greater&lt;int&gt;());
        return nums[k-1];
    }
};
</code></pre>
<pre><code class="language-Java">public class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }
}
</code></pre>
<pre><code class="language-Rust">impl Solution {
    pub fn find_kth_largest(nums: Vec&lt;i32&gt;, k: i32) -&gt; i32 {
        let mut sorted_nums = nums.clone();
        sorted_nums.sort();
        sorted_nums[(nums.len() - k as usize)]
    }
}
</code></pre>
<pre><code class="language-Go">import &quot;sort&quot;

func findKthLargest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[len(nums)-k]
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    nums.sort((a, b) =&gt; b - a);
    return nums[k-1];
};
</code></pre>
<pre><code class="language-C####">public class Solution {
    public int FindKthLargest(int[] nums, int k) {
        Array.Sort(nums);
        return nums[nums.Length - k];
    }
}
</code></pre>
<h4>Approach 2/3: Min-Heap</h4>
<p>The main idea of this solution is to use a min-heap with a maximum size of <code>k</code>. By doing this, we ensure that the smallest of the <code>k</code> largest elements is always on the top of the heap.</p>
<h5>Key Data Structures:</h5>
<ul>
<li><strong><code>heap</code></strong>:
  This is a min-heap containing the first <code>k</code> elements of <code>nums</code>. As we progress, we will modify this heap to ensure it contains the <code>k</code> largest elements.</li>
</ul>
<h6>Step-by-step Breakdown:</h6>
<ol>
<li><strong>Initialization</strong>:</li>
<li>Create a heap with the first <code>k</code> elements of <code>nums</code>.</li>
<li>
<p>Transform this list into a min-heap.</p>
</li>
<li>
<p><strong>Iterate through the List</strong>:</p>
</li>
<li>
<p>For each of the remaining elements in <code>nums</code>:</p>
<ul>
<li>If the element is larger than the smallest element in the heap (i.e., the top of the heap):</li>
<li>Remove the top element from the heap.</li>
<li>Insert the current element into the heap.</li>
</ul>
</li>
<li>
<p><strong>Result</strong>:</p>
</li>
<li>After processing all elements in <code>nums</code>, the top of the heap will contain the <code>k</code>th largest element. Return this element.</li>
</ol>
<h4>Example:</h4>
<p>Consider the list <code>nums = [3,2,1,5,6,4]</code> with <code>k = 2</code>.</p>
<p>Here's the evolution of the <code>heap</code>:</p>
<p><strong>Initial State</strong>:
- <code>heap</code>: [3,2]</p>
<p><strong>After processing index 2 (element = 1)</strong>:
- <code>heap</code> remains unchanged as <code>1</code> is not larger than <code>2</code>.</p>
<p><strong>After processing index 3 (element = 5)</strong>:
- <code>heap</code>: [3,5]</p>
<p><strong>After processing index 4 (element = 6)</strong>:
- <code>heap</code>: [5,6]</p>
<p><strong>After processing index 5 (element = 4)</strong>:
- <code>heap</code>: [5,6]</p>
<p>The final state of the <code>heap</code> shows that the <code>k</code>th largest element is <code>5</code>.</p>
<h4>Complexity</h4>
<p><strong>Time Complexity:</strong> $$O(n \log k)$$
Each of the <code>n</code> elements is processed once. However, heap operations take $$O(\log k)$$ time, leading to an overall complexity of $$O(n \log k)$$.</p>
<p><strong>Space Complexity:</strong> $$O(k)$$
The solution uses a heap with a maximum of <code>k</code> elements.</p>
<h4>Performance</h4>
<p>This solution is both time and space-efficient. By focusing only on the <code>k</code> largest elements and using the properties of a heap, it ensures optimal runtime for a wide range of inputs. The controlled space usage ensures that even for large <code>k</code>, the memory overhead remains minimal.</p>
<p>| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |
|------------|--------------|------------------|-------------|-----------------|
| <strong>Rust</strong>       | 13           | 77.55%           | 3.1         | 46.94%          |
| <strong>Java</strong>       | 37           | 59.27%           | 54.1        | 86.2%           |
| <strong>cpp</strong>        | 76           | 94.84%           | 46.5        | 68.16%          |
| <strong>Go</strong>         | 91           | 62.6%            | 8.6         | 30.67%          |
| <strong>JavaScript</strong> | 98           | 87.2%            | 51.7        | 47.64%          |
| <strong>C#</strong>         | 152          | 95.49%           | 51.7        | 16.25%          |
| <strong>Python3</strong>    | 407          | 98.75%           | 29.5        | 72.41%          |</p>
<h4>Code</h4>
<pre><code class="language-Python">class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:
        heap = nums[:k]
        heapq.heapify(heap)

        for num in nums[k:]:
            if num &gt; heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, num)

        return heap[0]
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(std::vector&lt;int&gt;&amp; nums, int k) {
        std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; min_heap(nums.begin(), nums.begin() + k);

        for (int i = k; i &lt; nums.size(); i++) {
            if (nums[i] &gt; min_heap.top()) {
                min_heap.pop();
                min_heap.push(nums[i]);
            }
        }

        return min_heap.top();
    }
};
</code></pre>
<pre><code class="language-Rust">use std::collections::BinaryHeap;
use std::cmp::Reverse;

impl Solution {
    pub fn find_kth_largest(nums: Vec&lt;i32&gt;, k: i32) -&gt; i32 {
        let mut heap: BinaryHeap&lt;Reverse&lt;i32&gt;&gt; = nums.iter().take(k as usize).map(|&amp;x| Reverse(x)).collect();

        for &amp;num in nums.iter().skip(k as usize) {
            if num &gt; heap.peek().unwrap().0 {
                heap.pop();
                heap.push(Reverse(num));
            }
        }

        heap.peek().unwrap().0
    }
}
</code></pre>
<pre><code class="language-Go">import &quot;container/heap&quot;

func findKthLargest(nums []int, k int) int {
    h := IntHeap(nums[:k])
    heap.Init(&amp;h)

    for _, num := range nums[k:] {
        if num &gt; h[0] {
            heap.Pop(&amp;h)
            heap.Push(&amp;h, num)
        }
    }

    return h[0]
}

type IntHeap []int

func (h IntHeap) Len() int { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] }
func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
</code></pre>
<pre><code class="language-Java">public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
        for (int i = 0; i &lt; k; i++) {
            minHeap.offer(nums[i]);
        }

        for (int i = k; i &lt; nums.length; i++) {
            if (nums[i] &gt; minHeap.peek()) {
                minHeap.poll();
                minHeap.offer(nums[i]);
            }
        }

        return minHeap.peek();
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
 class MinHeap {
    constructor() {
        this.heap = [];
    }
    push(val) {
        this.heap.push(val);
        this.bubbleUp();
    }
    pop() {
        const max = this.heap[0];
        const end = this.heap.pop();
        if (this.heap.length &gt; 0) {
            this.heap[0] = end;
            this.bubbleDown();
        }
        return max;
    }
    peek() {
        return this.heap[0];
    }
    bubbleUp() {
        let idx = this.heap.length - 1;
        const element = this.heap[idx];
        while (idx &gt; 0) {
            let parentIdx = Math.floor((idx - 1) / 2);
            let parent = this.heap[parentIdx];
            if (element &gt;= parent) break;
            this.heap[parentIdx] = element;
            this.heap[idx] = parent;
            idx = parentIdx;
        }
    }
    bubbleDown() {
        let idx = 0;
        const length = this.heap.length;
        const element = this.heap[0];
        while (true) {
            let leftChildIdx = 2 * idx + 1;
            let rightChildIdx = 2 * idx + 2;
            let leftChild, rightChild;
            let swap = null;
            if (leftChildIdx &lt; length) {
                leftChild = this.heap[leftChildIdx];
                if (leftChild &lt; element) {
                    swap = leftChildIdx;
                }
            }
            if (rightChildIdx &lt; length) {
                rightChild = this.heap[rightChildIdx];
                if (
                    (swap === null &amp;&amp; rightChild &lt; element) || 
                    (swap !== null &amp;&amp; rightChild &lt; leftChild)
                ) {
                    swap = rightChildIdx;
                }
            }
            if (swap === null) break;
            this.heap[idx] = this.heap[swap];
            this.heap[swap] = element;
            idx = swap;
        }
    }
}
var findKthLargest = function(nums, k) {
    let heap = new MinHeap();
    for (let i = 0; i &lt; k; i++) {
        heap.push(nums[i]);
    }
    for (let i = k; i &lt; nums.length; i++) {
        if (nums[i] &gt; heap.peek()) {
            heap.pop();
            heap.push(nums[i]);
        }
    }
    return heap.peek();
};
</code></pre>
<pre><code class="language-C####">public class Solution {
    public int FindKthLargest(int[] nums, int k) {
        MinHeap minHeap = new MinHeap(k);
        for (int i = 0; i &lt; k; i++) {
            minHeap.Insert(nums[i]);
        }

        for (int i = k; i &lt; nums.Length; i++) {
            if (nums[i] &gt; minHeap.Peek()) {
                minHeap.Pop();
                minHeap.Insert(nums[i]);
            }
        }

        return minHeap.Peek();
    }
}

public class MinHeap {
    private int[] heap;
    private int size;

    public MinHeap(int capacity) {
        heap = new int[capacity];
        size = 0;
    }

    public void Insert(int val) {
        heap[size] = val;
        size++;
        BubbleUp();
    }

    public int Peek() {
        return heap[0];
    }

    public int Pop() {
        int poppedValue = heap[0];
        heap[0] = heap[size - 1];
        size--;
        BubbleDown();
        return poppedValue;
    }

    private void BubbleUp() {
        int index = size - 1;
        while (index &gt; 0 &amp;&amp; heap[index] &lt; heap[Parent(index)]) {
            Swap(index, Parent(index));
            index = Parent(index);
        }
    }

    private void BubbleDown() {
        int index = 0;
        while (HasLeftChild(index) &amp;&amp; (heap[index] &gt; LeftChild(index) || HasRightChild(index) &amp;&amp; heap[index] &gt; RightChild(index))) {
            int smallerChildIndex = LeftChildIndex(index);
            if (HasRightChild(index) &amp;&amp; RightChild(index) &lt; LeftChild(index)) {
                smallerChildIndex = RightChildIndex(index);
            }
            Swap(index, smallerChildIndex);
            index = smallerChildIndex;
        }
    }

    private int Parent(int index) { return (index - 1) / 2; }
    private int LeftChildIndex(int index) { return 2 * index + 1; }
    private int RightChildIndex(int index) { return 2 * index + 2; }

    private bool HasLeftChild(int index) { return LeftChildIndex(index) &lt; size; }
    private bool HasRightChild(int index) { return RightChildIndex(index) &lt; size; }

    private int LeftChild(int index) { return heap[LeftChildIndex(index)]; }
    private int RightChild(int index) { return heap[RightChildIndex(index)]; }

    private void Swap(int indexOne, int indexTwo) {
        int temp = heap[indexOne];
        heap[indexOne] = heap[indexTwo];
        heap[indexTwo] = temp;
    }
}
</code></pre>
<h4>Approach 3/3: QuickSelect Algorithm</h4>
<p>The QuickSelect algorithm is an efficient method to find the $$k$$-th smallest (or largest) element in an unordered list without sorting the entire list. It works similarly to the QuickSort algorithm but only recurses into one half of the data.</p>
<h5>Key Data Structures:</h5>
<ul>
<li><strong>List/Array</strong>: We use Python's built-in list for this approach. The algorithm modifies the list in place.</li>
<li><strong>Pivot</strong>: An element chosen from the list, around which the list gets partitioned.</li>
</ul>
<h5>Step-by-step Breakdown:</h5>
<ol>
<li><strong>Initialization</strong>:</li>
<li>
<p>Set the <code>left</code> boundary to the beginning of the list and the <code>right</code> boundary to the end of the list.</p>
</li>
<li>
<p><strong>Pivot Selection</strong>:</p>
</li>
<li>
<p>Randomly select a pivot index between the <code>left</code> and <code>right</code> boundaries.</p>
</li>
<li>
<p><strong>Partitioning</strong>:</p>
</li>
<li>Move all elements smaller than the pivot to its left and all larger elements to its right.</li>
<li>
<p>Return the final position of the pivot after the partitioning.</p>
</li>
<li>
<p><strong>Check Pivot Position</strong>:</p>
</li>
<li>If the position of the pivot is the desired $$k$$-th largest index, return the pivot.</li>
<li>If the pivot's position is greater than the desired index, adjust the <code>right</code> boundary and repeat.</li>
<li>
<p>If the pivot's position is lesser than the desired index, adjust the <code>left</code> boundary and repeat.</p>
</li>
<li>
<p><strong>Result</strong>:</p>
</li>
<li>The function will eventually return the $$k$$-th largest element in the original list.</li>
</ol>
<h4>Example:</h4>
<p>Let's walk through the QuickSelect algorithm using the list <code>nums = [3,2,1,5,6,4]</code> and ( k = 2 ) to find the 2nd largest element.</p>
<p><strong>Initial List:</strong> 
<code>[3,2,1,5,6,4]</code></p>
<ol>
<li><strong>Iteration 1:</strong> </li>
<li>Chosen pivot: <code>3</code> (at index 0)</li>
<li>After partitioning, the list becomes: <code>[2, 1, 3, 5, 6, 4]</code></li>
<li>
<p>The new pivot index is 2. Since we're looking for the 2nd largest element (index 4 in 0-indexed list), and the current pivot index is less than this, we know the desired element is to the right of the current pivot.</p>
</li>
<li>
<p><strong>Iteration 2:</strong></p>
</li>
<li>Chosen pivot: <code>6</code> (at index 4)</li>
<li>After partitioning, the list becomes: <code>[2, 1, 3, 4, 5, 6]</code></li>
<li>The new pivot index is 4, which matches our target index for the 2nd largest element.</li>
</ol>
<p><strong>Result:</strong> 
The 2nd largest element in the list is <code>5</code>.</p>
<p>This example demonstrates the behavior of the QuickSelect algorithm. By iteratively selecting a pivot and partitioning the list around that pivot, it efficiently narrows down the search space until it locates the kth largest element.</p>
<h4>Complexity:</h4>
<p><strong>Time Complexity</strong>: 
- Best and Average Case: $$O(N)$$
- Worst Case: $$O(N^2)$$</p>
<p>The average performance is linear. However, in the worst case (very rare, especially with randomized pivot), the algorithm can degrade to $$O(N^2)$$.</p>
<p><strong>Space Complexity</strong>: $$O(1)$$
- The space used is constant. The algorithm modifies the original list in place and doesn't utilize any significant additional data structures. The recursive stack calls (in the worst case) are also bounded by the depth of the list, making it $$O(\log N)$$, but this is typically considered as $$O(1)$$ space complexity in QuickSelect.</p>
<h4>Performance:</h4>
<p>This solution is efficient for larger lists, especially when the pivot is chosen randomly, which greatly reduces the chance of the worst-case scenario. The QuickSelect algorithm allows for finding the desired element without sorting the entire list, making it faster than the sorting approach for large datasets.</p>
<p>| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |
|------------|--------------|------------------|-------------|-----------------|
| <strong>Java</strong>       | 4            | 97.78%           | 54.2        | 79.52%          |
| <strong>Rust</strong>       | 12           | 83.16%           | 3.4         | 5.61%           |
| <strong>Go</strong>         | 56           | 100%             | 8.3         | 46.37%          |
| <strong>cpp</strong>        | 63           | 98.85%           | 45.5        | 86.52%          |
| <strong>JavaScript</strong> | 80           | 94.94%           | 51.8        | 38.99%          |
| <strong>C#</strong>         | 146          | 98.46%           | 50.6        | 90.98%          |
| <strong>Python3</strong>    | 427          | 94.80%           | 29.6        | 55.40%          |</p>
<h4>Code 3/3</h4>
<pre><code class="language-Python">class Solution:
    def findKthLargest(self, nums, k):
        left, right = 0, len(nums) - 1
        while True:
            pivot_index = random.randint(left, right)
            new_pivot_index = self.partition(nums, left, right, pivot_index)
            if new_pivot_index == len(nums) - k:
                return nums[new_pivot_index]
            elif new_pivot_index &gt; len(nums) - k:
                right = new_pivot_index - 1
            else:
                left = new_pivot_index + 1

    def partition(self, nums, left, right, pivot_index):
        pivot = nums[pivot_index]
        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]
        stored_index = left
        for i in range(left, right):
            if nums[i] &lt; pivot:
                nums[i], nums[stored_index] = nums[stored_index], nums[i]
                stored_index += 1
        nums[right], nums[stored_index] = nums[stored_index], nums[right]
        return stored_index
</code></pre>
<pre><code class="language-cpp">class Solution {
public:
    int findKthLargest(std::vector&lt;int&gt;&amp; nums, int k) {
        int left = 0, right = nums.size() - 1;
        while (true) {
            int pivot_index = rand() % (right - left + 1) + left;
            int new_pivot_index = partition(nums, left, right, pivot_index);
            if (new_pivot_index == nums.size() - k) {
                return nums[new_pivot_index];
            } else if (new_pivot_index &gt; nums.size() - k) {
                right = new_pivot_index - 1;
            } else {
                left = new_pivot_index + 1;
            }
        }
    }

private:
    int partition(std::vector&lt;int&gt;&amp; nums, int left, int right, int pivot_index) {
        int pivot = nums[pivot_index];
        std::swap(nums[pivot_index], nums[right]);
        int stored_index = left;
        for (int i = left; i &lt; right; i++) {
            if (nums[i] &lt; pivot) {
                std::swap(nums[i], nums[stored_index]);
                stored_index++;
            }
        }
        std::swap(nums[right], nums[stored_index]);
        return stored_index;
    }
};
</code></pre>
<pre><code class="language-Rust">use rand::Rng;

impl Solution {
    pub fn find_kth_largest(nums: Vec&lt;i32&gt;, k: i32) -&gt; i32 {
        let mut nums = nums;
        let mut left = 0;
        let mut right = nums.len() - 1;
        let mut rng = rand::thread_rng();
        loop {
            let pivot_index = rng.gen_range(left, right + 1);
            let new_pivot_index = Self::partition(&amp;mut nums, left, right, pivot_index);
            if new_pivot_index == nums.len() - k as usize {
                return nums[new_pivot_index];
            } else if new_pivot_index &gt; nums.len() - k as usize {
                right = new_pivot_index - 1;
            } else {
                left = new_pivot_index + 1;
            }
        }
    }

    fn partition(nums: &amp;mut Vec&lt;i32&gt;, left: usize, right: usize, pivot_index: usize) -&gt; usize {
        let pivot = nums[pivot_index];
        nums.swap(pivot_index, right);
        let mut stored_index = left;
        for i in left..right {
            if nums[i] &lt; pivot {
                nums.swap(i, stored_index);
                stored_index += 1;
            }
        }
        nums.swap(right, stored_index);
        stored_index
    }
}
</code></pre>
<pre><code class="language-Go">import (
    &quot;math/rand&quot;
)

func findKthLargest(nums []int, k int) int {
    left, right := 0, len(nums)-1
    for {
        pivotIndex := left + rand.Intn(right-left+1)
        newPivotIndex := partition(nums, left, right, pivotIndex)
        if newPivotIndex == len(nums)-k {
            return nums[newPivotIndex]
        } else if newPivotIndex &gt; len(nums)-k {
            right = newPivotIndex - 1
        } else {
            left = newPivotIndex + 1
        }
    }
}

func partition(nums []int, left int, right int, pivotIndex int) int {
    pivot := nums[pivotIndex]
    nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]
    storedIndex := left
    for i := left; i &lt; right; i++ {
        if nums[i] &lt; pivot {
            nums[i], nums[storedIndex] = nums[storedIndex], nums[i]
            storedIndex++
        }
    }
    nums[right], nums[storedIndex] = nums[storedIndex], nums[right]
    return storedIndex
}
</code></pre>
<pre><code class="language-Java">public class Solution {
    public int findKthLargest(int[] nums, int k) {
        int left = 0, right = nums.length - 1;
        Random rand = new Random();
        while (true) {
            int pivot_index = left + rand.nextInt(right - left + 1);
            int new_pivot_index = partition(nums, left, right, pivot_index);
            if (new_pivot_index == nums.length - k) {
                return nums[new_pivot_index];
            } else if (new_pivot_index &gt; nums.length - k) {
                right = new_pivot_index - 1;
            } else {
                left = new_pivot_index + 1;
            }
        }
    }

    private int partition(int[] nums, int left, int right, int pivot_index) {
        int pivot = nums[pivot_index];
        swap(nums, pivot_index, right);
        int stored_index = left;
        for (int i = left; i &lt; right; i++) {
            if (nums[i] &lt; pivot) {
                swap(nums, i, stored_index);
                stored_index++;
            }
        }
        swap(nums, right, stored_index);
        return stored_index;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
<pre><code class="language-JavaScript">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    const partition = (left, right, pivotIndex) =&gt; {
        const pivot = nums[pivotIndex];
        [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]];
        let storedIndex = left;
        for (let i = left; i &lt; right; i++) {
            if (nums[i] &lt; pivot) {
                [nums[storedIndex], nums[i]] = [nums[i], nums[storedIndex]];
                storedIndex++;
            }
        }
        [nums[right], nums[storedIndex]] = [nums[storedIndex], nums[right]];
        return storedIndex;
    };

    let left = 0, right = nums.length - 1;
    while (true) {
        const pivotIndex = left + Math.floor(Math.random() * (right - left + 1));
        const newPivotIndex = partition(left, right, pivotIndex);
        if (newPivotIndex === nums.length - k) {
            return nums[newPivotIndex];
        } else if (newPivotIndex &gt; nums.length - k) {
            right = newPivotIndex - 1;
        } else {
            left = newPivotIndex + 1;
        }
    }
};
</code></pre>
<pre><code class="language-C####">public class Solution {
    public int FindKthLargest(int[] nums, int k) {
        int left = 0, right = nums.Length - 1;
        Random rand = new Random();
        while (true) {
            int pivot_index = left + rand.Next(right - left + 1);
            int new_pivot_index = Partition(nums, left, right, pivot_index);
            if (new_pivot_index == nums.Length - k) {
                return nums[new_pivot_index];
            } else if (new_pivot_index &gt; nums.Length - k) {
                right = new_pivot_index - 1;
            } else {
                left = new_pivot_index + 1;
            }
        }
    }

    private int Partition(int[] nums, int left, int right, int pivot_index) {
        int pivot = nums[pivot_index];
        Swap(nums, pivot_index, right);
        int stored_index = left;
        for (int i = left; i &lt; right; i++) {
            if (nums[i] &lt; pivot) {
                Swap(nums, i, stored_index);
                stored_index++;
            }
        }
        Swap(nums, right, stored_index);
        return stored_index;
    }

    private void Swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
<p>In the dynamic world of algorithms, there's no 'one-size-fits-all'. Each solution we've explored offers unique strengths and comes with its own set of trade-offs. Some shine brightest with smaller inputs, while others stand resilient in the face of massive datasets. The beauty lies in understanding and judiciously applying them based on the constraints and requirements at hand.</p>
<p>Remember, every challenge you face is an opportunity to apply and expand your understanding. By mastering multiple approaches, you not only diversify your algorithmic toolbox but also enhance your adaptability in solving real-world problems. Keep pushing the boundaries, keep exploring, and most importantly, keep coding! The journey of algorithms is vast and rewarding, and every problem you solve is a stepping stone towards becoming a more skilled and confident coder. Embrace the learning, and let the world of algorithms inspire and empower you!</p></div>