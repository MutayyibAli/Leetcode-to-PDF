<div class='cpp-solution'><h4>C++ || Easiest Solution Using Priority Queue || With Explanation [Votes: 82]</h4><h4>Intuition</h4>
<p>The idea is to consider for each element of array of nums2[i] as minimum once and check for maximum possible values available in nums1 keeping in mind nums2[i] as minimum .</p>
<h4>Approach</h4>
<ul>
<li>
<p>First we sort the nums2 array in decreasing order and as we need to know the mapping of nums2[i] to nums1[i]  so for that we make their pairs and then we sort.</p>
</li>
<li>
<p>Now we we will iterate through p array one by one and let p[i].first as the minimum for an instance then all the elements to left of p array can be considered for sum part.</p>
</li>
<li>
<p>But we can make priority queue for knowing top k elements to left of p array </p>
</li>
<li>
<p>And we will only keep k maximum elements at a time in priority queue and keep the tab of their sum .</p>
</li>
<li>
<p>Now please read the code and you will understand it . Upvotes are appreciated  </p>
</li>
</ul>
<h4>Complexity</h4>
<ul>
<li>
<p>Time complexity: O( N * Log(N) + (N-k) * Log(k) )</p>
</li>
<li>
<p>Space complexity: O(N) + O(k) = O(N+K)</p>
</li>
</ul>
<h4>Code</h4>
<pre><code>class Solution {
    public:
    long long maxScore(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) {

       vector&lt;pair&lt;int, int&gt;&gt; p ;

        for(int i = 0 ; i&lt;nums1.size() ; i++)
        {
            p.push_back({nums2[i] , nums1[i]});
        }

        sort(p.rbegin() , p.rend());

        long long ans  = 0;
        long long sum  = 0;
        priority_queue&lt;int&gt; pq;
        for(int i = 0 ; i&lt;k-1 ; i++)
        {
            sum += p[i].second;
            pq.push(-p[i].second);
        }

        for(int i = k-1 ; i&lt;nums1.size() ; i++)
        {

            sum += p[i].second;
            pq.push(-p[i].second);

            ans = max(ans, sum * p[i].first );

            sum += pq.top();
            pq.pop();
        }

        return ans;


    }
};
</code></pre></div><div class='python-solution'><h4>[Java/C++/Python] Priority Queue [Votes: 196]</h4><h4><strong>Intuition</strong></h4>
<p>Almost exactly same as
<a href="https://leetcode.com/problems/maximum-performance-of-a-team/discuss/539687/JavaC%2B%2BPython-Priority-Queue">1383. Maximum Performance of a Team</a>.
<br></p>
<h4><strong>Explanation</strong></h4>
<p>We iterate all pairs <code>(A[i], B[i])</code> with <code>B[i]</code> from big to small,
We keep the priority queue with maximum size of <code>k</code>.
Each time when we introduce a new pair of <code>(A[i], B[i])</code>,
the current minimum value on B is <code>B[i]</code>
the current sum value on A is <code>sum(priority queue)</code></p>
<p>If the size of queue &gt; k,
we pop the minimum <code>A[i]</code>.
also update total <code>sum -= A[i]</code></p>
<p>If the size of queue == k,
we update <code>res = res = max(res, sum * B[i])</code>
<br></p>
<h4><strong>Complexity</strong></h4>
<p>Time <code>O(nlogn)</code>
Space <code>O(n)</code>
<br></p>
<p><strong>Java</strong></p>
<pre><code class="language-java">    public long maxScore(int[] speed, int[] efficiency, int k) {
        int n = speed.length;
        int[][] ess = new int[n][2];
        for (int i = 0; i &lt; n; ++i)
            ess[i] = new int[] {efficiency[i], speed[i]};
        Arrays.sort(ess, (a, b) -&gt; b[0] - a[0]);
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);
        long res = 0, sumS = 0;
        for (int[] es : ess) {
            pq.add(es[1]);
            sumS = (sumS + es[1]);
            if (pq.size() &gt; k) sumS -= pq.poll();
            if (pq.size() == k) res = Math.max(res, (sumS * es[0]));
        }
        return res;
    }
</code></pre>
<p><strong>cpp</strong></p>
<pre><code class="language-cpp">    long long maxScore(vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {
        int n = speed.size();
        vector&lt;pair&lt;int, int&gt;&gt; ess(n);
        for (int i = 0; i &lt; n; ++i)
            ess[i] = {efficiency[i], speed[i]};
        sort(rbegin(ess), rend(ess));
        long long sumS = 0, res = 0;
        priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; //min heap
        for (auto&amp; [e, s] : ess) {
            pq.emplace(s);
            sumS += s;
            if (pq.size() &gt; k) {
                sumS -= pq.top();
                pq.pop();
            }
            if (pq.size() == k)
                res = max(res, sumS * e);
        }
        return res;
    }
</code></pre>
<p><strong>Python</strong></p>
<pre><code class="language-py">    def maxScore(self, A, B, k):
        total = res = 0
        h = []
        for a,b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]):
            heappush(h, a)
            total += a
            if len(h) &gt; k:
                total -= heappop(h)
            if len(h) == k:
                res = max(res, total * b)
        return res
</code></pre></div>