<div class='cpp-solution'><h4>âœ… C++ || EASY || DETAILED EXPLAINATION || OPTIMIZED [Votes: 504]</h4><p><strong>PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT **
</strong>Time<strong> and </strong>Space** Complexity =&gt; <code>O(n)</code>, where n is the size of nums</p>
<pre><code>class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int,int&gt; mp;
        int n = nums.size();

        for(int i=0; i&lt;n; i++)
        {
            // mp.count() will tell whatever ith index that I want, have I seen it before?
            if(mp.count(nums[i]))
            {
                // if I have already seen this number, then check for condition abs(i - j) &lt;= k
                if(abs(i-mp[nums[i]])&lt;=k)
                    return true;
            }
            // if I have not seen this number before, insert the number with its position in the map
            // and if the number is already present in the map, then update the position of that number
            mp[nums[i]] = i;
        }
        // after the complete traversal, if we don't find a pair to satisfy the condition, return false
        return false;
    }
};
</code></pre></div><div class='python-solution'><h4>Python concise solution with dictionary. [Votes: 366]</h4><pre><code>    
def containsNearbyDuplicate(self, nums, k):
    dic = {}
    for i, v in enumerate(nums):
        if v in dic and i - dic[v] &lt;= k:
            return True
        dic[v] = i
    return False
</code></pre></div>