<div class='cpp-solution'><h4>Simple C++ Solution || Fully Explained at begineers level || Easy Understanding of UNION concept [Votes: 109]</h4><p><strong>TOPIC: UNION FIND
   NOT A BIG TASK :), JUST GO LINE BY LINE</strong> </p>
<pre><code>   In union we just make any element leader of any group and make other elements as a group member.
</code></pre>
<p><strong>Let's say 1 and 2 are friend , and 2 and 3 are also friend 
Then indirectly 1 and 3 are also friends. We can say that 1,2,3 are in same group.</strong></p>
<p>How we will deal with it in UNION:</p>
<p>WE have given <strong>n * n matrix</strong> , then <strong>maximum number of group will be n</strong>, if nobody is friend of none.</p>
<p>Lets Say n=5
Now we mark all of them initially with -1, because at starting all are alone, all are self leader.
<strong>At the end we will find -1 for those index which will be leader of any group</strong></p>
<p>_INDEX :     <strong>[ 1 ,  2 ,3 ,4 ,   5]</strong>
VALUES: <strong>[-1,-1,-1,-1,-1]</strong></p>
<p>Now <strong>1 is friend of 2</strong>, mark <strong>2</strong> as a leader , how can we do this, simple ,<strong>point index 2 from 1</strong>
 _INDEX :     <strong>[ 1 ,  2 ,3 ,4 ,   5]</strong>
VALUES: <strong>[  2,-1,-1,-1, -1]</strong>
Here how we will find leader ,start from index 1</p>
<p><strong>1 is pointing 2 , 1-&gt;2
2 is pointing -1, 2 is leader of group</strong></p>
<p>Now <strong>2 is friend of 3</strong>, Now <strong>point 2 at index 3</strong>
 _INDEX :     <strong>[ 1 ,  2 ,3 ,4 ,   5]</strong>
VALUES: <strong>[  2 , 3,-1,-1, -1]</strong></p>
<p><strong>1 is pointing 2 , 1-&gt;2
2 is pointing 3 , 2-&gt;3
3 is pointing -1 , 3 is leader of group</strong></p>
<p>Now if we start finding <strong>leader of 1 and 2</strong> , then <strong>3</strong> is the leader (<strong>COMMON LEADER: SAME GROUP</strong>)</p>
<p>Now <strong>4 is friend of 5</strong>, Now <strong>point 4 at index 5</strong>
 _INDEX :     <strong>[ 1 ,  2 ,3 ,4 ,   5]</strong>
VALUES: <strong>[  2 , 3,-1, 5, -1]</strong></p>
<p>At the end just count total number of parent nodes whose value is -1.
Now we have <strong>two</strong> groups <strong>{1,2,3}</strong> and <strong>{4,5}</strong> , NOW go to solution line by line :)</p>
<pre><code>class Solution {
public:

    //It will be use to store groups
    vector&lt;int&gt; v;

    //Find the leader of any group in which x lies
    //if not lie in any group then it is self leader
    int parent(int x)
    {
        //self leader
        if(v[x]==-1) return x; 
        //find the leader of self parent
        return v[x]=parent(v[x]);
    }

    //Adding 2 friends in a group
    void _union(int a,int b)
    {
        //find the leader of both a and b
        int p_a=parent(a),p_b=parent(b);

        //if already in same group, i.e leader of both of them are same then return
        if(p_a==p_b) return; 
        /*
         if both of them are from different group then add both the groups 
         and make a single common group
         We can do this by -&gt; leader of 1st group is member of 2nd group 
         and now main leader of whole group is leader of 2nd member
        */ 
        v[p_a]=p_b; //v[p_a] will store the index of leader of whole group
    }

    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) { 
        int n=M.size();
        v=vector&lt;int&gt; (n,-1);//there will be maximum n group, mark all as a leader

        //making group
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;n;j++)
            {
                if(M[i][j])  //if i is friend of j, add them in a group
                { 
                    //if i is in any group then add j in that group
                    //or vice-versa
                    _union(i,j);  //Add them in a group
                }
            }
        }
        int c=0; 

        //counting group
        for(int i=0;i&lt;n;i++)
        {
            if(v[i]==-1) c++; //counting total number of parents
        }
        return c; 
    }
};
</code></pre>
<p><strong><em>Time Complexity: O(N * N * log(N))
Space Complexity: O(N)</em></strong>  </p>
<p><strong>We are traversing N * N size matrix and finding parent each time in vector  of size N
Using a vector to store parent of size N</strong></p></div><div class='python-solution'><h4>python, union find, dfs, bfs [Votes: 68]</h4><p>union find:</p>
<pre><code class="language-py">class UnionFind(object):
    def __init__(self, n):
        self.u = list(range(n))

    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra != rb: self.u[ra] = rb

    def find(self, a):
        while self.u[a] != a: a = self.u[a]
        return a

class Solution(object):
    def findCircleNum(self, M):
        &quot;&quot;&quot;
        :type M: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;

        if not M: return 0
        s = len(M)

        uf = UnionFind(s)
        for r in range(s):
            for c in range(r,s):
                if M[r][c] == 1: uf.union(r,c)

        return len(set([uf.find(i) for i in range(s)]))
</code></pre>
<p>DFS:</p>
<pre><code class="language-py">class Solution(object):
    def findCircleNum(self, M):
        &quot;&quot;&quot;
        :type M: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;

        if not M: return 0
        s = len(M)
        seen = set()

        def dfs(p):
            for q, adj in enumerate(M[p]):
                if (adj == 1) and (q not in seen):
                    seen.add(q)
                    dfs(q)

        cnt = 0
        for i in range(s):
            if i not in seen: 
                dfs(i)
                cnt += 1

        return cnt
</code></pre>
<p>BFS:</p>
<pre><code class="language-py">class Solution(object):
    def findCircleNum(self, M):
        &quot;&quot;&quot;
        :type M: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;

        if not M: return 0
        s = len(M)
        seen = set()
        cnt = 0
        for i in range(s):
            if i not in seen:
                q = [i]
                while q:
                    p = q.pop(0)
                    if p not in seen:
                        seen.add(p)
                        q += [k for k,adj in enumerate(M[p]) if adj and (k not in seen)]
                cnt += 1

        return cnt
</code></pre></div>