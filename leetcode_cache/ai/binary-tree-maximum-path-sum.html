<div class='ai-explanation'><h3>List of all the approaches to solution</h3>
<ol>
<li>Brute Force Approach</li>
<li>Recursive DFS Approach (Optimal)</li>
</ol>
<hr />
<h3>Brute Force Approach</h3>
<h4>Explanation</h4>
<p>The brute-force idea is to consider every node in the tree as the "pivot" or the highest point of a potential maximum path. For each node <code>u</code>, we can calculate the maximum path sum that can be formed with <code>u</code> as the root of that path. This path consists of <code>u</code>'s value, plus the best possible path extending downwards into its left subtree, plus the best possible path extending downwards into its right subtree.</p>
<p>To implement this, we can:
1.  Traverse every node <code>u</code> in the tree.
2.  For each node <code>u</code>, calculate the maximum path sum starting from <code>u</code> and going down into its left subtree. Let's call a helper function <code>maxPathDown(node)</code> for this.
3.  Similarly, calculate the maximum path sum starting from <code>u</code> and going down into its right subtree using <code>maxPathDown(node)</code>.
4.  The potential maximum path pivoting at <code>u</code> is <code>u-&gt;val + max(0, maxPathDown(u-&gt;left)) + max(0, maxPathDown(u-&gt;right))</code>. We take <code>max</code> with 0 to ignore negative sub-path sums.
5.  Keep track of the overall maximum found across all nodes.</p>
<p>The <code>maxPathDown(node)</code> function would itself be recursive and traverse the entire subtree of <code>node</code>. Because we call this function repeatedly for subtrees we've already visited, this approach leads to significant re-computation.</p>
<p>This approach is inefficient due to re-calculating path sums for the same subtrees multiple times. The time complexity is O(N^2) for a skewed tree and O(N log N) for a balanced tree, with O(N) space complexity for the recursion stack in the worst case.</p>
<p><em>(Note: A full code implementation for this approach is omitted as it is highly inefficient and the optimal solution is a significant improvement.)</em></p>
<hr />
<h3>Recursive DFS Approach (Optimal)</h3>
<h4>Explanation</h4>
<p>This optimal approach avoids re-computation by using a single Depth-First Search (DFS) traversal. We design a recursive helper function that, for each node, accomplishes two things:
1.  Calculates the maximum path sum that "pivots" at the current node and updates a global maximum if needed. A pivoting path goes from the left subtree, through the current node, to the right subtree.
2.  Returns the maximum path sum that starts at the current node and extends downwards in a single line (either to the left or right). This value is used by the parent node to compute its own path sums.</p>
<p>Here's the step-by-step breakdown of the recursive helper function <code>max_gain(node)</code>:</p>
<ol>
<li><strong>Base Case:</strong> If <code>node</code> is null, it cannot be part of any path, so we return 0.</li>
<li><strong>Recursive Calls:</strong> Recursively call <code>max_gain</code> for the left and right children.<ul>
<li><code>left_gain = max(0, max_gain(node-&gt;left))</code></li>
<li><code>right_gain = max(0, max_gain(node-&gt;right))</code>
We use <code>max(0, ...)</code> because if a path through a child has a negative sum, we are better off not including that path.</li>
</ul>
</li>
<li><strong>Update Global Maximum:</strong> At the current <code>node</code>, we calculate the maximum path sum that could pivot here: <code>node-&gt;val + left_gain + right_gain</code>. We compare this with our overall <code>max_sum</code> seen so far and update <code>max_sum</code> if this new path is larger.</li>
<li><strong>Return Value:</strong> The function must return the maximum gain a parent node can get by extending a path through the current <code>node</code>. This path cannot branch, so it must be <code>node-&gt;val</code> plus the larger of the two gains from its children: <code>node-&gt;val + max(left_gain, right_gain)</code>.</li>
</ol>
<p>The main function initializes <code>max_sum</code> to a very small number, calls the helper on the root, and returns the final <code>max_sum</code>. This solution visits each node once, resulting in a time complexity of O(N) and a space complexity of O(H) for the recursion stack, where H is the height of the tree.</p>
<h4>C++ Code</h4>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;climits&gt;

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int max_sum;

    int maxPathSum(TreeNode* root) {
        max_sum = INT_MIN;
        max_gain(root);
        return max_sum;
    }

private:
    int max_gain(TreeNode* node) {
        if (!node) {
            return 0;
        }

        // Recursively find the max one-sided path sum from left and right children.
        // If a child's path is negative, we don't include it (hence max(0, ...)).
        int left_gain = std::max(0, max_gain(node-&gt;left));
        int right_gain = std::max(0, max_gain(node-&gt;right));

        // Check if the path pivoting at the current node gives a new max.
        // This path is node-&gt;val + left_gain + right_gain.
        int current_path_sum = node-&gt;val + left_gain + right_gain;
        max_sum = std::max(max_sum, current_path_sum);

        // Return the max gain for a path extending upwards from the current node.
        // This path can only include one of the children's paths.
        return node-&gt;val + std::max(left_gain, right_gain);
    }
};
</code></pre>
<hr />
<h3>Pythonic solution for best approach</h3>
<pre><code class="language-python">from typing import Optional

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:
        # Initialize max_path with a very small number. Using root.val is not safe
        # if the tree has only one negative node, float('-inf') is safer.
        max_path = float('-inf')

        def max_gain(node: Optional[TreeNode]) -&gt; int:
            nonlocal max_path
            if not node:
                return 0

            # Recursively get max gain from left and right subtrees.
            # If a subtree's gain is negative, we don't include it (hence max(..., 0)).
            left_gain = max(max_gain(node.left), 0)
            right_gain = max(max_gain(node.right), 0)

            # Update the overall max_path if the path &quot;pivoting&quot; at the current node is better.
            current_path_sum = node.val + left_gain + right_gain
            max_path = max(max_path, current_path_sum)

            # For the recursion, return the max gain of a path that starts at the
            # current node and goes down one side. The parent can extend this path.
            return node.val + max(left_gain, right_gain)

        max_gain(root)
        return int(max_path)
</code></pre></div>