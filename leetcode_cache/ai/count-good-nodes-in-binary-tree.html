<div class='ai-explanation'><h3>List of all the approaches to solution</h3>
<ol>
<li>Brute Force Approach</li>
<li>Recursive Depth-First Search (DFS)</li>
<li>Iterative Depth-First Search (DFS) with Stack</li>
<li>Iterative Breadth-First Search (BFS) with Queue</li>
</ol>
<hr />
<h3>Brute Force Approach</h3>
<h4>Explanation</h4>
<p>The brute force method involves checking every single node in the tree to see if it meets the "good" node criteria. For each node, we determine the path from the root to it, find the maximum value among all nodes on that path, and then compare it with the current node's value.</p>
<ol>
<li>First, perform a traversal (like Preorder DFS) to collect all nodes of the tree into a list.</li>
<li>Iterate through each node in this list.</li>
<li>For each node, find the path from the root to this specific node. This can be done using another helper DFS function that tracks the path.</li>
<li>Once the path is found, iterate through the nodes on the path to find the maximum value.</li>
<li>If the current node's value is greater than or equal to this path maximum, it's a "good" node. Increment a counter.</li>
<li>After checking all nodes, the counter will hold the total number of good nodes.</li>
</ol>
<p>This approach is highly inefficient because it repeatedly traverses parts of the tree to find paths for each node. The time complexity is O(N*H) and space complexity is O(N), where N is the number of nodes and H is the height of the tree.</p>
<h4>C++ Code Snippet</h4>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int goodNodes(TreeNode* root) {
        if (!root) return 0;

        std::vector&lt;TreeNode*&gt; allNodes;
        getAllNodes(root, allNodes);

        int good_nodes_count = 0;
        for (TreeNode* node : allNodes) {
            std::vector&lt;TreeNode*&gt; path;
            findPath(root, node, path);

            int max_val_on_path = -10001; // Values are between -10^4 and 10^4
            for (TreeNode* path_node : path) {
                max_val_on_path = std::max(max_val_on_path, path_node-&gt;val);
            }

            if (node-&gt;val &gt;= max_val_on_path) {
                good_nodes_count++;
            }
        }
        return good_nodes_count;
    }

private:
    void getAllNodes(TreeNode* node, std::vector&lt;TreeNode*&gt;&amp; allNodes) {
        if (!node) return;
        allNodes.push_back(node);
        getAllNodes(node-&gt;left, allNodes);
        getAllNodes(node-&gt;right, allNodes);
    }

    bool findPath(TreeNode* current, TreeNode* target, std::vector&lt;TreeNode*&gt;&amp; path) {
        if (!current) return false;

        path.push_back(current);
        if (current == target) return true;

        if (findPath(current-&gt;left, target, path) || findPath(current-&gt;right, target, path)) {
            return true;
        }

        path.pop_back(); // Backtrack
        return false;
    }
};
</code></pre>
<hr />
<h3>Recursive Depth-First Search (DFS)</h3>
<h4>Explanation</h4>
<p>A much more efficient approach is to use a single traversal. As we traverse down the tree from the root, we can keep track of the maximum value encountered so far on the path to the current node. This avoids the need to re-calculate the path maximum for every node.</p>
<ol>
<li>Define a recursive helper function, for example <code>countGoodNodes(node, max_so_far)</code>.</li>
<li>The base case for the recursion is when a node is null, in which case we return 0.</li>
<li>In the function, first check if the current <code>node</code> is a "good" node by comparing its value with <code>max_so_far</code>. If <code>node-&gt;val &gt;= max_so_far</code>, we count it.</li>
<li>Update the maximum value for the path to the children by taking <code>max(max_so_far, node-&gt;val)</code>.</li>
<li>Recursively call the function for the left and right children, passing the updated maximum value.</li>
<li>The total count for a subtree is the sum of the good node count at the current node (0 or 1) and the counts returned from the recursive calls on its children.</li>
<li>The initial call will be <code>countGoodNodes(root, -10001)</code>, using a value smaller than any possible node value.</li>
</ol>
<p>This approach traverses each node once, resulting in a time complexity of O(N) and a space complexity of O(H) for the recursion stack, where N is the number of nodes and H is the height of the tree.</p>
<h4>C++ Code Snippet</h4>
<pre><code class="language-cpp">#include &lt;algorithm&gt;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int goodNodes(TreeNode* root) {
        // According to constraints, node values are between -10^4 and 10^4.
        // -10001 is a safe initial value for max_so_far.
        return countGoodNodes(root, -10001);
    }

private:
    int countGoodNodes(TreeNode* node, int max_so_far) {
        if (!node) {
            return 0;
        }

        int count = 0;
        if (node-&gt;val &gt;= max_so_far) {
            count = 1;
        }

        int new_max = std::max(max_so_far, node-&gt;val);

        count += countGoodNodes(node-&gt;left, new_max);
        count += countGoodNodes(node-&gt;right, new_max);

        return count;
    }
};
</code></pre>
<hr />
<h3>Iterative Depth-First Search (DFS) with Stack</h3>
<h4>Explanation</h4>
<p>The recursive DFS logic can be implemented iteratively using a stack to avoid potential stack overflow on very deep trees. The core idea of passing the path's maximum value down remains the same.</p>
<ol>
<li>Initialize a counter for good nodes to 0 and a stack. The stack will store pairs of <code>(TreeNode*, int)</code> representing the node to visit and the maximum value on the path to it.</li>
<li>If the root is not null, push the pair <code>{root, -10001}</code> onto the stack.</li>
<li>Loop as long as the stack is not empty.</li>
<li>In each iteration, pop a pair <code>(node, max_val)</code> from the stack.</li>
<li>If <code>node-&gt;val &gt;= max_val</code>, it's a good node, so increment the counter.</li>
<li>Calculate the new maximum for the path to the children: <code>new_max = max(max_val, node-&gt;val)</code>.</li>
<li>If the node has children, push them onto the stack along with <code>new_max</code>. Push the right child first, then the left, so that the left child is processed first (mimicking preorder traversal).</li>
</ol>
<p>This approach visits each node once, leading to a time complexity of O(N) and a space complexity of O(H) for the stack, where N is the number of nodes and H is the tree's height.</p>
<h4>C++ Code Snippet</h4>
<pre><code class="language-cpp">#include &lt;stack&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int goodNodes(TreeNode* root) {
        if (!root) return 0;

        int count = 0;
        std::stack&lt;std::pair&lt;TreeNode*, int&gt;&gt; s;
        s.push({root, -10001});

        while (!s.empty()) {
            auto [node, max_val] = s.top();
            s.pop();

            if (node-&gt;val &gt;= max_val) {
                count++;
            }

            int new_max = std::max(max_val, node-&gt;val);

            if (node-&gt;right) {
                s.push({node-&gt;right, new_max});
            }
            if (node-&gt;left) {
                s.push({node-&gt;left, new_max});
            }
        }
        return count;
    }
};
</code></pre>
<hr />
<h3>Iterative Breadth-First Search (BFS) with Queue</h3>
<h4>Explanation</h4>
<p>The problem can also be solved using a BFS traversal. Instead of a stack, we use a queue. The principle of carrying the path's maximum value remains identical.</p>
<ol>
<li>Initialize a counter for good nodes to 0 and a queue. The queue will store pairs of <code>(TreeNode*, int)</code>.</li>
<li>If the root is not null, enqueue the pair <code>{root, -10001}</code>.</li>
<li>Loop as long as the queue is not empty.</li>
<li>In each iteration, dequeue a pair <code>(node, max_val)</code>.</li>
<li>If <code>node-&gt;val &gt;= max_val</code>, increment the good nodes counter.</li>
<li>Calculate the new maximum for the path to the children: <code>new_max = max(max_val, node-&gt;val)</code>.</li>
<li>If the node has children, enqueue them into the queue along with <code>new_max</code>.</li>
</ol>
<p>This approach also visits each node once, giving a time complexity of O(N). The space complexity is O(W) for the queue, where W is the maximum width of the tree, which can be up to O(N) in a complete binary tree.</p>
<h4>C++ Code Snippet</h4>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int goodNodes(TreeNode* root) {
        if (!root) return 0;

        int count = 0;
        std::queue&lt;std::pair&lt;TreeNode*, int&gt;&gt; q;
        q.push({root, -10001});

        while (!q.empty()) {
            auto [node, max_val] = q.front();
            q.pop();

            if (node-&gt;val &gt;= max_val) {
                count++;
            }

            int new_max = std::max(max_val, node-&gt;val);

            if (node-&gt;left) {
                q.push({node-&gt;left, new_max});
            }
            if (node-&gt;right) {
                q.push({node-&gt;right, new_max});
            }
        }
        return count;
    }
};
</code></pre>
<hr />
<h3>Pythonic Solution (Best Approach: Recursive DFS)</h3>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def goodNodes(self, root: TreeNode) -&gt; int:
        &quot;&quot;&quot;
        Counts the number of &quot;good&quot; nodes in a binary tree using recursive DFS.
        A node is good if its value is the greatest among all nodes on the path
        from the root to itself.
        &quot;&quot;&quot;

        def dfs(node: TreeNode, max_so_far: int) -&gt; int:
            &quot;&quot;&quot;
            Recursively traverses the tree and counts good nodes.

            Args:
                node: The current node being visited.
                max_so_far: The maximum value on the path from the root to the parent of `node`.

            Returns:
                The number of good nodes in the subtree rooted at `node`.
            &quot;&quot;&quot;
            if not node:
                return 0

            # Check if the current node is good
            is_good = 1 if node.val &gt;= max_so_far else 0

            # Update the maximum value for the path to the children
            new_max = max(max_so_far, node.val)

            # Recursively count good nodes in left and right subtrees
            # The total is the sum of the current node's status and the counts from its children.
            return is_good + dfs(node.left, new_max) + dfs(node.right, new_max)

        # Initial call with a value smaller than any possible node value.
        # Node values are between -10^4 and 10^4.
        return dfs(root, -10001)

</code></pre></div>