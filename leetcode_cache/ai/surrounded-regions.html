<div class='ai-explanation'><h3>List of all the approaches to solution</h3>
<ol>
<li>Brute Force Approach</li>
<li>Border Traversal with Depth-First Search (DFS) Approach</li>
<li>Border Traversal with Breadth-First Search (BFS) Approach</li>
</ol>
<h3>Brute Force Approach</h3>
<p>This approach iterates through every cell of the board. If an 'O' is found that hasn't been visited yet, we start a traversal (like DFS or BFS) to find all connected 'O's, forming a region. During the traversal, we keep track of all cells in the region and check if any of them are on the border. If, after exploring the entire region, no cell was found on the border, we know the region is surrounded and we can flip all its 'O's to 'X's. A <code>visited</code> grid is necessary to avoid re-processing the same region.</p>
<ol>
<li>Initialize a <code>visited</code> grid of the same dimensions as the <code>board</code>, with all values set to <code>false</code>.</li>
<li>Iterate through each cell <code>(i, j)</code> of the board.</li>
<li>If <code>board[i][j]</code> is 'O' and <code>visited[i][j]</code> is <code>false</code>:<ul>
<li>Start a traversal (e.g., DFS) from <code>(i, j)</code>.</li>
<li>Use a temporary list, <code>region_cells</code>, to store the coordinates of all 'O's in the current region.</li>
<li>Use a boolean flag, <code>is_surrounded</code>, initialized to <code>true</code>.</li>
<li>During the traversal, if any 'O' cell is on the border, set <code>is_surrounded</code> to <code>false</code>. Mark all visited cells in the <code>visited</code> grid.</li>
<li>After the traversal is complete, if <code>is_surrounded</code> is still <code>true</code>, iterate through <code>region_cells</code> and change the corresponding cells on the <code>board</code> from 'O' to 'X'.
This approach can be inefficient as it might explore the same "safe" regions multiple times before finding a border connection. The time complexity is asymptotically the same as the optimal solution but with higher constant factors and more complex logic.</li>
</ul>
</li>
</ol>
<p>The time complexity is O(M * N) because each cell is visited a constant number of times. The space complexity is O(M * N) for the <code>visited</code> grid and the recursion stack.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

class Solution {
public:
    void solve(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board) {
        if (board.empty() || board[0].empty()) {
            return;
        }
        int m = board.size();
        int n = board[0].size();
        std::vector&lt;std::vector&lt;bool&gt;&gt; visited(m, std::vector&lt;bool&gt;(n, false));

        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (board[i][j] == 'O' &amp;&amp; !visited[i][j]) {
                    std::vector&lt;std::pair&lt;int, int&gt;&gt; region_cells;
                    bool is_surrounded = true;
                    dfs(board, i, j, visited, region_cells, is_surrounded);

                    if (is_surrounded) {
                        for (auto&amp; cell : region_cells) {
                            board[cell.first][cell.second] = 'X';
                        }
                    }
                }
            }
        }
    }

private:
    void dfs(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board, int r, int c, 
             std::vector&lt;std::vector&lt;bool&gt;&gt;&amp; visited, 
             std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; region_cells, 
             bool&amp; is_surrounded) {

        int m = board.size();
        int n = board[0].size();

        if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || visited[r][c] || board[r][c] == 'X') {
            return;
        }

        if (r == 0 || r == m - 1 || c == 0 || c == n - 1) {
            is_surrounded = false;
        }

        visited[r][c] = true;
        region_cells.push_back({r, c});

        dfs(board, r + 1, c, visited, region_cells, is_surrounded);
        dfs(board, r - 1, c, visited, region_cells, is_surrounded);
        dfs(board, r, c + 1, visited, region_cells, is_surrounded);
        dfs(board, r, c - 1, visited, region_cells, is_surrounded);
    }
};
</code></pre>
<h3>Border Traversal with Depth-First Search (DFS) Approach</h3>
<p>The key insight is that any 'O' that is on the border, or is connected to an 'O' on the border, cannot be captured. All other 'O's are surrounded. This approach flips the problem: instead of finding surrounded regions, we find all <em>un-surrounded</em> regions and protect them, then flip the rest.</p>
<ol>
<li>Iterate through the cells on the four borders of the grid (top, bottom, left, right).</li>
<li>If a border cell contains an 'O', it's part of an "unsafe" region. Start a DFS from this cell.</li>
<li>In the DFS traversal, change every connected 'O' to a temporary marker, say '#'. This marks the entire region as safe.</li>
<li>After scanning all borders and marking all "unsafe" 'O's, iterate through the entire grid one more time.</li>
<li>If a cell is an 'O', it was not connected to any border 'O', so it must be a surrounded region. Flip it to 'X'.</li>
<li>If a cell is a '#', it was part of an "unsafe" region. Flip it back to 'O'.</li>
</ol>
<p>The time complexity is O(M * N) as each cell is visited at most twice. The space complexity is O(M * N) in the worst case for the recursion stack.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;

class Solution {
public:
    void solve(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board) {
        if (board.empty() || board[0].empty()) {
            return;
        }
        int m = board.size();
        int n = board[0].size();

        // 1. Mark 'O's on the border and their connected 'O's
        for (int i = 0; i &lt; m; ++i) {
            if (board[i][0] == 'O') dfs(board, i, 0);
            if (board[i][n - 1] == 'O') dfs(board, i, n - 1);
        }
        for (int j = 0; j &lt; n; ++j) {
            if (board[0][j] == 'O') dfs(board, 0, j);
            if (board[m - 1][j] == 'O') dfs(board, m - 1, j);
        }

        // 2. Flip remaining 'O's to 'X's and '#'s back to 'O's
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                } else if (board[i][j] == '#') {
                    board[i][j] = 'O';
                }
            }
        }
    }

private:
    void dfs(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board, int r, int c) {
        int m = board.size();
        int n = board[0].size();

        if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != 'O') {
            return;
        }

        board[r][c] = '#'; // Mark as safe

        dfs(board, r + 1, c);
        dfs(board, r - 1, c);
        dfs(board, r, c + 1);
        dfs(board, r, c - 1);
    }
};
</code></pre>
<h3>Border Traversal with Breadth-First Search (BFS) Approach</h3>
<p>This approach is identical in logic to the DFS-based border traversal but uses a queue for an iterative traversal instead of recursion. This can be advantageous as it avoids potential stack overflow issues on very large grids where a region might be extremely deep.</p>
<ol>
<li>Create a queue and add the coordinates of all 'O's on the borders to it.</li>
<li>While adding, change these border 'O's to a temporary marker '#' to prevent re-processing.</li>
<li>While the queue is not empty, dequeue a cell <code>(r, c)</code>.</li>
<li>Explore its four neighbors <code>(nr, nc)</code>.</li>
<li>If a neighbor is within bounds and is an 'O', change it to '#' and enqueue it.</li>
<li>After the BFS is complete, all 'O's connected to the border will have been marked with '#'.</li>
<li>Iterate through the entire board. Flip any remaining 'O' to 'X' and any '#' back to 'O'.</li>
</ol>
<p>The time complexity is O(M * N) because each cell is visited a constant number of times. The space complexity is O(M * N) in the worst case for the queue.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;queue&gt;

class Solution {
public:
    void solve(std::vector&lt;std::vector&lt;char&gt;&gt;&amp; board) {
        if (board.empty() || board[0].empty()) {
            return;
        }
        int m = board.size();
        int n = board[0].size();

        std::queue&lt;std::pair&lt;int, int&gt;&gt; q;

        // 1. Add 'O's on the border to the queue and mark them
        for (int i = 0; i &lt; m; ++i) {
            if (board[i][0] == 'O') {
                board[i][0] = '#';
                q.push({i, 0});
            }
            if (board[i][n - 1] == 'O') {
                board[i][n - 1] = '#';
                q.push({i, n - 1});
            }
        }
        for (int j = 0; j &lt; n; ++j) {
            if (board[0][j] == 'O') {
                board[0][j] = '#';
                q.push({0, j});
            }
            if (board[m - 1][j] == 'O') {
                board[m - 1][j] = '#';
                q.push({m - 1, j});
            }
        }

        int dr[] = {0, 0, 1, -1};
        int dc[] = {1, -1, 0, 0};

        // 2. Perform BFS to mark all connected 'O's
        while (!q.empty()) {
            std::pair&lt;int, int&gt; curr = q.front();
            q.pop();

            for (int i = 0; i &lt; 4; ++i) {
                int nr = curr.first + dr[i];
                int nc = curr.second + dc[i];

                if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp; board[nr][nc] == 'O') {
                    board[nr][nc] = '#';
                    q.push({nr, nc});
                }
            }
        }

        // 3. Flip remaining 'O's to 'X's and '#'s back to 'O's
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                } else if (board[i][j] == '#') {
                    board[i][j] = 'O';
                }
            }
        }
    }
};
</code></pre>
<h3>Pythonic Solution (Best Approach)</h3>
<p>The best approach is the Border Traversal (either with DFS or BFS). The following Python solution uses an iterative approach that functions like a DFS (due to using <code>list.pop()</code>) to mark all 'O' regions connected to the border. It's concise and efficient.</p>
<ol>
<li>Handle the edge case of an empty board.</li>
<li>Create a stack/queue (<code>to_visit</code>) and populate it with the coordinates of all 'O's on the border.</li>
<li>While <code>to_visit</code> is not empty, pop a cell. If it's a valid, unvisited 'O', mark it as safe (e.g., with 'S') and add its neighbors to <code>to_visit</code>.</li>
<li>After the traversal, iterate through the board. Convert safe cells ('S') back to 'O' and all other cells (which were originally 'O' but not marked 'S') to 'X'.</li>
</ol>
<pre><code class="language-python">from collections import deque

class Solution:
    def solve(self, board: list[list[str]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        if not board or not board[0]:
            return

        m, n = len(board), len(board[0])

        # A queue for BFS traversal starting from the border 'O's
        to_visit = deque()

        # Step 1: Find all 'O's on the border and add them to the queue
        for r in range(m):
            for c in range(n):
                if (r == 0 or r == m - 1 or c == 0 or c == n - 1) and board[r][c] == 'O':
                    to_visit.append((r, c))
                    board[r][c] = 'S' # Mark as Safe

        # Step 2: Run BFS to mark all 'O's connected to the border 'O's
        while to_visit:
            r, c = to_visit.popleft()

            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc

                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == 'O':
                    board[nr][nc] = 'S' # Mark as Safe
                    to_visit.append((nr, nc))

        # Step 3: Flip the remaining 'O's to 'X's and safe 'S's back to 'O's
        for r in range(m):
            for c in range(n):
                if board[r][c] == 'S':
                    board[r][c] = 'O'
                elif board[r][c] == 'O':
                    board[r][c] = 'X'

</code></pre></div>