<div class='ai-explanation'><h3>List of all the approaches to solution</h3>
<ol>
<li>Brute Force Approach (Dynamic Programming)</li>
<li>Greedy Approach (Sorting by End Time)</li>
</ol>
<hr />
<h3>Brute Force Approach (Dynamic Programming)</h3>
<p>This approach is based on a concept similar to the Longest Increasing Subsequence (LIS) problem. The core idea is to first sort the intervals by their start times. Then, we use dynamic programming to find the maximum number of non-overlapping intervals. We define <code>dp[i]</code> as the maximum number of non-overlapping intervals we can form in the subarray <code>intervals[0...i]</code>, including the interval <code>i</code>.</p>
<h4>Step-by-step explanation:</h4>
<ol>
<li>Sort the <code>intervals</code> array based on the start times. If start times are equal, sorting by end time is a good practice.</li>
<li>Create a DP array, <code>dp</code>, of the same size as <code>intervals</code>, and initialize all its elements to 1. This is because any single interval is by itself a valid non-overlapping set of size 1.</li>
<li>Iterate through the intervals from the second one (<code>i = 1</code> to <code>n-1</code>).</li>
<li>For each interval <code>i</code>, iterate through all previous intervals <code>j</code> (from <code>0</code> to <code>i-1</code>).</li>
<li>If <code>intervals[j]</code> does not overlap with <code>intervals[i]</code> (i.e., <code>intervals[j][1] &lt;= intervals[i][0]</code>), it means we can potentially extend the non-overlapping set ending at <code>j</code> with the current interval <code>i</code>.</li>
<li>Update <code>dp[i]</code> with the maximum length found so far: <code>dp[i] = max(dp[i], 1 + dp[j])</code>.</li>
<li>After filling the <code>dp</code> array, the maximum value in it represents the size of the largest set of non-overlapping intervals.</li>
<li>The minimum number of intervals to remove is the total number of intervals minus this maximum value.
This approach is correct but less efficient due to the nested loops. The time complexity is O(N<sup>2</sup>) and the space complexity is O(N).</li>
</ol>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Solution {
public:
    int eraseOverlapIntervals(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.empty()) {
            return 0;
        }

        // Step 1: Sort by start times
        std::sort(intervals.begin(), intervals.end());

        int n = intervals.size();
        // Step 2: Initialize DP array
        std::vector&lt;int&gt; dp(n, 1);
        int max_non_overlapping = 1;

        // Step 3 &amp; 4: Iterate and fill DP table
        for (int i = 1; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                // Step 5: Check for non-overlap
                if (intervals[j][1] &lt;= intervals[i][0]) {
                    // Step 6: Update dp[i]
                    dp[i] = std::max(dp[i], 1 + dp[j]);
                }
            }
            max_non_overlapping = std::max(max_non_overlapping, dp[i]);
        }

        // Step 8: Calculate result
        return n - max_non_overlapping;
    }
};
</code></pre>
<hr />
<h3>Greedy Approach (Sorting by End Time)</h3>
<p>The problem asks for the minimum number of intervals to remove, which is equivalent to finding the maximum number of non-overlapping intervals to keep. A greedy approach works perfectly here. The intuition is that to maximize the number of intervals we can fit, we should always choose the interval that finishes the earliest. This leaves the maximum possible room for subsequent intervals.</p>
<h4>Step-by-step explanation:</h4>
<ol>
<li>Sort the <code>intervals</code> array based on their end times in ascending order. This is the crucial greedy choice.</li>
<li>Initialize a counter <code>count</code> for non-overlapping intervals to 1, as we will always keep the first interval in the sorted list.</li>
<li>Store the end time of this first interval in a variable, let's call it <code>prev_end</code>.</li>
<li>Iterate through the sorted intervals starting from the second one.</li>
<li>For each interval, compare its start time with <code>prev_end</code>.</li>
<li>If the current interval's start time is greater than or equal to <code>prev_end</code>, it means there is no overlap. We can "keep" this interval. Increment <code>count</code> and update <code>prev_end</code> to the end time of the current interval.</li>
<li>If the current interval's start time is less than <code>prev_end</code>, it overlaps with the last chosen interval. We must "remove" one. Since we sorted by end times, the current interval will always finish later than or at the same time as the one we already kept. By doing nothing, we are effectively discarding the current, longer interval and sticking with our earlier choice that frees up time sooner.</li>
<li>After the loop, <code>count</code> will hold the maximum number of non-overlapping intervals. The minimum number to remove is <code>total_intervals - count</code>.
The time complexity is dominated by the sort, making it O(N log N), and the space complexity is O(1) or O(log N) depending on the sort implementation.</li>
</ol>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Solution {
public:
    // Custom comparator to sort by the second element (end time)
    static bool cmp(std::vector&lt;int&gt;&amp; a, std::vector&lt;int&gt;&amp; b) {
        return a[1] &lt; b[1];
    }

    int eraseOverlapIntervals(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.empty()) {
            return 0;
        }

        int n = intervals.size();

        // Step 1: Sort intervals by their end times
        std::sort(intervals.begin(), intervals.end(), cmp);

        // Step 2 &amp; 3: Initialize count and the end of the first interval
        int count = 1;
        int prev_end = intervals[0][1];

        // Step 4: Iterate through the rest of the intervals
        for (int i = 1; i &lt; n; i++) {
            // Step 5 &amp; 6: Check for non-overlap
            if (intervals[i][0] &gt;= prev_end) {
                // This interval can be kept
                count++;
                prev_end = intervals[i][1];
            }
            // Step 7: If it overlaps, do nothing (implicitly discard it)
        }

        // Step 8: The number of intervals to remove is total - kept
        return n - count;
    }
};
</code></pre>
<hr />
<h3>Pythonic solution for best approach</h3>
<p>The most optimal solution is the greedy approach. The Python implementation is concise, using a <code>lambda</code> function for sorting, which is a common and readable pattern.</p>
<pre><code class="language-python">from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
        if not intervals:
            return 0

        # Sort intervals based on their end times
        intervals.sort(key=lambda x: x[1])

        n = len(intervals)
        count = 1  # Number of non-overlapping intervals kept
        prev_end = intervals[0][1]

        for i in range(1, n):
            # If the current interval's start is after or at the previous one's end
            if intervals[i][0] &gt;= prev_end:
                # We can keep this interval
                count += 1
                prev_end = intervals[i][1]

        # The number of intervals to remove is the total minus the number we kept
        return n - count

</code></pre></div>