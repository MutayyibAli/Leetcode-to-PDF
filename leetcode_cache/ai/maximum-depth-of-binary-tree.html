<div class='ai-explanation'><h3>List of approaches to solution:</h3>
<ol>
<li>Brute Force Approach (Recursive Depth-First Search)</li>
<li>Iterative Breadth-First Search (BFS) Approach</li>
</ol>
<hr />
<h3>Brute Force Approach (Recursive Depth-First Search)</h3>
<p>This approach directly translates the definition of a tree's maximum depth into a recursive algorithm. The depth of a tree is defined as 1 (for the root) plus the maximum of the depths of its left and right subtrees. Although this is the most straightforward and intuitive approach, it is also highly efficient.</p>
<ol>
<li><strong>Base Case:</strong> If the current node (<code>root</code>) is null, it represents an empty tree or the end of a path, so its depth is 0.</li>
<li><strong>Recursive Step:</strong> If the node is not null, recursively calculate the maximum depth of its left subtree (<code>left_depth</code>).</li>
<li>Recursively calculate the maximum depth of its right subtree (<code>right_depth</code>).</li>
<li>The depth of the tree rooted at the current node is <code>1 + max(left_depth, right_depth)</code>. The <code>1</code> accounts for the current node itself.</li>
</ol>
<p>This process continues until all paths have been explored, and the final value returned from the initial call on the root is the maximum depth of the entire tree.</p>
<p>The time complexity is O(N), where N is the number of nodes, as we visit each node exactly once. The space complexity is O(H) in the average case (for a balanced tree) and O(N) in the worst case (for a skewed tree), where H is the height of the tree, due to the recursion call stack.</p>
<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // Base case: if the node is null, depth is 0
        if (root == NULL) {
            return 0;
        }

        // Recursively find the depth of the left and right subtrees
        int left_depth = maxDepth(root-&gt;left);
        int right_depth = maxDepth(root-&gt;right);

        // The depth of the tree is 1 (current node) + the max of the two subtrees
        return std::max(left_depth, right_depth) + 1;
    }
};
</code></pre>
<hr />
<h3>Iterative Breadth-First Search (BFS) Approach</h3>
<p>An alternative to recursion is an iterative approach using Breadth-First Search (BFS). BFS explores the tree level by level. The maximum depth is simply the total number of levels in the tree.</p>
<ol>
<li><strong>Initialization:</strong> If the root is null, return 0. Otherwise, create a queue and add the root node to it. Initialize a <code>depth</code> counter to 0.</li>
<li><strong>Level-Order Traversal:</strong> Loop as long as the queue is not empty. In each iteration, the nodes in the queue represent a complete level of the tree.</li>
<li><strong>Process a Level:</strong><ul>
<li>Increment the <code>depth</code> counter.</li>
<li>Find the number of nodes at the current level (<code>level_size = queue.size()</code>).</li>
<li>Loop <code>level_size</code> times to process all nodes at the current level.</li>
<li>For each node, dequeue it and enqueue its non-null left and right children.</li>
</ul>
</li>
<li><strong>Return Depth:</strong> After the loop finishes (meaning all levels have been processed), the <code>depth</code> counter will hold the maximum depth of the tree.</li>
</ol>
<p>The time complexity is O(N) because each node is visited exactly once. The space complexity is O(W), where W is the maximum width of the tree, which can be up to O(N) in the case of a complete binary tree.</p>
<pre><code class="language-cpp">#include &lt;queue&gt;

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }

        std::queue&lt;TreeNode*&gt; q;
        q.push(root);
        int depth = 0;

        while (!q.empty()) {
            depth++;
            int level_size = q.size();
            for (int i = 0; i &lt; level_size; ++i) {
                TreeNode* current = q.front();
                q.pop();

                if (current-&gt;left != NULL) {
                    q.push(current-&gt;left);
                }
                if (current-&gt;right != NULL) {
                    q.push(current-&gt;right);
                }
            }
        }
        return depth;
    }
};
</code></pre>
<hr />
<h3>Pythonic Solution (Best Approach)</h3>
<p>The recursive DFS approach is the most concise and elegant solution. It naturally reflects the recursive structure of a tree, making it a highly Pythonic way to solve this problem.</p>
<pre><code class="language-python">from typing import Optional

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:
        &quot;&quot;&quot;
        Calculates the maximum depth of a binary tree using recursion (DFS).
        &quot;&quot;&quot;
        # Base case: an empty tree has a depth of 0
        if not root:
            return 0

        # Recursively find the depth of the left and right subtrees
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)

        # The depth of the tree is 1 (for the current node) plus the maximum
        # depth of its left and right subtrees.
        return 1 + max(left_depth, right_depth)

</code></pre></div>