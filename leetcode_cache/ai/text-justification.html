<div class='ai-explanation'><h3>Explanation of Approaches</h3>
<p>The problem of text justification can be solved using a greedy approach. We build the text line by line, packing as many words as possible onto each line before formatting it according to the given rules. The overall algorithm can be broken down into two main parts: grouping words for a line and then formatting that line.</p>
<h4>1. Greedy Word Grouping</h4>
<p>We iterate through the words, deciding which words belong to the current line. Starting with an empty line, we add words one by one as long as they fit within the <code>maxWidth</code>. A new word fits if the current line's length plus the new word's length plus a space character does not exceed <code>maxWidth</code>. This process continues until we find a word that is too long to fit. The words collected so far form the group for the current line.</p>
<h4>2. Line Formatting</h4>
<p>Once we have a group of words for a line, we must format it. There are two distinct formatting scenarios:</p>
<ul>
<li>
<p><strong>Full Justification (for regular lines):</strong></p>
<ul>
<li>This applies to all lines except the last one, provided they contain more than one word.</li>
<li>The goal is to distribute spaces evenly between words to make the line's total length exactly <code>maxWidth</code>.</li>
<li>First, calculate the total number of spaces needed: <code>totalSpaces = maxWidth - totalLengthOfWords</code>.</li>
<li>Then, calculate the number of gaps between words, which is <code>numWords - 1</code>.</li>
<li>The spaces are distributed as evenly as possible. Each gap gets a base number of spaces (<code>totalSpaces / numGaps</code>).</li>
<li>The remaining <code>totalSpaces % numGaps</code> spaces are distributed one by one to the gaps on the left side of the line until they run out.</li>
</ul>
</li>
<li>
<p><strong>Left Justification (for the last line or single-word lines):</strong></p>
<ul>
<li>This simpler formatting applies to the last line of the text or any line that ends up with only a single word.</li>
<li>Words are joined by a single space.</li>
<li>The entire line is then padded with trailing spaces on the right to match <code>maxWidth</code>.</li>
</ul>
</li>
</ul>
<p>This process of grouping and formatting is repeated until all words are processed.</p>
<h3>Time and Space Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity:</strong> O(N * M), where <code>N</code> is the number of words and <code>M</code> is <code>maxWidth</code>. We iterate through each word once. For each line we form, we perform formatting and string construction, which takes O(M) time. Since there can be up to N lines in the worst case (one word per line), the total time complexity is O(N * M).</p>
</li>
<li>
<p><strong>Space Complexity:</strong> O(N * M). This complexity is driven by the storage required for the output. The resulting list of strings can contain up to <code>N</code> lines, each of length <code>M</code>. The auxiliary space needed to build each line is O(M).</p>
</li>
</ul>
<h3>C++ Code</h3>
<p>```cpp</p>
<h1>include <vector></h1>
<h1>include <string></h1>
<p>class Solution {
public:
    std::vector<std::string> fullJustify(std::vector<std::string>&amp; words, int maxWidth) {
        std::vector<std::string> result;
        int i = 0;
        int n = words.size();</p>
<pre><code>    while (i &lt; n) {
        int j = i;
        int line_length = 0;
        // Greedily find words for the current line
        // (j - i) represents the minimum spaces between words
        while (j &lt; n &amp;&amp; line_length + words[j].length() + (j - i) &lt;= maxWidth) {
            line_length += words[j].length();
            j++;
        }

        std::string current_line;
        int num_words = j - i;
        int total_spaces = maxWidth - line_length;

        // Case 1: Last line or single-word line -&gt; left-justified
        if (num_words == 1 || j == n) {
            current_line += words[i];
            for (int k = i + 1; k &lt; j; ++k) {
                current_line += " ";
                current_line += words[k];
            }
            current_line.append(maxWidth - current_line.length(), ' ');
        } 
        // Case 2: Regular line -&gt; fully justified
        else {
            int num_gaps = num_words - 1;
            int base_spaces = total_spaces / num_gaps;
            int extra_spaces = total_spaces % num_gaps;

            current_line += words[i];
            for (int k = i + 1; k &lt; j; ++k) {
                current_line.append(base_spaces, ' ');
                if (extra_spaces &gt; 0) {
                    current_line += ' ';
                    extra_spaces--;
                }
                current_line += words[k];
            }
        }
        result.push_back(current_line);
        i = j;
    }
    return result;
}
</code></pre>
<p>};
```</p>
<h3>Python Code</h3>
<p>```python
from typing import List</p>
<p>class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -&gt; List[str]:
        result = []
        i = 0
        n = len(words)</p>
<pre><code>    while i &lt; n:
        j = i
        line_length = 0
        # Greedily find words for the current line
        # (j - i) represents the minimum spaces between words
        while j &lt; n and line_length + len(words[j]) + (j - i) &lt;= maxWidth:
            line_length += len(words[j])
            j += 1

        num_words = j - i
        total_spaces = maxWidth - line_length

        # Case 1: Last line or single-word line -&gt; left-justified
        if num_words == 1 or j == n:
            line = " ".join(words[i:j])
            result.append(line.ljust(maxWidth))
        # Case 2: Regular line -&gt; fully justified
        else:
            num_gaps = num_words - 1
            base_spaces = total_spaces // num_gaps
            extra_spaces = total_spaces % num_gaps

            line = words[i]
            for k in range(i + 1, j):
                spaces_to_add = base_spaces
                if extra_spaces &gt; 0:
                    spaces_to_add += 1
                    extra_spaces -= 1
                line += " " * spaces_to_add + words[k]
            result.append(line)

        i = j

    return result
</code></pre>
<p>```</p></div><p style="page-break-before: always" ></p>