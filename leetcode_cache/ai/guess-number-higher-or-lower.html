<div class='ai-explanation'><h3>List of Approaches</h3>
<ol>
<li>Brute Force Approach</li>
<li>Binary Search Approach</li>
</ol>
<hr />
<h4>1. Brute Force Approach</h4>
<p>This approach involves checking every possible number from 1 to <code>n</code> until the correct number is found.</p>
<p><strong>Step-by-step explanation:</strong>
1.  Use a loop to iterate through each number, let's call it <code>i</code>, from 1 up to <code>n</code>.
2.  In each iteration, call the pre-defined <code>guess(i)</code> API.
3.  If <code>guess(i)</code> returns <code>0</code>, it means <code>i</code> is the correct number, so we return <code>i</code>.
4.  If the result is not <code>0</code>, we continue to the next number.
5.  Since the problem guarantees that a number is picked, the loop will always find the number.</p>
<p>This method is straightforward but will be too slow if <code>n</code> is large, likely resulting in a "Time Limit Exceeded" error. The time complexity is O(n) and the space complexity is O(1).</p>
<pre><code class="language-cpp">/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return       -1 if num is higher than the picked number
 *                1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

class Solution {
public:
    int guessNumber(int n) {
        for (int i = 1; i &lt;= n; i++) {
            if (guess(i) == 0) {
                return i;
            }
        }
        return -1; // This line is unreachable given the problem constraints
    }
};
</code></pre>
<hr />
<h4>2. Binary Search Approach</h4>
<p>A much more efficient approach is to use binary search. The <code>guess</code> API provides feedback (higher or lower) that allows us to eliminate half of the remaining search space with each guess, which is the core idea behind binary search.</p>
<p><strong>Step-by-step explanation:</strong>
1.  Initialize two pointers, <code>low = 1</code> and <code>high = n</code>, which represent the current range of possible numbers.
2.  Enter a loop that continues as long as <code>low</code> is less than or equal to <code>high</code>.
3.  Calculate the middle number of the current range: <code>mid = low + (high - low) / 2</code>. This calculation prevents potential integer overflow that could occur with <code>(low + high) / 2</code>.
4.  Call the <code>guess(mid)</code> API to check the middle number.
5.  If <code>guess(mid)</code> returns <code>0</code>, we have found the correct number, and we return <code>mid</code>.
6.  If <code>guess(mid)</code> returns <code>-1</code>, our guess (<code>mid</code>) is too high. This means the target number must be in the lower half of the current range. We discard the upper half by setting <code>high = mid - 1</code>.
7.  If <code>guess(mid)</code> returns <code>1</code>, our guess (<code>mid</code>) is too low. The target must be in the upper half. We discard the lower half by setting <code>low = mid + 1</code>.
8.  The loop repeats, narrowing the search range until the number is found.</p>
<p>This approach drastically reduces the number of guesses required compared to the brute-force method. The time complexity is O(log n) and the space complexity is O(1).</p>
<pre><code class="language-cpp">/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return       -1 if num is higher than the picked number
 *                1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

class Solution {
public:
    int guessNumber(int n) {
        int low = 1, high = n;
        while (low &lt;= high) {
            int mid = low + (high - low) / 2;
            int result = guess(mid);
            if (result == 0) {
                return mid;
            } else if (result == -1) { // Our guess is higher than the picked number
                high = mid - 1;
            } else { // Our guess is lower than the picked number
                low = mid + 1;
            }
        }
        return -1; // This line is unreachable given the problem constraints
    }
};
</code></pre>
<hr />
<h3>Pythonic Solution (Binary Search)</h3>
<p>This is the Python implementation of the optimal Binary Search approach. It follows the same logic of narrowing down the search space until the correct number is found.</p>
<pre><code class="language-python"># The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -&gt; int:

class Solution:
    def guessNumber(self, n: int) -&gt; int:
        low, high = 1, n

        while low &lt;= high:
            # Using integer division //
            # This formula avoids potential overflow in languages with fixed-size integers
            mid = low + (high - low) // 2

            result = guess(mid)

            if result == 0:
                # Found the number
                return mid
            elif result == -1:
                # The guess is too high, so the number is in the lower half
                high = mid - 1
            else: # result == 1
                # The guess is too low, so the number is in the upper half
                low = mid + 1

        return -1 # Should be unreachable based on problem description
</code></pre></div>